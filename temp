package com.alphacredit.util;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.Enumeration;
import java.util.UUID;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * Provides a minimal, verifiably safe ZIP extraction utility.
 * Designed to be Fortify- and Sonar-clean, and compliant with CERT FIO00-J.
 */
public final class SafeExtractor {

    private SafeExtractor() {}

    /**
     * Extracts all entries from a ZIP file into a trusted target directory.
     * Each entry is validated and written to a generated safe filename.
     *
     * @param zipFile   trusted Path to an existing ZIP file
     * @param targetDir trusted base directory for extracted files
     * @return the Path of the extraction root
     * @throws IOException if validation fails or a read/write error occurs
     */
    public static Path extractZipEntrySafely(Path zipFile, Path targetDir) throws IOException {
        // --- 1. Validate trusted parameters (no external strings)
        if (zipFile == null || targetDir == null) {
            throw new IOException("Null parameter");
        }
        if (!Files.isReadable(zipFile) || !Files.isRegularFile(zipFile)) {
            throw new IOException("Invalid ZIP file: " + zipFile);
        }

        // --- 2. Prepare trusted base directory
        Files.createDirectories(targetDir);
        Path baseCanonical = targetDir.toRealPath(LinkOption.NOFOLLOW_LINKS);

        // --- 3. Extraction limits
        final int    MAX_ENTRIES = 10_000;
        final long   MAX_TOTAL_SIZE = 1_000_000_000L; // 1 GB
        final double MAX_RATIO = 10.0;

        long totalBytes = 0;
        int count = 0;

        // --- 4. Use ZipFile for controlled enumeration
        try (ZipFile zf = new ZipFile(zipFile.toFile(), StandardCharsets.UTF_8)) {
            Enumeration<? extends ZipEntry> entries = zf.entries();
            byte[] buffer = new byte[4096];

            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();

                // --- 5. Skip directories and invalid entries early
                if (entry.isDirectory() || entry.getName() == null || entry.getName().isBlank()) {
                    continue;
                }

                // --- 6. Reject suspicious metadata (bomb, traversal, encoding)
                if (entry.getSize() > MAX_TOTAL_SIZE
                        || entry.getCompressedSize() > MAX_TOTAL_SIZE
                        || entry.getName().contains("..")
                        || entry.getName().contains(":")
                        || entry.getName().startsWith("/")
                        || entry.getName().startsWith("\\")) {
                    throw new IOException("Unsafe entry detected: " + entry.getName());
                }

                // --- 7. Create safe deterministic filename (no external data used)
                String safeName = UUID.nameUUIDFromBytes(
                        entry.getName().getBytes(StandardCharsets.UTF_8)).toString();
                String extension = getExtension(entry.getName());
                Path outFile = baseCanonical.resolve(safeName + extension);

                // containment check
                Path canonicalOut = outFile.toRealPath(LinkOption.NOFOLLOW_LINKS)
                        .getParent();
                if (canonicalOut == null || !canonicalOut.startsWith(baseCanonical)) {
                    throw new IOException("Output escapes base directory");
                }

                Files.createDirectories(outFile.getParent());

                // --- 8. Stream copy with zip-bomb ratio checks
                try (InputStream is = zf.getInputStream(entry);
                     OutputStream os = new BufferedOutputStream(Files.newOutputStream(outFile,
                             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING))) {
                    int bytesRead;
                    long uncompressed = 0;
                    long compressed = entry.getCompressedSize();

                    while ((bytesRead = is.read(buffer)) > 0) {
                        os.write(buffer, 0, bytesRead);
                        uncompressed += bytesRead;
                        totalBytes += bytesRead;

                        if (compressed > 0 && (double) uncompressed / compressed > MAX_RATIO) {
                            throw new IOException("Zip bomb detected: " + entry.getName());
                        }
                        if (totalBytes > MAX_TOTAL_SIZE) {
                            throw new IOException("Archive too large");
                        }
                    }
                }

                count++;
                if (count > MAX_ENTRIES) {
                    throw new IOException("Too many entries");
                }
            }
        }

        return baseCanonical;
    }

    // Helper to preserve original extension safely
    private static String getExtension(String name) {
        int dot = name.lastIndexOf('.');
        return (dot >= 0 && dot < name.length() - 1)
                ? name.substring(dot)
                : "";
    }
}
