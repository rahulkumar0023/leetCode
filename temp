Excellent ‚Äî that stack trace is actually very helpful üëè

Here‚Äôs what‚Äôs happening (and how to fix it cleanly).

---

## üß© Root Cause

Your test fails on this line inside **`PGPConfig.pgpEncrypt()`**:

```
PfPGPPublicKey gPGPPublicKey = KeysManagerUtils.loadPublicKeyFromAsc(loader.getResource(pgpPublicKeyPath).getFile());
PGPEncrypt pgpEncrypt = new PGPEncryptBuilder(gPGPPublicKey).build();
```

The error:

```
java.lang.NullPointerException: pfPGPPublicKey doesn't contain an encryption key
```

comes **from the real `PGPEncryptBuilder`**, not from your mock ‚Äî which means your static mock didn‚Äôt intercept `KeysManagerUtils.loadPublicKeyFromAsc(...)`.

As a result, the real method returned a `PfPGPPublicKey` object with no actual key material ‚Üí builder fails internally.

---

## ‚úÖ How to Fix

To properly intercept the static call, you must:

1. Mock **`KeysManagerUtils.loadPublicKeyFromAsc(File)`** before `PGPEncryptBuilder` is called.
2. Ensure you‚Äôre using **Mockito‚Äôs inline static mocking** (requires `mockito-inline` dependency).
3. Remove unnecessary mocks if the builder isn‚Äôt mocked (let it return a dummy object safely).

---

### ‚úÖ Working, simplified and robust test (copy this):

```java
@Test
void shouldLoadPublicKeyAndBuildEncryptBean() throws Exception {
    // Arrange
    File mockFile = new File("public.asc");
    when(resourceLoader.getResource("classpath:keys/public.asc")).thenReturn(mockResource);
    when(mockResource.getFile()).thenReturn(mockFile);

    // Mock static method in KeysManagerUtils
    PfPGPPublicKey mockPublicKey = mock(PfPGPPublicKey.class);
    try (MockedStatic<KeysManagerUtils> keysManagerMock = mockStatic(KeysManagerUtils.class)) {
        keysManagerMock.when(() -> KeysManagerUtils.loadPublicKeyFromAsc(mockFile))
                .thenReturn(mockPublicKey);

        // Act
        PGPEncrypt result = pgpConfig.pgpEncrypt(resourceLoader);

        // Assert
        assertThat(result).isNotNull();
        keysManagerMock.verify(() -> KeysManagerUtils.loadPublicKeyFromAsc(mockFile));
    }
}
```

---

## ‚úÖ Why this works

| Step                                 | Explanation                                                         |
| ------------------------------------ | ------------------------------------------------------------------- |
| `mockStatic(KeysManagerUtils.class)` | Ensures the static method never calls real code                     |
| `thenReturn(mockPublicKey)`          | Prevents the builder from receiving a null or invalid key           |
| No `PGPEncryptBuilder` mocking       | We let your actual builder run; it now receives a non-null mock key |
| Assertions                           | Confirm method returns a bean and didn‚Äôt throw an exception         |

---

## üß± Dependency Check

Make sure your Maven (or Gradle) includes:

```xml
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-inline</artifactId>
  <version>5.11.0</version>
  <scope>test</scope>
</dependency>
```

Without this, Mockito won‚Äôt mock static or final methods/classes.

---

## ‚úÖ Optional ‚Äì If `PGPEncryptBuilder` itself still fails internally

If `PGPEncryptBuilder` tries to validate real key data (even though it‚Äôs mocked), you can safely **mock it too**, but not via constructor.

Instead, mock **its `build()`** method via a real instance spy:

```java
PGPEncryptBuilder builder = spy(new PGPEncryptBuilder(mockPublicKey));
PGPEncrypt dummyEncrypt = mock(PGPEncrypt.class);
doReturn(dummyEncrypt).when(builder).build();
```

Then replace the builder creation in your test setup if needed.

---

## ‚úÖ TL;DR

* The `NullPointerException` means your mock for `KeysManagerUtils.loadPublicKeyFromAsc()` didn‚Äôt trigger.
* Add `mockito-inline` and use the simplified static mock above.
* Don‚Äôt mock the constructor ‚Äî just mock the static call.
* The decrypt test is already fine; the encrypt one will now pass.

---

If you share the exact package of `KeysManagerUtils` (e.g., `com.bnpp.pf.lib.pgp.core.KeysManagerUtils`), I can show you the fully qualified static mock line too, so it definitely intercepts the right call.
