Yep, we can keep Sonar happy **without** adding Awaitility or any new jar üëç

The key is:

* Don‚Äôt use `Thread.sleep(...)` in your **test**
* Let `Thread.sleep(...)` live only in your **production** `sleep(Duration)` method
* Use `Thread.join(...)` + an `AtomicReference` to capture the exception instead of sleeping in the test

Below is what you need for:

1. `sleep(Duration waitTime)` ‚Äì interrupted branch (no extra dependency, no sleep in test)
2. Catch blocks for `getTransferStatus` and `doSingleAttempt` (these don‚Äôt need `sleep` at all)

---

## 1Ô∏è‚É£ Test for `sleep(Duration waitTime)` (interrupted, no Awaitility, no sleep in test)

Assuming your prod code:

```java
void sleep(Duration waitTime) {
    try {
        Thread.sleep(waitTime.toMillis());
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new IllegalStateException("Interrupted while waiting", e);
    }
}
```

Test:

```java
@Test
void sleep_whenInterrupted_shouldThrowIllegalStateException() throws Exception {
    Duration waitTime = Duration.ofSeconds(5); // long enough to be sleeping

    AtomicReference<Throwable> caught = new AtomicReference<>();

    Thread t = new Thread(() -> {
        try {
            cftApiClient.sleep(waitTime);
        } catch (Throwable ex) {
            caught.set(ex);
        }
    });

    t.start();
    // Immediately interrupt ‚Äì no Thread.sleep in the test
    t.interrupt();
    // Wait (blocking) until the worker thread finishes
    t.join(1000);

    Throwable ex = caught.get();
    assertNotNull(ex, "Expected an exception from sleep, but none was caught");
    assertThat(ex)
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Interrupted");
}
```

‚úÖ No `Thread.sleep` in the test
‚úÖ No extra jar
‚úÖ Covers the catch branch in `sleep(Duration)`
Sonar‚Äôs ‚Äúdon‚Äôt use Thread.sleep in tests‚Äù rule now has nothing to complain about.

You can still keep the ‚Äúhappy path‚Äù test:

```java
@Test
void sleep_shouldNotThrow_whenNotInterrupted() {
    assertDoesNotThrow(() -> cftApiClient.sleep(Duration.ofMillis(5)));
}
```

---

## 2Ô∏è‚É£ Catch block of `getTransferStatus`

Prod (rough outline):

```java
TransferStatusResponse getTransferStatus(String idtu) {
    try {
        ResponseEntity<String> response = restTemplate.exchange(... String.class ...);
        return objectMapper.readValue(response.getBody(), TransferStatusResponse.class);
    } catch (Exception e) {
        throw new IllegalStateException("Failed to parse CFT status for idtu=" + idtu, e);
    }
}
```

Test ‚Äì make JSON invalid so `objectMapper.readValue` explodes and we hit the catch:

```java
@Test
void getTransferStatus_whenJsonInvalid_shouldThrowIllegalStateException() {
    String idtu = "IDTU-123";

    // Invalid JSON on purpose
    ResponseEntity<String> response =
            new ResponseEntity<>("NOT_VALID_JSON", HttpStatus.OK);

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class)
    )).thenReturn(response);

    assertThatThrownBy(() -> cftApiClient.getTransferStatus(idtu))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Failed to parse CFT status");

    verify(restTemplate, times(1)).exchange(
            anyString(),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class)
    );
}
```

No sleeps, no extra libs, and the catch in `getTransferStatus` is covered.

---

## 3Ô∏è‚É£ Catch block of `doSingleAttempt`

Prod (roughly):

```java
TransferStatusResponse doSingleAttempt(String outPath,
                                       String fileName,
                                       Duration waitTime,
                                       int attempt) {
    try {
        String idtu = triggerTransferOnce(outPath, fileName, attempt);
        sleep(waitTime);
        TransferStatusResponse status = getTransferStatus(idtu);
        // maybe second sleep + GET when SENDING...
        return status;
    } catch (Exception e) {
        throw new IllegalStateException(
                "CFT POST/GET attempt " + attempt + " failed for file " + fileName, e);
    }
}
```

To cover the catch, just force an exception from inside:

```java
@Test
void doSingleAttempt_whenTriggerTransferThrows_shouldWrapInIllegalStateException() throws Exception {
    CFTApiClient spyClient = Mockito.spy(cftApiClient);

    // whenever doSingleAttempt calls triggerTransferOnce, throw
    doThrow(new RuntimeException("boom"))
            .when(spyClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    Duration waitTime = Duration.ofMillis(1);

    assertThatThrownBy(() ->
            spyClient.doSingleAttempt("out/path/file.pgp", "file.pgp", waitTime, 1)
    )
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("CFT POST/GET attempt 1 failed");
}
```

Again, no sleep in the test, no new dependency, and you hit the catch in `doSingleAttempt`.

---

### Summary

* ‚úÖ You can **avoid Awaitility** and any new jar.
* ‚úÖ Remove `Thread.sleep(...)` from the test; use `Thread.join(...)` to wait for the worker thread to finish.
* ‚úÖ Use invalid JSON and a spy-throw to cover the `getTransferStatus` and `doSingleAttempt` catch blocks.

If you paste your exact `sleep`, `getTransferStatus`, and `doSingleAttempt` signatures, I can tweak the test snippets exactly to your method names/parameters, but structurally this will keep both **Sonar** and **coverage** happy.


--


Yeah, Sonar is right to complain about `Thread.sleep(50)` in tests ‚Äì it hates explicit sleeps in unit tests and prefers something like Awaitility that *waits for a condition* instead of a fixed time.

You can keep your `sleep(Duration waitTime)` method in **production** as-is (Sonar usually tolerates that if justified), and just fix the **test** to use Awaitility.

---

## 1Ô∏è‚É£ Add Awaitility (if not already there)

In your `pom.xml` (test scope):

```xml
<dependency>
    <groupId>org.awaitility</groupId>
    <artifactId>awaitility</artifactId>
    <version>4.2.0</version>
    <scope>test</scope>
</dependency>
```

Then in the test class:

```java
import static org.awaitility.Awaitility.await;
import java.time.Duration;
import java.util.concurrent.atomic.AtomicReference;
```

---

## 2Ô∏è‚É£ Replace the `Thread.sleep(50)` test with an Awaitility-based one

Here‚Äôs a Sonar-friendly version of the **interrupted sleep** test, no `Thread.sleep` at all:

```java
@Test
void sleep_whenInterrupted_shouldThrowIllegalStateException() {
    Duration waitTime = Duration.ofSeconds(5); // long enough to ensure it's really sleeping

    AtomicReference<Throwable> caught = new AtomicReference<>();

    Thread t = new Thread(() -> {
        try {
            cftApiClient.sleep(waitTime);
        } catch (Throwable ex) {
            caught.set(ex);
        }
    });

    t.start();
    // immediately interrupt; if the thread hasn't called sleep yet,
    // the interrupted flag is set and Thread.sleep will still throw
    t.interrupt();

    // Wait until the worker thread has actually caught something
    await()
        .atMost(Duration.ofSeconds(1))
        .untilAsserted(() -> assertThat(caught.get()).isNotNull());

    Throwable ex = caught.get();
    assertThat(ex)
        .isInstanceOf(IllegalStateException.class)
        .hasMessageContaining("Interrupted");
}
```

What‚Äôs happening here:

* We start a thread that calls your **production** `sleep(Duration)` method.
* We interrupt the thread right away (no `Thread.sleep(50)`).
* `sleep()`‚Äôs internal `Thread.sleep(...)` will see the interrupt flag and throw `InterruptedException`.
* Your `sleep()` catches that and rethrows `IllegalStateException` ‚Üí caught in `caught.set(ex)`.
* Awaitility keeps polling until `caught.get()` is non-null or 1s passes.
* Then we assert on the type/message.

This covers the **catch block** of `sleep(Duration waitTime)` and keeps Sonar happy.

---

Your other tests for:

* the happy path of `sleep(Duration)`
* the catch in `getTransferStatus`
* the catch in `doSingleAttempt`

can stay as they are, since they don‚Äôt use `Thread.sleep` directly in the test.

If you want, you can paste your current `sleep(Duration)` method, and I‚Äôll quickly double-check that this test matches it exactly.


-=-=-=--=-----

Nice, you‚Äôre *very* close now ‚Äî you just need a few focused tests to hit:

* the new `sleep(Duration)` method (both normal + interrupted),
* the **catch** block in `getTransferStatus`,
* the **catch** block in `doSingleAttempt`.

I‚Äôll assume these (or very similar) signatures in `CFTApiClient`:

```java
// package-private (default) now
void sleep(Duration waitTime) {
    try {
        Thread.sleep(waitTime.toMillis());
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new IllegalStateException("Interrupted while waiting", e);
    }
}

TransferStatusResponse getTransferStatus(String idtu) {
    try {
        // restTemplate.exchange(... String.class)
        // objectMapper.readValue(body, TransferStatusResponse.class)
    } catch (Exception e) {
        throw new IllegalStateException("Failed to parse CFT status for idtu=" + idtu, e);
    }
}

TransferStatusResponse doSingleAttempt(String outPath,
                                       String fileName,
                                       Duration waitTime,
                                       int attempt) {
    try {
        String idtu = triggerTransferOnce(outPath, fileName, attempt);
        sleep(waitTime);
        TransferStatusResponse status = getTransferStatus(idtu);
        // maybe second sleep + GET when SENDING...
        return status;
    } catch (Exception e) {
        throw new IllegalStateException(
                "CFT POST/GET attempt " + attempt + " failed for file " + fileName, e);
    }
}
```

> ‚ö†Ô∏è Make sure your **test class is in the same package** as `CFTApiClient` so it can access these default/package-private methods directly.

Below are **only the new tests** you need to add to your existing `CFTApiClientTest` (the one that already sets up `restTemplateBuilder`, `restTemplate`, and a real `ObjectMapper`).

---

## 1Ô∏è‚É£ Tests for `sleep(Duration waitTime)`

### a) Normal case ‚Äì no interrupt

```java
@Test
void sleep_shouldNotThrow_whenNotInterrupted() {
    // very small duration so the test stays fast
    Duration waitTime = Duration.ofMillis(5);

    assertDoesNotThrow(() -> cftApiClient.sleep(waitTime));
}
```

This hits the **try** path in `sleep` (no exception, no catch).

### b) Interrupted case ‚Äì covers catch block

We run `sleep` in a separate thread, interrupt it, and assert it throws `IllegalStateException`.

```java
@Test
void sleep_whenInterrupted_shouldThrowIllegalStateException() throws Exception {
    Duration waitTime = Duration.ofSeconds(5); // long enough to be sleeping

    AtomicReference<Throwable> caught = new AtomicReference<>();

    Thread t = new Thread(() -> {
        try {
            cftApiClient.sleep(waitTime);
        } catch (Throwable ex) {
            caught.set(ex);
        }
    });

    t.start();

    // give the thread a moment to enter Thread.sleep
    Thread.sleep(50);
    t.interrupt();      // this will cause InterruptedException inside sleep
    t.join(1000);       // wait for thread to finish

    Throwable ex = caught.get();
    assertNotNull(ex, "Expected an exception from sleep, but none was caught");
    assertThat(ex).isInstanceOf(IllegalStateException.class)
                  .hasMessageContaining("Interrupted");
}
```

That test executes the `catch (InterruptedException e)` block and the `IllegalStateException` rethrow.

---

## 2Ô∏è‚É£ Test catch block of `getTransferStatus`

We‚Äôll make `restTemplate` return **invalid JSON**, so the real `ObjectMapper` throws and we hit the catch.

```java
@Test
void getTransferStatus_whenJsonInvalid_shouldThrowIllegalStateException() {
    String idtu = "IDTU-123";

    // invalid JSON: objectMapper.readValue(...) will fail here
    ResponseEntity<String> response =
            new ResponseEntity<>("NOT_VALID_JSON", HttpStatus.OK);

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class)
    )).thenReturn(response);

    assertThatThrownBy(() -> cftApiClient.getTransferStatus(idtu))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Failed to parse CFT status"); // adjust to your message

    verify(restTemplate, times(1)).exchange(
            anyString(),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class)
    );
}
```

This covers the **catch (Exception e)** part inside `getTransferStatus`.

---

## 3Ô∏è‚É£ Test catch block of `doSingleAttempt`

We don‚Äôt need HTTP here at all. We just want `doSingleAttempt` to see some exception and wrap it in `IllegalStateException`.

Simplest way: spy the client and make `triggerTransferOnce` throw. That guarantees the `try` in `doSingleAttempt` hits its catch.

```java
@Test
void doSingleAttempt_whenTriggerTransferThrows_shouldWrapInIllegalStateException() throws Exception {
    // spy so we can stub only internal methods, everything else remains real
    CFTApiClient spyClient = Mockito.spy(cftApiClient);

    // whenever doSingleAttempt calls triggerTransferOnce, throw a RuntimeException
    doThrow(new RuntimeException("boom"))
            .when(spyClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    Duration waitTime = Duration.ofMillis(1);

    assertThatThrownBy(() ->
            spyClient.doSingleAttempt("out/path/file.pgp", "file.pgp", waitTime, 1)
    )
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("CFT POST/GET attempt 1 failed"); // match your message prefix
}
```

If your error message is slightly different, just relax the assertion to only check type:

```java
assertThatThrownBy(() ->
        spyClient.doSingleAttempt("out/path/file.pgp", "file.pgp", waitTime, 1)
).isInstanceOf(IllegalStateException.class);
```

That covers the catch inside `doSingleAttempt`.

---

### Recap

With these three additions:

* **`sleep(Duration)`**:

  * normal case ‚Üí try block,
  * interrupt case ‚Üí catch block.
* **`getTransferStatus`**:

  * invalid JSON ‚Üí `IllegalStateException` wrapper in catch block.
* **`doSingleAttempt`**:

  * internal failure (simulated via spy) ‚Üí `IllegalStateException` wrapper in catch block.

you‚Äôll cover exactly the missing bits:

* `sleep` method,
* catch of `getTransferStatus`,
* catch of `doSingleAttempt`.

If you paste your actual `doSingleAttempt` and `getTransferStatus` method signatures, I can tweak the test method calls so they align 1:1 with your code, but structurally this is exactly what you need.
======-=-=-=-=-=h-=-h=-f=-=f-=f


Gotcha, let‚Äôs clean this up properly:

* ‚úÖ No `ReflectionTestUtils.invokeMethod`
* ‚úÖ Keep using Mockito
* ‚úÖ No ‚Äúunnecessary stubbing‚Äù / PotentialStubbingProblem
* ‚úÖ Actually hit `triggerTransferOnce`, `doSingleAttempt` (including sleep block) and `getTransferStatus`

Below is a **pattern** that you can drop into your existing `CFTApiClientTest` (same package as `CFTApiClient`). Adjust names slightly if your signatures differ, but this is very close to what you described.

---

## 1. Test setup ‚Äì real `ObjectMapper`, mocked HTTP

Key idea: **don‚Äôt mock `ObjectMapper` at all**. Use a real one and only mock `RestTemplate`. That removes a lot of stubbing noise and avoids the line you mentioned:

```java
when(objectMapper.writeValueAsString(any()))...
```

```java
@ExtendWith(MockitoExtension.class)
class CFTApiClientTest {

    @Mock
    private RestTemplateBuilder restTemplateBuilder;

    @Mock
    private RestTemplate restTemplate;

    // REAL object mapper ‚Äì no Mockito
    private ObjectMapper objectMapper;

    private CFTApiClient cftApiClient;

    private static final Duration NO_WAIT = Duration.ZERO;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();

        // RestTemplateBuilder ‚Üí RestTemplate
        when(restTemplateBuilder.basicAuthentication(
                nullable(String.class), nullable(String.class)))
                .thenReturn(restTemplateBuilder);
        when(restTemplateBuilder.requestFactory(any()))
                .thenReturn(restTemplateBuilder);
        when(restTemplateBuilder.build()).thenReturn(restTemplate);

        cftApiClient = new CFTApiClient(restTemplateBuilder, objectMapper);

        // configure fields without invokeMethod
        ReflectionTestUtils.setField(cftApiClient, "baseUrl", "baseUrl");
        ReflectionTestUtils.setField(cftApiClient, "destPART", "destPART");
        ReflectionTestUtils.setField(cftApiClient, "destIDF", "destIDF");
        // restTemplate is normally set by init(); we inject it directly:
        ReflectionTestUtils.setField(cftApiClient, "restTemplate", restTemplate);
    }

    private static TransferStatusResponse status(String idtu,
                                                 String sentinel,
                                                 int diagi,
                                                 String diagnostic) {
        TransferStatusResponse s = new TransferStatusResponse();
        s.setIdtu(idtu);
        s.setSentinel(sentinel);
        s.setDiagi(diagi);
        s.setDiagnostic(diagnostic);
        return s;
    }
}
```

> Note: no `invokeMethod` anywhere; just `setField` to inject config + restTemplate.

---

## 2. Cover `triggerTransferOnce` (success + failure)

Here I assume:

```java
/* package */ String triggerTransferOnce(String outPath, String fileName, int attempt)
```

### 2.1 success: POST returns body with `idtu`

```java
@Test
void triggerTransferOnce_returnsIdtuOnSuccess() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    String responseBody = "{\"idtu\":\"IDTU-123\"}";
    ResponseEntity<String> response =
            new ResponseEntity<>(responseBody, HttpStatus.OK);

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(String.class),
            any(Map.class)
    )).thenReturn(response);

    String idtu = cftApiClient.triggerTransferOnce(outPath, fileName, 1);

    assertThat(idtu).isEqualTo("IDTU-123");

    verify(restTemplate, times(1)).exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(String.class),
            any(Map.class)
    );
}
```

### 2.2 failure: POST body has no `idtu` ‚Üí exception

```java
@Test
void triggerTransferOnce_throwsWhenIdtuMissing() {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    String responseBody = "{\"foo\":\"bar\"}";
    ResponseEntity<String> response =
            new ResponseEntity<>(responseBody, HttpStatus.OK);

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(String.class),
            any(Map.class)
    )).thenReturn(response);

    assertThatThrownBy(() ->
            cftApiClient.triggerTransferOnce(outPath, fileName, 1)
    ).isInstanceOf(IllegalStateException.class);

    verify(restTemplate, times(1)).exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(String.class),
            any(Map.class)
    );
}
```

Both tests **use** the stubbed `exchange`, so no ‚Äúunnecessary stubbing‚Äù.

---

## 3. Cover `getTransferStatus` (happy path)

Assuming:

```java
/* package */ TransferStatusResponse getTransferStatus(String idtu)
```

```java
@Test
void getTransferStatus_parsesResponseCorrectly() throws Exception {
    String idtu = "IDTU-777";

    String body = "{\"idtu\":\"IDTU-777\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"ok\"}";
    ResponseEntity<String> response =
            new ResponseEntity<>(body, HttpStatus.OK);

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class)
    )).thenReturn(response);

    TransferStatusResponse status = cftApiClient.getTransferStatus(idtu);

    assertThat(status.getIdtu()).isEqualTo("IDTU-777");
    assertThat(status.getSentinel()).isEqualTo("COMPLETED");
    assertThat(status.getDiagi()).isEqualTo(0);
    assertThat(status.getDiagnostic()).isEqualTo("ok");

    verify(restTemplate, times(1)).exchange(
            anyString(),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class)
    );
}
```

Again: stub is *used* ‚Üí no unnecessary stubbing.

---

## 4. Cover `doSingleAttempt` including the sleep + second GET

For this one, we don‚Äôt care about HTTP; we want to cover:

* first GET returns `SENDING`
* method sleeps
* second GET returns `COMPLETED`
* final status is returned.

We do this with a **spy** and stub only `triggerTransferOnce` + `getTransferStatus`. No `RestTemplate` or `ObjectMapper` stubbing at all ‚Üí no strict-stubbing issues.

Assuming:

```java
/* package */ TransferStatusResponse doSingleAttempt(String outPath,
                                                     String fileName,
                                                     Duration waitTime,
                                                     int attempt)
```

```java
@Test
void doSingleAttempt_whenSendingThenCompleted_coversSleepBlock() throws Exception {
    // spy so we can stub internal methods but keep the rest of logic
    CFTApiClient spyClient = Mockito.spy(cftApiClient);

    // 1) triggerTransferOnce returns idtu1
    doReturn("idtu1").when(spyClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    // 2) First getTransferStatus(idtu1) -> SENDING, second -> COMPLETED
    TransferStatusResponse sending   = status("idtu1", "SENDING",   0, "in progress");
    TransferStatusResponse completed = status("idtu1", "COMPLETED", 0, "done");

    AtomicInteger counter = new AtomicInteger();
    doAnswer(invocation -> {
        // first call -> SENDING, second call -> COMPLETED
        return counter.getAndIncrement() == 0 ? sending : completed;
    }).when(spyClient).getTransferStatus("idtu1");

    // small wait time to hit the sleep blocks but keep tests fast
    Duration waitTime = Duration.ofMillis(5);

    long before = System.currentTimeMillis();
    TransferStatusResponse result =
            spyClient.doSingleAttempt("out/path/file.pgp", "file.pgp", waitTime, 1);
    long after = System.currentTimeMillis();

    assertThat(result.getSentinel()).isEqualTo("COMPLETED");
    // We don't assert exact sleep time, only that code ran
    assertThat(after).isGreaterThanOrEqualTo(before);

    // internal methods were used
    verify(spyClient, times(1))
            .triggerTransferOnce(anyString(), anyString(), anyInt());
    verify(spyClient, times(2))
            .getTransferStatus("idtu1");
}
```

Because we **don‚Äôt** stub `restTemplate.exchange` or `objectMapper` in this test, there is zero chance of ‚Äúunnecessary stubbing‚Äù here.

This test drives:

* both `Thread.sleep(waitTime)` calls in `doSingleAttempt` (before first GET and before second GET when first is SENDING),
* the branch that does the second GET.

That gives you coverage for the ‚Äúsleep block‚Äù and the SENDING‚ÜíCOMPLETED logic.

---

## 5. Fail-case ‚Üí batch fail

You already have `notifyAndWaitForCompletion(...)` throwing an exception when both attempts fail. One more logic test (using the spy again) confirms that:

```java
@Test
void notifyAndWaitForCompletion_bothAttemptsFail_throwsException() throws Exception {
    CFTApiClient spyClient = Mockito.spy(cftApiClient);

    // first attempt: CANCELLED
    TransferStatusResponse cancelled1 = status("idtu1", "CANCELLED", 5, "first fail");
    // second attempt: CANCELLED again
    TransferStatusResponse cancelled2 = status("idtu2", "CANCELLED", 7, "second fail");

    // triggerTransferOnce returns idtu1 then idtu2
    doReturn("idtu1", "idtu2").when(spyClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    // map idtu -> status
    doAnswer(inv -> {
        String idtu = inv.getArgument(0, String.class);
        return "idtu1".equals(idtu) ? cancelled1 : cancelled2;
    }).when(spyClient).getTransferStatus(anyString());

    assertThatThrownBy(() ->
            spyClient.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", Duration.ofMillis(1))
    ).isInstanceOf(IllegalStateException.class);
}
```

If your tasklet simply calls `notifyAndWaitForCompletion` and does **not** catch this exception, Spring Batch will mark the step and job as `FAILED`.

---

### Why this should fix your issues

* No `invokeMethod` at all.
* Only the tests that **need** HTTP stubbing stub `restTemplate.exchange`, and every stub is used ‚Üí no ‚Äúunnecessary stubbing‚Äù warnings.
* `ObjectMapper` is real, so you don‚Äôt need to stub it (and can delete the `writeValueAsString(any())` stub line you mentioned).
* `triggerTransferOnce`, `getTransferStatus`, and `doSingleAttempt` are all called directly (they‚Äôre package-private now), so coverage goes up on those methods, including the sleep branch.

If you paste your current signatures for the three methods (`triggerTransferOnce`, `doSingleAttempt`, `getTransferStatus`), I can tweak the method calls (parameters) to match them exactly, but this structure will already be very close to what you need.
---------------


You‚Äôre right: to push CFTApiClient coverage up you basically need **three things**:

1. Hit the `triggerTransferOnce(..)` happy + retry + fail paths
2. Hit the `doSingleAttempt(..)` branch that does the `sleep`
3. Hit `getTransferStatus(..)` (at least one GET path)

Below is a clean Mockito-based test setup that does exactly that.
Adjust field / method names to your exact class, but the structure will fit what you already have.

---

## 1. Test setup (same pattern as your existing notifyUpload test)

```java
@ExtendWith(MockitoExtension.class)
class CFTApiClientTest {

    @Mock
    private RestTemplateBuilder restTemplateBuilder;

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private ObjectMapper objectMapper;

    private CFTApiClient cftApiClient;

    @BeforeEach
    void setUp() throws Exception {
        // Builder -> RestTemplate
        when(restTemplateBuilder
                .basicAuthentication(nullable(String.class), nullable(String.class)))
            .thenReturn(restTemplateBuilder);
        when(restTemplateBuilder.requestFactory(any(Supplier.class)))
            .thenReturn(restTemplateBuilder);
        when(restTemplateBuilder.build()).thenReturn(restTemplate);

        cftApiClient = new CFTApiClient(restTemplateBuilder, objectMapper);

        // Set fields used inside the methods
        ReflectionTestUtils.setField(cftApiClient, "baseUrl", "http://cft/api/transfers");
        ReflectionTestUtils.setField(cftApiClient, "destPART", "destPART");
        ReflectionTestUtils.setField(cftApiClient, "destIDF", "destIDF");

        // Call @PostConstruct init()
        ReflectionTestUtils.invokeMethod(cftApiClient, "init");

        // ObjectMapper for POST body
        when(objectMapper.writeValueAsString(any()))
                .thenReturn("{\"fname\":\"out/path/file.pgp\",\"parm\":\"file.pgp\",\"sync\":\"YES\"}");
    }

    // helper to build TransferStatusResponse with whatever fields you have
    private TransferStatusResponse status(String sentinel, int diagi, String idtu) {
        TransferStatusResponse s = new TransferStatusResponse();
        s.setSentinel(sentinel);
        s.setDiagi(diagi);
        s.setIdtu(idtu);
        return s;
    }
}
```

> ‚ö†Ô∏è If `TransferStatusResponse` has a builder or different setters, just adjust the `status(..)` helper.

---

## 2. Coverage for `triggerTransferOnce(..)`

### 2.1. Success on first attempt (COMPLETED, `diagi = 0`)

```java
@Test
void triggerTransferOnce_successOnFirstAttempt() throws Exception {
    // POST returns COMPLETED, diagi = 0
    TransferStatusResponse completed = status("COMPLETED", 0, "IDTU-123");

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(TransferStatusResponse.class),
            anyMap()))
        .thenReturn(new ResponseEntity<>(completed, HttpStatus.OK));

    // call (via reflection if method is private)
    String idtu = ReflectionTestUtils.invokeMethod(
            cftApiClient,
            "triggerTransferOnce",
            "/out/path/file.pgp",   // outPath
            "file.pgp",             // fileName
            Duration.ofMillis(5)    // waitTime
    );

    assertThat(idtu).isEqualTo("IDTU-123");

    // Only one POST attempt
    verify(restTemplate, times(1))
            .exchange(anyString(), eq(HttpMethod.POST), any(), eq(TransferStatusResponse.class), anyMap());
}
```

### 2.2. Retry once when first attempt CANCELLED or `diagi != 0`

```java
@Test
void triggerTransferOnce_retryOnceWhenFirstAttemptCancelled_thenSuccess() throws Exception {
    TransferStatusResponse cancelled = status("CANCELLED", 99, null);
    TransferStatusResponse completed = status("COMPLETED", 0, "IDTU-999");

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(TransferStatusResponse.class),
            anyMap()))
        .thenReturn(
            new ResponseEntity<>(cancelled, HttpStatus.OK),  // first attempt
            new ResponseEntity<>(completed, HttpStatus.OK)   // retry
        );

    String idtu = ReflectionTestUtils.invokeMethod(
            cftApiClient,
            "triggerTransferOnce",
            "/out/path/file.pgp",
            "file.pgp",
            Duration.ofMillis(5)
    );

    assertThat(idtu).isEqualTo("IDTU-999");

    // Two POST attempts (first CANCELLED, second COMPLETED)
    verify(restTemplate, times(2))
            .exchange(anyString(), eq(HttpMethod.POST), any(), eq(TransferStatusResponse.class), anyMap());
}
```

### 2.3. Both attempts fail ‚Üí throw `InvoiceProcessingException`

```java
@Test
void triggerTransferOnce_throwsWhenBothAttemptsFail() {
    TransferStatusResponse cancelled = status("CANCELLED", 42, null);

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(TransferStatusResponse.class),
            anyMap()))
        .thenReturn(
            new ResponseEntity<>(cancelled, HttpStatus.OK),
            new ResponseEntity<>(cancelled, HttpStatus.OK)
        );

    assertThatThrownBy(() -> ReflectionTestUtils.invokeMethod(
            cftApiClient,
            "triggerTransferOnce",
            "/out/path/file.pgp",
            "file.pgp",
            Duration.ofMillis(5)
    ))
        .isInstanceOf(InvoiceProcessingException.class)
        .hasMessageContaining("CFT POST/GET attempt failed for file"); // adjust to your message

    verify(restTemplate, times(2))
            .exchange(anyString(), eq(HttpMethod.POST), any(), eq(TransferStatusResponse.class), anyMap());
}
```

That gives you good branch coverage inside `triggerTransferOnce(..)`.

---

## 3. Cover the `doSingleAttempt(..)` *sleep* block

Your sleep block is triggered when response has `sentinel = "SENDING"` (that‚Äôs what we designed earlier).
We don‚Äôt need to assert the actual time, just execute the code path with a **small** duration so the test doesn‚Äôt pause for long.

```java
@Test
void doSingleAttempt_waitsWhenSentinelSending() throws Exception {
    TransferStatusResponse sending = status("SENDING", 0, "IDTU-42");

    when(restTemplate.exchange(
            anyString(),
            eq(HttpMethod.GET),                  // or POST, depending on where you call doSingleAttempt
            any(HttpEntity.class),
            eq(TransferStatusResponse.class),
            anyMap()))
        .thenReturn(new ResponseEntity<>(sending, HttpStatus.OK));

    long before = System.currentTimeMillis();

    TransferStatusResponse result = ReflectionTestUtils.invokeMethod(
            cftApiClient,
            "doSingleAttempt",
            HttpMethod.GET,           // method
            "IDTU-42",                // idtu or null for POST
            Duration.ofMillis(5)      // small wait to hit sleep branch
    );

    long after = System.currentTimeMillis();

    assertThat(result.getSentinel()).isEqualTo("SENDING");
    // we don't assert an exact sleep time, just that the method returned
    assertThat(after).isGreaterThanOrEqualTo(before);

    verify(restTemplate, times(1))
            .exchange(anyString(), eq(HttpMethod.GET), any(), eq(TransferStatusResponse.class), anyMap());
}
```

> If `doSingleAttempt(..)` doesn‚Äôt take a `Duration` parameter but uses a field (e.g. `graceWaitTime`), just set that field with `ReflectionTestUtils.setField(cftApiClient, "graceWaitTime", Duration.ofMillis(5));` before the call.

---

## 4. Cover `getTransferStatus(..)` (GET /transfers/{idtu})

```java
@Test
void getTransferStatus_returnsCompletedStatus() throws Exception {
    TransferStatusResponse completed = status("COMPLETED", 0, "IDTU-777");

    when(restTemplate.exchange(
            contains("/transfers/IDTU-777"),
            eq(HttpMethod.GET),
            any(HttpEntity.class),
            eq(TransferStatusResponse.class)))
        .thenReturn(new ResponseEntity<>(completed, HttpStatus.OK));

    TransferStatusResponse result = ReflectionTestUtils.invokeMethod(
            cftApiClient,
            "getTransferStatus",
            "IDTU-777",
            Duration.ofMillis(5) // or whatever your signature uses
    );

    assertThat(result.getSentinel()).isEqualTo("COMPLETED");
    assertThat(result.getIdtu()).isEqualTo("IDTU-777");

    verify(restTemplate, times(1))
            .exchange(contains("/transfers/IDTU-777"),
                      eq(HttpMethod.GET),
                      any(HttpEntity.class),
                      eq(TransferStatusResponse.class));
}
```

If your `getTransferStatus(..)` is `void` and only used inside `notifyUploadAndWaitForCompletion`, then instead:

* Call the public method (`notifyUploadAndWaitForCompletion(...)`)
* Stub the GET exchange as above
* Verify that it was called with the correct URL and that the method doesn‚Äôt throw.

---

## 5. Making the batch fail when CFT transfer fails

You also asked earlier:

> ‚ÄúIf this transfer fails ideally my batch should fail too‚Äù

The last test `triggerTransferOnce_throwsWhenBothAttemptsFail()` is the key for that:

* We make sure CFTApiClient throws an `InvoiceProcessingException` when both attempts fail.
* Your `PackageAndUploadTasklet` or whatever tasklet calls this should **not** catch that as a recoverable exception; let it bubble up ‚Üí the step fails ‚Üí job status = `FAILED`.

You already have that wiring; this test just proves the CFT client behaves correctly and gives you coverage on the failure branch.

---

If you paste these tests into your existing `CFTApiClientTest` (tweaking names / messages to match your class), your coverage for:

* `triggerTransferOnce`
* `doSingleAttempt` (including the sleep branch)
* `getTransferStatus`

should jump from ~66% to somewhere in the 90s.

If you show me the *current* signatures of these three methods, I can tighten the code so it compiles without any adjustments on your side.












=========================================================
You **can** absolutely stay with Mockito-based tests üëç
The two problems you hit:

1. `this.restTemplate` or `this.objectMapper` is `null`
2. Mockito ‚Äúargument mismatch / PotentialStubbingProblem‚Äù

‚Ä¶are both symptoms that the *real* HTTP code is still being called in your tests.

The easiest way to fix this and still use Mockito is:

> Use a **spy** on `CFTApiClient` and mock just the two internal methods
> `triggerTransferOnce(...)` and `getTransferStatus(...)`.

Then:

* No real `RestTemplate` calls.
* No strict stubbing errors.
* You only test the **control flow** of `notifyAndWaitForCompletion`.

---

## 1Ô∏è‚É£ Small change in production code

In `CFTApiClient`, make these **non-private** so Mockito can override them:

```java
// was: private String triggerTransferOnce(...)
protected String triggerTransferOnce(String outPath, String fileName, int attempt) throws Exception {
    // existing POST logic
}

// was: private TransferStatusResponse getTransferStatus(String idtu)
protected TransferStatusResponse getTransferStatus(String idtu) {
    // existing GET logic
}
```

Do **not** change their bodies, just visibility.

---

## 2Ô∏è‚É£ Your test setup with Mockito spy

In your existing `CFTApiClientTest` (the one you already have with `restTemplateBuilder`, `restTemplate`, `objectMapper` mocks), update `setUp()` like this:

```java
private CFTApiClient restApiClient;

@Mock
private RestTemplateBuilder restTemplateBuilder;

@Mock
private RestTemplate restTemplate;

@Mock
private ObjectMapper objectMapper;

@BeforeEach
void setUp() {
    // RestTemplateBuilder wiring ‚Äì same as you already had
    when(restTemplateBuilder.basicAuthentication(nullable(String.class), nullable(String.class)))
            .thenReturn(restTemplateBuilder);
    when(restTemplateBuilder.requestFactory(any()))
            .thenReturn(restTemplateBuilder);
    when(restTemplateBuilder.build())
            .thenReturn(restTemplate);

    // Create real client
    CFTApiClient realClient = new CFTApiClient(restTemplateBuilder, objectMapper);
    ReflectionTestUtils.setField(realClient, "baseUrl", "baseUrl");
    ReflectionTestUtils.setField(realClient, "username", "username");
    ReflectionTestUtils.setField(realClient, "password", "cftCred");
    ReflectionTestUtils.setField(realClient, "destPART", "destPART");
    ReflectionTestUtils.setField(realClient, "destIDF", "destIDF");
    ReflectionTestUtils.invokeMethod(realClient, "init");

    // Spy it, so we can override internal methods but keep everything else
    restApiClient = Mockito.spy(realClient);
}
```

Now `restApiClient`:

* has a non-null `restTemplate`, `objectMapper`, etc.,
* but in tests we‚Äôll **override** `triggerTransferOnce` and `getTransferStatus`, so HTTP is never used.

---

## 3Ô∏è‚É£ Helper to build statuses

Inside the test class:

```java
private static TransferStatusResponse status(String idtu, String sentinel, int diagi, String diagnostic) {
    TransferStatusResponse s = new TransferStatusResponse();
    s.setIdtu(idtu);
    s.setSentinel(sentinel);
    s.setDiagi(diagi);
    s.setDiagnostic(diagnostic);
    return s;
}
```

And we‚Äôll use `Duration.ZERO` to avoid any real `sleep`:

```java
private static final Duration NO_WAIT = Duration.ZERO;
```

---

## 4Ô∏è‚É£ Tests using Mockito spy (no RestTemplate stubbing needed)

### 4.1 Success ‚Äì first attempt, COMPLETED immediately

```java
@Test
void notifyAndWaitForCompletion_successOnFirstAttempt_completed() throws Exception {
    TransferStatusResponse completed = status("idtu1", "COMPLETED", 0, "ok");

    // Any call to triggerTransferOnce returns idtu1
    doReturn("idtu1").when(restApiClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    // GET for idtu1 returns COMPLETED,0
    doReturn(completed).when(restApiClient)
            .getTransferStatus("idtu1");

    assertDoesNotThrow(() ->
            restApiClient.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
    );
}
```

---

### 4.2 Success ‚Äì first attempt: SENDING then COMPLETED

We want: first GET ‚Üí SENDING, second GET ‚Üí COMPLETED.

```java
@Test
void notifyAndWaitForCompletion_successOnFirstAttempt_sendingThenCompleted() throws Exception {
    TransferStatusResponse sending   = status("idtu1", "SENDING",   0, "in progress");
    TransferStatusResponse completed = status("idtu1", "COMPLETED", 0, "done");

    doReturn("idtu1").when(restApiClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    AtomicInteger counter = new AtomicInteger();
    doAnswer(invocation -> {
        // first call -> SENDING, second call -> COMPLETED
        return counter.getAndIncrement() == 0 ? sending : completed;
    }).when(restApiClient).getTransferStatus("idtu1");

    assertDoesNotThrow(() ->
            restApiClient.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
    );
}
```

---

### 4.3 Retry once ‚Äì first attempt CANCELLED, second attempt COMPLETED

Here we want:

* Attempt 1: `triggerTransferOnce` ‚Üí idtu1, `getTransferStatus(idtu1)` ‚Üí CANCELLED
* Attempt 2: `triggerTransferOnce` ‚Üí idtu2, `getTransferStatus(idtu2)` ‚Üí COMPLETED

```java
@Test
void notifyAndWaitForCompletion_retryOnceAfterCancelled_thenSuccess() throws Exception {
    TransferStatusResponse cancelled = status("idtu1", "CANCELLED", 5, "cancelled");
    TransferStatusResponse completed = status("idtu2", "COMPLETED", 0, "ok on retry");

    // First trigger -> idtu1, second trigger -> idtu2
    doReturn("idtu1", "idtu2").when(restApiClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    // Return status depending on idtu
    doAnswer(invocation -> {
        String idtu = invocation.getArgument(0, String.class);
        if ("idtu1".equals(idtu)) {
            return cancelled;
        } else {
            return completed;
        }
    }).when(restApiClient).getTransferStatus(anyString());

    assertDoesNotThrow(() ->
            restApiClient.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
    );
}
```

---

### 4.4 Failure ‚Äì both attempts error ‚Üí batch will fail

Now both attempts end in error (`CANCELLED`, or `diagi != 0`, or still SENDING).
We just check that an exception is thrown; **you don‚Äôt need to assert the exact message**.

```java
@Test
void notifyAndWaitForCompletion_bothAttemptsFail_throwsException() throws Exception {
    TransferStatusResponse cancelled1 = status("idtu1", "CANCELLED", 5, "first fail");
    TransferStatusResponse cancelled2 = status("idtu2", "CANCELLED", 7, "second fail");

    doReturn("idtu1", "idtu2").when(restApiClient)
            .triggerTransferOnce(anyString(), anyString(), anyInt());

    doAnswer(invocation -> {
        String idtu = invocation.getArgument(0, String.class);
        if ("idtu1".equals(idtu)) {
            return cancelled1;
        } else {
            return cancelled2;
        }
    }).when(restApiClient).getTransferStatus(anyString());

    assertThrows(IllegalStateException.class, () ->
            restApiClient.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
    );
}
```

Because your tasklet **doesn‚Äôt catch** this `IllegalStateException`, Spring Batch will mark:

* the **step FAILED**, and
* the **job FAILED**
  ‚Üí exactly what you want when the transfer ultimately fails.

---

## Why this fixes your issues

* `restTemplate` and `objectMapper` can no longer be `null` in tests, because:

  * we build the real client with mocks in `setUp()` (just like before),
  * then we spy it ‚Äì all fields are preserved.
* We do **not** stub `RestTemplate.exchange(...)` at all in these 4 tests, so:

  * no `PotentialStubbingProblem`,
  * no URL/argument mismatch.
* All transfer outcomes (`COMPLETED`, `SENDING‚ÜíCOMPLETED`, `CANCELLED + retry`, `CANCELLED + CANCELLED`) are simulated purely via Mockito on `triggerTransferOnce` / `getTransferStatus`.

If you paste your `notifyAndWaitForCompletion(...)` method, I can quickly double-check that this stubbing still matches its internal flow, but this pattern is exactly designed for the way we structured it earlier.
==========================


package com.bnpp.pf.einvoice.connect.notifycft;

import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.*;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.assertThatCode;

/**
 * Tests only the transfer control logic (POST‚Üíwait‚ÜíGET (+optional GET)‚Üíretry once),
 * without mocking RestTemplate. HTTP is simulated by overriding methods.
 */
class CFTApiClientTransferLogicTest {

    private static final Duration NO_WAIT = Duration.ZERO; // avoids actual Thread.sleep

    /** Little fake client that simulates CFT behaviour for tests. */
    static class FakeCFTApiClient extends CFTApiClient {

        // Queue of idtus to return for successive POSTs
        private final Queue<String> idtus = new ArrayDeque<>();
        // For each idtu, a queue of statuses to return on successive GETs
        private final Map<String, Queue<TransferStatusResponse>> statusByIdtu = new HashMap<>();

        int triggerCalls = 0;
        int statusCalls = 0;

        FakeCFTApiClient() {
            // pass nulls, we will never hit real HTTP in this subclass
            super(null, null);
        }

        void addScenario(String idtu, TransferStatusResponse... statusesInOrder) {
            idtus.add(idtu);
            statusByIdtu.put(idtu, new ArrayDeque<>(Arrays.asList(statusesInOrder)));
        }

        @Override
        protected String triggerTransferOnce(String outPath, String fileName, int attempt) {
            triggerCalls++;
            String idtu = idtus.poll();
            if (idtu == null) {
                throw new IllegalStateException("No more idtus configured in test");
            }
            return idtu;
        }

        @Override
        protected TransferStatusResponse getTransferStatus(String idtu) {
            statusCalls++;
            Queue<TransferStatusResponse> q = statusByIdtu.get(idtu);
            if (q == null || q.isEmpty()) {
                throw new IllegalStateException("No more statuses configured for idtu=" + idtu);
            }
            return q.poll();
        }
    }

    private static TransferStatusResponse status(String idtu,
                                                 String sentinel,
                                                 int diagi,
                                                 String diagnostic) {
        TransferStatusResponse s = new TransferStatusResponse();
        s.setIdtu(idtu);
        s.setSentinel(sentinel);
        s.setDiagi(diagi);
        s.setDiagnostic(diagnostic);
        return s;
    }

    @Test
    void successOnFirstAttempt_whenCompletedImmediately() {
        FakeCFTApiClient client = new FakeCFTApiClient();

        // First attempt: POST -> idtu1, GET -> COMPLETED / diagi 0
        client.addScenario(
                "idtu1",
                status("idtu1", "COMPLETED", 0, "ok")
        );

        assertThatCode(() ->
                client.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
        ).doesNotThrowAnyException();

        // 1 POST, 1 GET
        assertThat(client.triggerCalls).isEqualTo(1);
        assertThat(client.statusCalls).isEqualTo(1);
    }

    @Test
    void successOnFirstAttempt_whenSendingThenCompleted() {
        FakeCFTApiClient client = new FakeCFTApiClient();

        // First attempt: GET1 -> SENDING, GET2 -> COMPLETED
        client.addScenario(
                "idtu1",
                status("idtu1", "SENDING", 0, "in progress"),
                status("idtu1", "COMPLETED", 0, "done")
        );

        assertThatCode(() ->
                client.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
        ).doesNotThrowAnyException();

        // 1 POST, 2 GETs (second GET because first was SENDING)
        assertThat(client.triggerCalls).isEqualTo(1);
        assertThat(client.statusCalls).isEqualTo(2);
    }

    @Test
    void retryOnce_whenFirstAttemptCancelled_thenSecondAttemptSuccess() {
        FakeCFTApiClient client = new FakeCFTApiClient();

        // First attempt: CANCELLED -> error -> trigger retry
        client.addScenario(
                "idtu1",
                status("idtu1", "CANCELLED", 5, "cancelled")
        );

        // Second attempt: COMPLETED -> success
        client.addScenario(
                "idtu2",
                status("idtu2", "COMPLETED", 0, "ok on retry")
        );

        assertThatCode(() ->
                client.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
        ).doesNotThrowAnyException();

        // 2 POSTs, 2 GETs (1 per attempt)
        assertThat(client.triggerCalls).isEqualTo(2);
        assertThat(client.statusCalls).isEqualTo(2);
    }

    @Test
    void throwsWhenBothAttemptsFail() {
        FakeCFTApiClient client = new FakeCFTApiClient();

        // 1st attempt: CANCELLED
        client.addScenario(
                "idtu1",
                status("idtu1", "CANCELLED", 5, "first fail")
        );
        // 2nd attempt: still CANCELLED
        client.addScenario(
                "idtu2",
                status("idtu2", "CANCELLED", 7, "second fail")
        );

        assertThatThrownBy(() ->
                client.notifyAndWaitForCompletion("out/path/file.pgp", "file.pgp", NO_WAIT)
        )
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("FAILED after retry");

        // still 2 POSTs, 2 GETs
        assertThat(client.triggerCalls).isEqualTo(2);
        assertThat(client.statusCalls).isEqualTo(2);
    }
}


----------
Nice, good to hear it‚Äôs working üéâ
Let‚Äôs add JUnit tests around the new behaviour.

I‚Äôll assume:

* Class name: `CFTApiClient`
* New public method:
  `notifyAndWaitForCompletion(String outPath, String fileName, Duration waitTime)`
* Internally it does:

  * POST ‚Üí get `idtu`
  * wait
  * GET (maybe second GET if first was `SENDING`)
  * retry the whole POST+wait+GET sequence **once** if final status is error
    (`CANCELLED`, `diagi != 0`, or still `SENDING`)

You already have:

* `RestTemplateBuilder restTemplateBuilder` mock
* `RestTemplate restTemplate` mock
* `ObjectMapper objectMapper` mock
* `CFTApiClient restApiClient` initialised via reflection (as in your screenshot)

We‚Äôll just **add new tests** to your existing `CFTApiClientTest`.
To avoid real `Thread.sleep`, we‚Äôll pass `Duration.ZERO` in tests.

---

## 1. Helpers for the tests

Add these helpers inside `CFTApiClientTest` (under your fields):

```java
private static final Duration NO_WAIT = Duration.ZERO;

private static TransferStatusResponse status(String idtu, String sentinel, int diagi, String diagnostic) {
    TransferStatusResponse s = new TransferStatusResponse();
    s.setIdtu(idtu);
    s.setSentinel(sentinel);
    s.setDiagi(diagi);
    s.setDiagnostic(diagnostic);
    return s;
}
```

---

## 2. Success ‚Äì first attempt, COMPLETED immediately

```java
@Test
void notifyAndWaitForCompletion_successOnFirstAttempt_completed() throws Exception {
    // given
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    // POST response body containing idtu
    String postBody = "{\"idtu\":\"idtu1\"}";
    ResponseEntity<String> postResponse =
            new ResponseEntity<>(postBody, HttpStatus.OK);

    // GET response body (we‚Äôll let ObjectMapper turn it into TransferStatusResponse)
    String getBody = "{\"idtu\":\"idtu1\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"ok\"}";
    ResponseEntity<String> getResponse =
            new ResponseEntity<>(getBody, HttpStatus.OK);

    // ObjectMapper: write request JSON
    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    // ObjectMapper: parse POST response (idtu)
    when(objectMapper.readTree(postBody))
            .thenReturn(new ObjectMapper().readTree(postBody));

    // ObjectMapper: parse GET response into TransferStatusResponse
    when(objectMapper.readValue(eq(getBody), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "COMPLETED", 0, "ok"));

    // RestTemplate: first call is POST, second is GET
    when(restTemplate.exchange(
            startsWith("baseUrl?"),  // your baseURL + query
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(String.class),
            any(Map.class))
    ).thenReturn(postResponse);

    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class))
    ).thenReturn(getResponse);

    // when / then ‚Äì should NOT throw
    assertThatCode(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    ).doesNotThrowAnyException();

    // verify 1 POST + 1 GET
    verify(restTemplate, times(1)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(1)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

## 3. Success ‚Äì first attempt: SENDING then COMPLETED

Here we simulate **two GET calls** in the same attempt: first `SENDING`, second `COMPLETED`.

```java
@Test
void notifyAndWaitForCompletion_successOnFirstAttempt_sendingThenCompleted() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    String postBody = "{\"idtu\":\"idtu1\"}";
    ResponseEntity<String> postResponse =
            new ResponseEntity<>(postBody, HttpStatus.OK);

    String getBody1 = "{\"idtu\":\"idtu1\",\"sentinel\":\"SENDING\",\"diagi\":0,\"diagnostic\":\"in progress\"}";
    String getBody2 = "{\"idtu\":\"idtu1\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"done\"}";

    ResponseEntity<String> getResponse1 =
            new ResponseEntity<>(getBody1, HttpStatus.OK);
    ResponseEntity<String> getResponse2 =
            new ResponseEntity<>(getBody2, HttpStatus.OK);

    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    when(objectMapper.readTree(postBody))
            .thenReturn(new ObjectMapper().readTree(postBody));

    when(objectMapper.readValue(eq(getBody1), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "SENDING", 0, "in progress"));

    when(objectMapper.readValue(eq(getBody2), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "COMPLETED", 0, "done"));

    // POST once, GET twice in order
    when(restTemplate.exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST),
            any(HttpEntity.class), eq(String.class), any(Map.class))
    ).thenReturn(postResponse);

    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET),
            isNull(), eq(String.class), any(Map.class))
    ).thenReturn(getResponse1, getResponse2);

    assertThatCode(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    ).doesNotThrowAnyException();

    verify(restTemplate, times(1)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

## 4. Retry ‚Äì first attempt CANCELLED, second attempt COMPLETED

This checks that:

* we do **two POSTs** and **two GETs**,
* final result is success (no exception).

```java
@Test
void notifyAndWaitForCompletion_retryAfterCancelled_thenSuccess() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    // First attempt
    String postBody1 = "{\"idtu\":\"idtu1\"}";
    String getBody1 = "{\"idtu\":\"idtu1\",\"sentinel\":\"CANCELLED\",\"diagi\":5,\"diagnostic\":\"cancelled\"}";

    ResponseEntity<String> postResponse1 =
            new ResponseEntity<>(postBody1, HttpStatus.OK);
    ResponseEntity<String> getResponse1 =
            new ResponseEntity<>(getBody1, HttpStatus.OK);

    // Second attempt
    String postBody2 = "{\"idtu\":\"idtu2\"}";
    String getBody2 = "{\"idtu\":\"idtu2\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"ok on retry\"}";

    ResponseEntity<String> postResponse2 =
            new ResponseEntity<>(postBody2, HttpStatus.OK);
    ResponseEntity<String> getResponse2 =
            new ResponseEntity<>(getBody2, HttpStatus.OK);

    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    // POST parse
    when(objectMapper.readTree(postBody1))
            .thenReturn(new ObjectMapper().readTree(postBody1));
    when(objectMapper.readTree(postBody2))
            .thenReturn(new ObjectMapper().readTree(postBody2));

    // GET parse
    when(objectMapper.readValue(eq(getBody1), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "CANCELLED", 5, "cancelled"));
    when(objectMapper.readValue(eq(getBody2), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu2", "COMPLETED", 0, "ok on retry"));

    // POST calls in order (attempt 1, then 2)
    when(restTemplate.exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST),
            any(HttpEntity.class), eq(String.class), any(Map.class))
    ).thenReturn(postResponse1, postResponse2);

    // GET calls in order (one per attempt)
    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET),
            isNull(), eq(String.class), any(Map.class))
    ).thenReturn(getResponse1, getResponse2);

    assertThatCode(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    ).doesNotThrowAnyException();

    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

## 5. Final failure ‚Äì both attempts error ‚áí exception (batch will fail)

This ensures `notifyAndWaitForCompletion` throws, which, if you don‚Äôt catch it in the tasklet, will make your Spring Batch job fail.

```java
@Test
void notifyAndWaitForCompletion_throwsWhenBothAttemptsFail() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    String postBody1 = "{\"idtu\":\"idtu1\"}";
    String getBody1  = "{\"idtu\":\"idtu1\",\"sentinel\":\"CANCELLED\",\"diagi\":5,\"diagnostic\":\"first fail\"}";

    String postBody2 = "{\"idtu\":\"idtu2\"}";
    String getBody2  = "{\"idtu\":\"idtu2\",\"sentinel\":\"CANCELLED\",\"diagi\":7,\"diagnostic\":\"second fail\"}";

    ResponseEntity<String> postResponse1 =
            new ResponseEntity<>(postBody1, HttpStatus.OK);
    ResponseEntity<String> postResponse2 =
            new ResponseEntity<>(postBody2, HttpStatus.OK);

    ResponseEntity<String> getResponse1 =
            new ResponseEntity<>(getBody1, HttpStatus.OK);
    ResponseEntity<String> getResponse2 =
            new ResponseEntity<>(getBody2, HttpStatus.OK);

    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    when(objectMapper.readTree(postBody1))
            .thenReturn(new ObjectMapper().readTree(postBody1));
    when(objectMapper.readTree(postBody2))
            .thenReturn(new ObjectMapper().readTree(postBody2));

    when(objectMapper.readValue(eq(getBody1), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "CANCELLED", 5, "first fail"));
    when(objectMapper.readValue(eq(getBody2), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu2", "CANCELLED", 7, "second fail"));

    when(restTemplate.exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST),
            any(HttpEntity.class), eq(String.class), any(Map.class))
    ).thenReturn(postResponse1, postResponse2);

    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET),
            isNull(), eq(String.class), any(Map.class))
    ).thenReturn(getResponse1, getResponse2);

    assertThatThrownBy(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    )
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("FAILED after retry");

    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

### How this ties to batch failure

You don‚Äôt need a special Spring Batch test for failure: as long as your tasklet just calls:

```java
cftApiClient.notifyAndWaitForCompletion(...);
```

and doesn‚Äôt catch the `IllegalStateException`, the **step will fail**, and Spring Batch will mark the **job FAILED**.

So these unit tests:

* Prove the new logic (SENDING + double GET, retry once on CANCELLED/diagi‚â†0).
* Confirm that in the ‚Äúboth attempts fail‚Äù case, an exception is thrown ‚Üí which is exactly what you want to cause the batch to fail.
---------------=-=-=-=-=--------=-=-=-=-----------------







Right, that clarifies it:

* First GET after the wait returned `SENDING`,
* but the *real* outcome of the transfer later was **FAILED**,
* so you **must not** treat `SENDING` as success.
* You want: **POST ‚Üí wait ‚Üí GET ‚Üí if SENDING, wait again ‚Üí GET again**.
  Then decide success/failure from that final GET.

We can do this with **very small changes** to what we already designed:
üëâ at most **2 GETs per POST**, and still **one POST retry max**.

---

## 1. Updated logic per attempt (conceptually)

For *each* attempt (initial and retry):

1. `POST /transfers` ‚Üí get `idtu`
2. `sleep(waitTime)` (your size-based wait)
3. `GET /transfers/{idtu}` ‚Üí `status1`
4. If `status1.sentinel == SENDING` (and `diagi == 0`):

   * `sleep(waitTime)` **again**
   * `GET /transfers/{idtu}` ‚Üí `status2`
   * use `status2` as the **final status for this attempt**
5. Now look at final status:

   * If `sentinel = CANCELLED` **or** `diagi != 0` ‚Üí this attempt = **error**
   * If `sentinel = SENDING` again ‚Üí treat as **error** (it never finished in our window)
   * Otherwise (`COMPLETED`, `PRE_PROC`, etc. with `diagi == 0`) ‚Üí **success**

If the first attempt is an error ‚Üí **one more attempt** (POST+wait+GET(+optional second GET)).

---

## 2. Minimal code changes

I‚Äôll show only the **two places** to change compared to the previous version:

### 2.1. `doSingleAttempt`: add a *second* GET if first returns SENDING

```java
private TransferStatusResponse doSingleAttempt(String outPath,
                                               String fileName,
                                               Duration waitTime,
                                               int attempt) {
    try {
        // 1) POST
        String idtu = triggerTransferOnce(outPath, fileName, attempt);

        // 2) first WAIT
        if (!waitTime.isZero() && !waitTime.isNegative()) {
            log.info("Waiting {} ms before first status GET for idtu={}", waitTime.toMillis(), idtu);
            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before first CFT GET", e);
            }
        }

        // 3) first GET
        TransferStatusResponse status = getTransferStatus(idtu);
        log.info("First CFT status for idtu={} sentinel={} diagi={} diagnostic={}",
                 idtu, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

        // 4) If still SENDING, wait once more and GET again
        if ("SENDING".equalsIgnoreCase(status.getSentinel())
                && status.getDiagi() == 0) {

            log.info("CFT status is SENDING after first wait. Waiting {} ms again and re-checking...",
                     waitTime.toMillis());

            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before second CFT GET", e);
            }

            status = getTransferStatus(idtu);
            log.info("Second CFT status for idtu={} sentinel={} diagi={} diagnostic={}",
                     idtu, status.getSentinel(), status.getDiagi(), status.getDiagnostic());
        }

        // final status for this attempt
        return status;

    } catch (Exception ex) {
        throw new IllegalStateException("CFT POST/GET attempt " + attempt + " failed for file " + fileName, ex);
    }
}
```

So now:

* Each attempt does **one or two GETs**:

  * 1st GET after the wait
  * A **second** GET only if the first said `SENDING`

---

### 2.2. `isErrorStatus`: treat final `SENDING` as error

Previously we only treated `CANCELLED` and `diagi != 0` as error.
Now we also say: ‚Äúif it‚Äôs still SENDING after the second check ‚Üí treat as error‚Äù.

```java
private boolean isErrorStatus(TransferStatusResponse status) {
    String sentinel = status.getSentinel();
    int diagi = status.getDiagi();

    log.info("Final CFT status for decision: idtu={} sentinel={} diagi={} diagnostic={}",
             status.getIdtu(), sentinel, diagi, status.getDiagnostic());

    // business error conditions:
    // - CANCELLED
    // - any diagi != 0
    // - still SENDING after two waits (never reached a final state)
    if ("CANCELLED".equalsIgnoreCase(sentinel)
            || diagi != 0
            || "SENDING".equalsIgnoreCase(sentinel)) {
        return true;
    }

    // PRE_PROC, COMPLETED, etc. with diagi == 0 => OK
    return false;
}
```

**Why treat SENDING as error here?**

* At this point we‚Äôve already:

  * waited `waitTime`, did GET1 (SENDING),
  * waited another `waitTime`, did GET2, still SENDING.
* If it‚Äôs *still* SENDING, we don‚Äôt want to declare success.
  It‚Äôs safer to treat this as ‚Äúdid not finish ‚Üí error‚Äù so we either:

  * retry the POST once, or
  * fail the job, rather than silently saying ‚ÄúOK‚Äù while the transfer actually fails.

---

## 3. The retry logic itself stays the same

We keep the same `notifyAndWaitForCompletion` from before:

```java
public void notifyAndWaitForCompletion(String outPath,
                                       String fileName,
                                       Duration waitTime) {

    // FIRST attempt
    TransferStatusResponse status = doSingleAttempt(outPath, fileName, waitTime, 1);

    if (!isErrorStatus(status)) {
        log.info("CFT transfer SUCCESS on first attempt for file {} (sentinel={}, diagi={})",
                 fileName, status.getSentinel(), status.getDiagi());
        return;
    }

    log.warn("CFT transfer ERROR on first attempt for file {} ‚Äì sentinel={} diagi={} diagnostic={}. Retrying once...",
             fileName, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

    // SECOND (and last) attempt
    TransferStatusResponse status2 = doSingleAttempt(outPath, fileName, waitTime, 2);

    if (isErrorStatus(status2)) {
        throw new IllegalStateException(
                String.format("CFT transfer FAILED after retry for file %s. Last status: sentinel=%s diagi=%d diagnostic=%s",
                              fileName,
                              status2.getSentinel(),
                              status2.getDiagi(),
                              status2.getDiagnostic()));
    }

    log.info("CFT transfer SUCCESS on second attempt for file {} (sentinel={}, diagi={})",
             fileName, status2.getSentinel(), status2.getDiagi());
}
```

And your tasklet still just does:

```java
if (cftEnabled) {
    long bytes = encryptedFile.length();
    Duration waitTime = pickWaitByTier(bytes, waittime); // your ‚Äú6s + per MB‚Äù logic
    log.info("Payload size={} bytes. Using waitTime={} before CFT status checks.", bytes, waitTime);
    cftApiClient.notifyAndWaitForCompletion(key, encryptedFileName, waitTime);
}
```

---

## 4. What this fixes for your ‚ÄúSENDING but actually failed‚Äù case

With these tweaks:

* First `POST‚Üíwait‚ÜíGET` returns `SENDING` ‚Üí **not accepted** as final.
* We:

  * wait **again** for the same `waitTime`,
  * do a **second GET**,
  * now we see the true final state (e.g. `CANCELLED`, or `diagi != 0`).
* That final `CANCELLED` / error now:

  * marks the attempt as error,
  * triggers the **second POST attempt**, or
  * fails the job after the second attempt.

So you don‚Äôt falsely treat that initial `SENDING` as success anymore.

If you want, you can tell me roughly what your typical waitTime is (e.g. ‚Äú6s + 1s per MB‚Äù) and we could decide if the second wait should be the same, or a fixed small extra (say 5s). But the structure above already matches exactly what you described.
===================-=-=-==-=---------

Gotcha, that makes sense now üëç

You want a *much simpler* flow:

> **POST ‚Üí wait (size-based) ‚Üí single GET**
> If GET says `CANCELLED` (or error) ‚Üí do **one more** `POST ‚Üí wait ‚Üí GET`.
> No polling loop, no multiple GETs.

Also: `sentinel = PRE_PROC` should *not* be treated as a failure.

Let‚Äôs do this step by step and keep the code small and readable.

---

## 1. Desired behavior (in words)

For each file:

1. **First attempt**

   1. Call `POST /transfers` (your existing notify)
      ‚Æï response contains `idtu`.
   2. Wait for your **size-based duration** (e.g. `6s + X per MB`).
   3. Call **one** `GET /transfers/{idtu}`.
   4. Interpret result:

      * If `sentinel == "CANCELLED"` **or** `diagi != 0` ‚Üí treat as *error*.
      * Any other `sentinel` (`COMPLETED`, `PRE_PROC`, `SENDING`, ‚Ä¶) with `diagi == 0` ‚Üí treat as **success**.

2. **If first attempt is error** (`CANCELLED` or `diagi != 0`)
   ‚ûú Do **one more full attempt**:

   * `POST` again (new `idtu`)
   * wait again
   * `GET` once
   * If still error ‚Üí throw exception ‚Üí batch step fails.

So:

* ‚úÖ No multiple GETs per attempt (exactly one).
* ‚úÖ GET happens **only after** the wait.
* ‚úÖ `PRE_PROC` is considered OK as long as `diagi == 0`.
* ‚úÖ At most **2 POSTs** per file (initial + 1 retry).

---

## 2. DTO for GET `/transfers/{idtu}`

```java
public class TransferStatusResponse {

    private String idtu;
    private String sentinel;   // e.g. "COMPLETED", "PRE_PROC", "SENDING", "CANCELLED"
    private int diagi;         // 0 = OK
    private String diagnostic; // descriptive text

    // getters and setters
}
```

Adjust field names with `@JsonProperty` if needed.

---

## 3. Helper: GET status once

In your `CftApiClient`:

```java
private TransferStatusResponse getTransferStatus(String idtu) {
    String url = baseURL + "/transfers/{idtu}";   // adjust if needed

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("idtu", idtu);

    ResponseEntity<String> response =
            restTemplate.exchange(url, HttpMethod.GET, null, String.class, uriVariables);

    log.info("CFT GET status for idtu={} -> {}", idtu, response.getStatusCode());
    log.debug("CFT GET body: {}", response.getBody());

    try {
        return objectMapper.readValue(response.getBody(), TransferStatusResponse.class);
    } catch (Exception e) {
        throw new IllegalStateException("Failed to parse CFT status for idtu=" + idtu, e);
    }
}
```

---

## 4. Helper: POST once and return `idtu`

This is basically your current POST, wrapped:

```java
private String triggerTransferOnce(String outPath, String fileName, int attempt) throws Exception {
    String apiUrl = baseURL + "?part={part}&idtf={idtf}";

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);

    Map<String, String> requestBody = new HashMap<>();
    requestBody.put("fname", outPath);
    requestBody.put("pname", fileName);
    requestBody.put("sync", "YES");

    String jsonPayload = objectMapper.writeValueAsString(requestBody);
    HttpEntity<String> requestEntity = new HttpEntity<>(jsonPayload, headers);

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("part", destPART);
    uriVariables.put("idtf", destIDF);

    log.info("Sending CFT POST attempt {} to: {}", attempt, apiUrl);
    log.info("Headers: {}", headers);
    log.info("Body   : {}", requestBody);

    ResponseEntity<String> response =
            restTemplate.exchange(apiUrl, HttpMethod.POST, requestEntity,
                                  String.class, uriVariables);

    log.info("CFT POST attempt {} status: {}", attempt, response.getStatusCode());
    log.info("CFT POST attempt {} body  : {}", attempt, response.getBody());

    JsonNode root = objectMapper.readTree(response.getBody());
    String idtu = root.path("idtu").asText(null);   // adjust field name if needed

    if (idtu == null || idtu.isEmpty()) {
        throw new IllegalStateException("CFT POST response did not contain idtu (attempt " + attempt + ")");
    }

    return idtu;
}
```

---

## 5. Helper: evaluate if this status is an **error**

You said: *‚Äúretry POST request once again in case of error if (`sentinel = CANCELLED` or `diagi != 0`)‚Äù*.

```java
private boolean isErrorStatus(TransferStatusResponse status) {
    String sentinel = status.getSentinel();
    int diagi = status.getDiagi();

    // log always, for visibility
    log.info("CFT status: idtu={} sentinel={} diagi={} diagnostic={}",
             status.getIdtu(), sentinel, diagi, status.getDiagnostic());

    // Only treat CANCELLED or diagi != 0 as errors
    if ("CANCELLED".equalsIgnoreCase(sentinel) || diagi != 0) {
        return true;
    }

    // PRE_PROC, COMPLETED, SENDING with diagi==0 are considered OK
    return false;
}
```

So your `PRE_PROC` case with `diagi == 0` becomes **success** ‚úÖ

---

## 6. Single attempt: POST ‚Üí wait ‚Üí GET ‚Üí decide

```java
private TransferStatusResponse doSingleAttempt(String outPath,
                                               String fileName,
                                               Duration waitTime,
                                               int attempt) {
    try {
        // 1) POST
        String idtu = triggerTransferOnce(outPath, fileName, attempt);

        // 2) WAIT based on file size (you pass this in)
        if (!waitTime.isZero() && !waitTime.isNegative()) {
            log.info("Waiting {} ms before status GET for idtu={}", waitTime.toMillis(), idtu);
            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before CFT GET", e);
            }
        }

        // 3) GET once
        TransferStatusResponse status = getTransferStatus(idtu);
        return status;

    } catch (Exception ex) {
        throw new IllegalStateException("CFT POST/GET attempt " + attempt + " failed for file " + fileName, ex);
    }
}
```

Note: **GET is now called only after the wait**, exactly as you asked.

---

## 7. Public method: retry POST+WAIT+GET once on error

```java
public void notifyAndWaitForCompletion(String outPath,
                                       String fileName,
                                       Duration waitTime) {

    // FIRST attempt
    TransferStatusResponse status = doSingleAttempt(outPath, fileName, waitTime, 1);

    if (!isErrorStatus(status)) {
        // OK: sentinel != CANCELLED and diagi == 0 (COMPLETED, PRE_PROC, SENDING, etc.)
        log.info("CFT transfer considered SUCCESS on first attempt for file {} (sentinel={}, diagi={})",
                 fileName, status.getSentinel(), status.getDiagi());
        return;
    }

    // We are in the error scenario: CANCELLED or diagi != 0
    log.warn("CFT transfer ERROR on first attempt for file {} ‚Äì sentinel={} diagi={} diagnostic={}. Retrying once...",
             fileName, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

    // SECOND (and last) attempt
    TransferStatusResponse status2 = doSingleAttempt(outPath, fileName, waitTime, 2);

    if (isErrorStatus(status2)) {
        // still error ‚Üí fail the batch
        throw new IllegalStateException(
                String.format("CFT transfer FAILED after retry for file %s. Last status: sentinel=%s diagi=%d diagnostic=%s",
                              fileName,
                              status2.getSentinel(),
                              status2.getDiagi(),
                              status2.getDiagnostic()));
    }

    log.info("CFT transfer considered SUCCESS on second attempt for file {} (sentinel={}, diagi={})",
             fileName, status2.getSentinel(), status2.getDiagi());
}
```

---

## 8. How your tasklet calls it

Back in `PackageAndUploadFilesTasklet`, you already compute a wait based on file size.

Where you had:

```java
if (cftEnabled) {
    // old: notifyUpload(...) + Thread.sleep(...) here
}
```

Change to:

```java
if (cftEnabled) {
    long bytes = encryptedFile.length();
    Duration waitTime = pickWaitByTier(bytes, waittime);  // your existing size-based logic

    log.info("Payload size={} bytes. Using waitTime={} before CFT status GET.", bytes, waitTime);
    cftApiClient.notifyAndWaitForCompletion(key, encryptedFileName, waitTime);
}
```

---

### Summary

* We removed the polling loop and **multiple GETs**.
* We now strictly do: **POST ‚Üí wait ‚Üí GET once**.
* We only treat `sentinel = CANCELLED` or `diagi != 0` as error ‚Üí triggers a **second full attempt** (POST+wait+GET).
* `sentinel = PRE_PROC` with `diagi == 0` is treated as **success**, same for `COMPLETED`, `SENDING`, etc.
* GET is **only** called after your size-based wait.

If you paste a sample actual GET JSON (with `PRE_PROC`), I can double-check the field names so you don‚Äôt get parsing surprises.
