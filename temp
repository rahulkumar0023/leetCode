Yep ‚Äî you can do this, and you **don‚Äôt need to touch your encrypt/upload logic much**.

You already plan to create subfolders like:

* `processed/xml/miles/<invoiceId>/...`
* `processed/xml/finance/<invoiceId>/...`

If your **zip code preserves relative paths**, the zip will contain those subfolders automatically.

Right now your `zipDirectory()` flattens everything because it uses:

```java
new ZipEntry(path.getFileName().toString())
```

So the minimal and correct change is: **zip using the path relative to the root dir**.

---

## 1) Minimal change in `PackageAndUploadTasklet.zipDirectory` (keep subdirs inside zip)

### ‚úÖ Replace only the ZipEntry name

```java
void zipDirectory(Path dir, File zipFile) throws IOException {
    if (dir == null) {
        throw new IOException("Zip root directory is null");
    }
    if (!Files.exists(dir)) return;

    Path normalizedRoot = dir.toAbsolutePath().normalize();

    try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
        Files.walk(normalizedRoot)
            .filter(Files::isRegularFile)
            .forEach(path -> {
                try {
                    Path normalizedFile = path.toAbsolutePath().normalize();

                    // Fortify/Sonar safe: block path traversal outside root
                    if (!normalizedFile.startsWith(normalizedRoot)) {
                        throw new IOException("Invalid file outside zip root");
                    }

                    // ‚úÖ Preserve subdirectories in ZIP
                    String entryName = normalizedRoot.relativize(normalizedFile)
                        .toString()
                        .replace('\\', '/'); // windows safe

                    log.info("Adding file {} to zip as {}", path.getFileName(), entryName);

                    ZipEntry entry = new ZipEntry(entryName);
                    zos.putNextEntry(entry);

                    try (InputStream is = Files.newInputStream(normalizedFile)) {
                        is.transferTo(zos);
                    }

                    zos.closeEntry();

                } catch (IOException e) {
                    throw new InvoiceProcessingException(e.getMessage());
                }
            });
    }

    log.info("Created ZIP: {}", zipFile.getAbsolutePath());
}
```

### Why this is minimal + safe

* Only changes **ZipEntry naming**
* Keeps your current stream logic, encrypt, COS upload unchanged
* Preserves folder structure inside zip (exactly what you asked)

No other changes needed in `execute()` / `zipEncryptUploadFiles()`.

---

## 2) Changes in `XmlInvoiceWriter` (put invoices into `<invoiceId>` folder only for miles/finance)

From your latest screenshot, you already implemented something like `resolveInvoiceSubDirIfNeeded(...)`. That‚Äôs the correct approach.

### ‚úÖ Recommended final shape inside `updateInvoiceName(...)`

(Only the important part shown)

```java
if (isJobTypeXml) {
    String invoiceId = registry.lookup(invoice);
    String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);
    String finalInvoiceFileName = invoiceFileName + trailingSuffix + XML_EXTENTION;

    log.info("base invoice name for attachment move : {}", invoiceId);

    Path finalOutputDir = resolveInvoiceSubDirIfNeeded(outputDir, invoice);

    createOutputxml(invoice, finalOutputDir, finalInvoiceFileName);

    // IMPORTANT: pass finalOutputDir so attachments go into same invoice folder
    attachmentMover.moveAttachments(invoiceId, invoiceFileName + XML_EXTENTION, finalOutputDir);
} else {
    createOutputxml(invoice, outputDir, invoiceFileName + XML_EXTENTION);
}
```

That will generate:

* XML ‚Üí `.../miles/<invoiceId>/<finalInvoiceFileName>`
* Attachments ‚Üí moved into `.../miles/<invoiceId>/...` (same folder)

So your zip will now include `miles/<invoiceId>/...` automatically once zipDirectory preserves structure.

---

## 3) Reuse the same logic for `XmlCreditNoteWriter` (avoid duplicate code)

Yes ‚Äî you should pull the common bits into a small util (minimal refactor, low risk).

### `InvoiceBatchFileUtil` (or similar)

```java
public final class InvoiceBatchFileUtil {

    private InvoiceBatchFileUtil() {}

    public static Path resolveSubDirIfNeeded(Path baseOutputDir, String baseDirName, String docId) throws IOException {
        if (baseOutputDir == null) {
            throw new IOException("Base output directory is null");
        }

        boolean isMilesOrFinance =
            "miles".equalsIgnoreCase(baseDirName) || "finance".equalsIgnoreCase(baseDirName);

        if (!isMilesOrFinance) {
            return baseOutputDir;
        }

        String folder = sanitizeForFileName(docId);
        if (folder == null || folder.isBlank()) {
            throw new IOException("Document id is missing for miles/finance folder");
        }

        Path normalizedBase = baseOutputDir.toAbsolutePath().normalize();
        Path candidate = normalizedBase.resolve(folder).normalize();

        // Fortify safe: prevent traversal
        if (!candidate.startsWith(normalizedBase)) {
            throw new IOException("Invalid document subdirectory");
        }

        Files.createDirectories(candidate);
        return candidate;
    }

    public static String safeId(String id) {
        return id;
    }

    // you already have this somewhere:
    public static String sanitizeForFileName(String input) {
        // your existing sanitizeForFileName
        return input;
    }
}
```

### Use it in `XmlInvoiceWriter`

```java
private Path resolveInvoiceSubDirIfNeeded(Path baseOutputDir, InvoiceType invoice) throws IOException {
    String baseDirName = baseOutputDir.getFileName() != null ? baseOutputDir.getFileName().toString() : "";
    String invoiceId = safeInvoiceId(invoice);
    return InvoiceBatchFileUtil.resolveSubDirIfNeeded(baseOutputDir, baseDirName, invoiceId);
}
```

### Use it in `XmlCreditNoteWriter`

Same idea, but `safeCreditNoteId(creditNote)`.

This keeps your writer classes small and avoids copy/paste.

---

## 4) JUnit tests you need

### A) Test zip preserves subdirectories

This validates your ‚Äúsubdirectories must appear in zip‚Äù requirement.

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.zip.ZipFile;

import static org.assertj.core.api.Assertions.assertThat;

class PackageAndUploadTaskletZipTest {

    @TempDir
    Path tempDir;

    @Test
    void zipDirectory_preservesSubdirectories() throws Exception {
        // given
        Path root = tempDir.resolve("miles");
        Path invDir = root.resolve("INV-123");
        Files.createDirectories(invDir);

        Files.writeString(invDir.resolve("a.xml"), "<xml/>");
        Files.writeString(invDir.resolve("a.pdf"), "pdf");

        File zip = tempDir.resolve("out.zip").toFile();

        PackageAndUploadTasklet tasklet = new PackageAndUploadTasklet();
        tasklet.zipDirectory(root, zip);

        // then
        try (ZipFile zipFile = new ZipFile(zip)) {
            assertThat(zipFile.getEntry("INV-123/a.xml")).isNotNull();
            assertThat(zipFile.getEntry("INV-123/a.pdf")).isNotNull();
        }
    }
}
```

> Note: because you zip `milesXmlPath` itself (`processed/xml/miles`), inside zip you‚Äôll get `INV-123/...` (not `miles/INV-123/...`). That matches your current code which calls `zipDirectory(milesXmlPath, zipFile)`.

---

### B) Test resolveSubDirIfNeeded creates invoice folder only for miles/finance

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.nio.file.Files;
import java.nio.file.Path;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

class InvoiceBatchFileUtilTest {

    @TempDir
    Path tempDir;

    @Test
    void resolveSubDirIfNeeded_createsFolderForMiles() throws Exception {
        Path milesDir = tempDir.resolve("miles");
        Files.createDirectories(milesDir);

        Path result = InvoiceBatchFileUtil.resolveSubDirIfNeeded(milesDir, "miles", "INV-999");

        assertThat(result).isEqualTo(milesDir.resolve("INV-999"));
        assertThat(Files.exists(result)).isTrue();
        assertThat(Files.isDirectory(result)).isTrue();
    }

    @Test
    void resolveSubDirIfNeeded_returnsSameDirForOtherBuckets() throws Exception {
        Path regularDir = tempDir.resolve("regular");
        Files.createDirectories(regularDir);

        Path result = InvoiceBatchFileUtil.resolveSubDirIfNeeded(regularDir, "regular", "INV-999");

        assertThat(result).isEqualTo(regularDir);
    }

    @Test
    void resolveSubDirIfNeeded_throwsIfIdMissingForMiles() throws Exception {
        Path milesDir = tempDir.resolve("miles");
        Files.createDirectories(milesDir);

        assertThatThrownBy(() ->
            InvoiceBatchFileUtil.resolveSubDirIfNeeded(milesDir, "miles", "  ")
        ).isInstanceOf(Exception.class);
    }
}
```

---

## What you *don‚Äôt* need to change

* Your PGP encrypt code
* COS upload code
* How you collect `processedFiles` (you can still add `milesXmlPath`, `financeXmlPath`)

As long as:

1. Writers create invoice subfolders under miles/finance
2. Zip preserves relative paths

‚Ä¶you get exactly what you want: **zip contains subdirectories**.

---

If you paste your `XmlCreditNoteWriter.updateInvoiceName(...)` snippet, I can show the exact 3‚Äì5-line change there too (it‚Äôll mirror the invoice writer: resolve subdir ‚Üí write xml into it ‚Üí move attachments into it).



-----1435-----
Your method is **already recursive** (`Files.walk(dir)`), so you‚Äôre 90% there ‚úÖ

Right now you‚Äôre flattening because you create the entry with only:

```java
new ZipEntry(...)
path.getFileName().toString()
```

So the *minimal* change you need is:

* build the ZIP entry name as the **relative path from `dir`**
* (optionally) normalize + basic safety check to keep Fortify happy
* keep everything else the same

---

## ‚úÖ Minimal diff inside your `zipDirectory(...)`

### Replace ONLY these two lines:

```java
log.info("Adding file {} to zip", path.getFileName());
ZipEntry entry = new ZipEntry(path.getFileName().toString());
```

### With this:

```java
Path relativePath = dir.relativize(path);
String entryName = relativePath.toString().replace('\\', '/');

// Extra safety (very small + Fortify-friendly)
if (entryName.contains("..") || entryName.startsWith("/")) {
    throw new InvoiceProcessingException("Invalid zip entry name");
}

log.info("Adding file {} to zip", entryName);
ZipEntry entry = new ZipEntry(entryName);
```

That‚Äôs it.

---

## Your full method with only the minimal change applied

```java
void zipDirectory(Path dir, File zipFile) throws IOException {
    if (!Files.exists(dir)) return;

    try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
        Files.walk(dir)
            .filter(Files::isRegularFile)
            .forEach(path -> {
                try (InputStream is = Files.newInputStream(path)) {

                    Path relativePath = dir.relativize(path);
                    String entryName = relativePath.toString().replace('\\', '/');

                    if (entryName.contains("..") || entryName.startsWith("/")) {
                        throw new InvoiceProcessingException("Invalid zip entry name");
                    }

                    log.info("Adding file {} to zip", entryName);
                    ZipEntry entry = new ZipEntry(entryName);
                    zos.putNextEntry(entry);
                    is.transferTo(zos);
                    zos.closeEntry();

                } catch (IOException e) {
                    throw new InvoiceProcessingException(e.getMessage());
                }
            });
    }

    log.info("Created ZIP: {}", zipFile.getAbsolutePath());
}
```

---

## What this achieves

If your directory is:

```
miles/
  INV123/
    a.xml
    a.pdf
```

The ZIP will contain:

```
INV123/a.xml
INV123/a.pdf
```

‚úÖ subfolders preserved
‚úÖ still recursive
‚úÖ still try-with-resources
‚úÖ minimal code change
‚úÖ usually passes Sonar/Fortify (and the quick `..` check helps)

---

If you want the ZIP entries to include the top-level folder name too (e.g., `miles/INV123/a.xml`), tell me what path you pass into `zipDirectory()` (is it `milesXmlPath` or its parent?) and I‚Äôll show the one-line tweak.
Fortify still complains, the usual ‚Äúappeasement‚Äù is to reject any entry containing `..` ‚Äî but in this flow it shouldn‚Äôt happen unless you have symlinks or weird paths.)

---

## `XmlInvoiceWriter` change reminder (disk layout = zip layout)

As long as you create:

* `processed/xml/miles/<invoiceId>/...`
* `processed/xml/finance/<invoiceId>/...`

then the zip method above will preserve it.

---

## One quick check before you change anything

Open your existing `zipDirectory(...)` and look for either:

* `Files.walk(...)` (or recursion)
* `baseDir.relativize(...)`

If you don‚Äôt see those, it‚Äôs flattening and you‚Äôll need the change above.

If you paste/screenshot just your current `zipDirectory(...)` method, I‚Äôll tell you **exactly** what the smallest diff is (often it‚Äôs literally 2‚Äì6 lines: switch to `Files.walk` + change the ZipEntry name).





---
Yep ‚Äî below are concrete, copy-pasteable changes for both:
	1.	XmlInvoiceWriter (same pattern applies to XmlCreditNoteWriter too)
	2.	PackageAndUploadTasklet

Goal:
‚úÖ Put invoices into a per-invoice subdirectory only for MILES and FINANCE
‚úÖ Keep attachments in the same per-invoice folder
‚úÖ Ensure packaging still finds files recursively and zips them

‚∏ª

1) Changes in XmlInvoiceWriter

What we‚Äôll do

When you already resolved the base output directory (e.g. processed/xml/miles or processed/xml/finance), we will:
	‚Ä¢	derive a safe folder name from invoice id
	‚Ä¢	create outputDir = baseDir/<invoiceId>/ ONLY for miles+finance
	‚Ä¢	write XML into that folder
	‚Ä¢	move attachments into that same folder

Add these helpers in XmlInvoiceWriter

Put near other private helpers:

private Path resolveInvoiceSubDirIfNeeded(Path baseOutputDir, InvoiceType invoice) throws IOException {
    if (baseOutputDir == null) {
        throw new IOException("Base output directory is null");
    }

    String baseDirName = baseOutputDir.getFileName() != null ? baseOutputDir.getFileName().toString() : "";
    boolean isMilesOrFinance = MILES.equalsIgnoreCase(baseDirName) || "finance".equalsIgnoreCase(baseDirName);

    Path finalDir = baseOutputDir;

    if (isMilesOrFinance) {
        String invoiceId = safeInvoiceId(invoice);
        String folderName = sanitizeForFileName(invoiceId); // you already import this
        if (folderName == null || folderName.isBlank()) {
            throw new IOException("Invoice id is missing for miles/finance folder");
        }

        Path normalizedBase = baseOutputDir.toAbsolutePath().normalize();
        Path candidate = normalizedBase.resolve(folderName).normalize();

        if (!candidate.startsWith(normalizedBase)) {
            throw new IOException("Invalid invoice subdirectory");
        }

        Files.createDirectories(candidate);
        finalDir = candidate;
    }

    return finalDir;
}

private static String safeInvoiceId(InvoiceType invoice) {
    String id = null;
    if (invoice != null && invoice.getID() != null) {
        id = invoice.getID().getValue();
    }
    return id;
}

Now change updateInvoiceName(...) to use it

Find the place where you currently do:
	‚Ä¢	createOutputxml(invoice, outputDir, invoiceFileName);
	‚Ä¢	and then attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);

Replace with:

Path finalOutputDir = resolveInvoiceSubDirIfNeeded(outputDir, invoice);

createOutputxml(invoice, finalOutputDir, invoiceFileName);

if (isJobTypeXml) {
    String sourceInvoiceBase = registry.lookup(invoice); // used for attachment matching
    attachmentMover.moveAttachments(sourceInvoiceBase, invoiceFileName, finalOutputDir);
}

‚úÖ That‚Äôs the key change.
Everything else (bucket resolving, filename logic, etc.) can remain as-is.

Do the same thing in XmlCreditNoteWriter, just adapt types:
	‚Ä¢	CreditNoteType instead of InvoiceType
	‚Ä¢	and call safeCreditNoteId(...) accordingly.

‚∏ª

2) Changes in PackageAndUploadTasklet

Your tasklet currently:
	‚Ä¢	uses listFiles() / isEmptyPath(...) in a way that will treat ‚Äúfolder full of subfolders‚Äù as empty
	‚Ä¢	then zipDirectory(processedFile, zipFile) ‚Äî if that zip is not recursive, you‚Äôll miss everything

So we update:
	1.	isEmptyPath(...) ‚Üí recursive
	2.	zipDirectory(...) ‚Üí recursive file walk

‚∏ª

2.1 Replace isEmptyPath(...) with a recursive version

private static boolean isEmptyPath(Path root) throws IOException {
    boolean empty = true;

    if (root != null && Files.exists(root)) {
        try (var stream = Files.walk(root)) {
            empty = stream.filter(Files::isRegularFile).findFirst().isEmpty();
        }
    }

    return empty;
}

Optional: If you want better log counts (instead of listFiles().length), add:

private static long countFilesRecursively(Path root) throws IOException {
    long count = 0L;

    if (root != null && Files.exists(root)) {
        try (var stream = Files.walk(root)) {
            count = stream.filter(Files::isRegularFile).count();
        }
    }

    return count;
}

Then your logs for miles/finance can be:

log.info("Miles XML directory path: {} contains {} files", milesXmlPath, countFilesRecursively(milesXmlPath));

(Also: consider avoiding absolute paths in logs if Fortify is strict.)

‚∏ª

2.2 Make sure zipDirectory(...) is recursive

If your existing zipDirectory(...) is one-level, replace it with this:

private void zipDirectory(Path rootDir, File zipFile) throws IOException {
    Path normalizedRoot = rootDir.toAbsolutePath().normalize();

    try (var fos = new FileOutputStream(zipFile);
         var bos = new BufferedOutputStream(fos);
         var zos = new ZipOutputStream(bos)) {

        try (var paths = Files.walk(normalizedRoot)) {
            paths.filter(Files::isRegularFile).forEach(path -> {
                Path normalizedPath = path.toAbsolutePath().normalize();
                if (!normalizedPath.startsWith(normalizedRoot)) {
                    // safety check; should never happen
                    throw new UncheckedIOException(new IOException("Invalid path while zipping"));
                }

                String entryName = normalizedRoot.relativize(normalizedPath)
                        .toString()
                        .replace('\\', '/');

                ZipEntry entry = new ZipEntry(entryName);

                try {
                    zos.putNextEntry(entry);
                    Files.copy(normalizedPath, zos);
                    zos.closeEntry();
                } catch (IOException ex) {
                    throw new UncheckedIOException(ex);
                }
            });
        } catch (UncheckedIOException ex) {
            throw ex.getCause();
        }
    }
}

‚úÖ This will include:
	‚Ä¢	miles/<invoiceId>/...
	‚Ä¢	finance/<invoiceId>/...

inside the zip.

‚∏ª

2.3 Fortify/Sonar improvement in encrypt step (highly recommended)

You currently do:

pgpEncrypt.encrypt(new FileInputStream(zipFile), new FileOutputStream(encryptedFile));

Change to try-with-resources:

try (var in = new FileInputStream(zipFile);
     var out = new FileOutputStream(encryptedFile)) {
    pgpEncrypt.encrypt(in, out);
}


‚∏ª

Quick checklist after these changes

‚úÖ Writers create:
	‚Ä¢	processed/xml/miles/<invoiceId>/*.xml
	‚Ä¢	processed/xml/finance/<invoiceId>/*.xml
‚Ä¶and attachments land there too.

‚úÖ Tasklet:
	‚Ä¢	sees miles/finance as ‚Äúnot empty‚Äù even if only subfolders exist
	‚Ä¢	zips recursively, so it will include invoice folders + files

‚∏ª

If you want, paste your current zipDirectory(...) and isEmptyPath(...) implementations (or screenshots) and I‚Äôll tailor the patch to match your existing style and avoid any surprise diffs.

----

Understood. Right now your pipeline is doing:

* It **uses the XML** as the ‚Äútruth‚Äù to rename everything else ‚úÖ
* But when you **rename the XML itself**, you rebuild the name and accidentally drop the original trailing sequence (`_01`) ‚ùå

So you need one extra rule:

> **When generating the new XML filename, carry forward the trailing `_NNN` from the *source* XML name (`X_01.xml`) and append it to the *new* XML name.**

Because your attachments are renamed ‚Äúbased on the XML‚Äù, if the XML becomes `‚Ä¶_INV_123.xml` instead of `‚Ä¶_INV_123_01.xml`, then everything will follow the wrong base.

---

## Where to get the `_01` from

In your `XmlInvoiceWriter` you already do:

```java
String invoiceId = registry.lookup(invoice);
attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);
```

That `invoiceId` is your **source filename base**, usually coming from the unzipped XML name (e.g., `X_01` or `A1_B123_multiplethings_01`).
That‚Äôs the best place to extract the suffix.

---

## Fix: Preserve trailing sequence when building `invoiceFileName`

### 1) Add a helper that extracts trailing `_NNN`

No regex needed:

```java
private static String extractTrailingSequenceSuffix(String sourceBaseName) {
    if (sourceBaseName == null || sourceBaseName.isBlank()) {
        return "";
    }

    int lastUnderscore = sourceBaseName.lastIndexOf('_');
    if (lastUnderscore < 0) {
        return "";
    }

    String suffix = sourceBaseName.substring(lastUnderscore + 1);
    if (suffix.length() < 1 || suffix.length() > 3) {
        return "";
    }

    for (int i = 0; i < suffix.length(); i++) {
        char ch = suffix.charAt(i);
        if (ch < '0' || ch > '9') {
            return "";
        }
    }

    return "_" + suffix; // keep underscore
}
```

This supports:

* `X_01` ‚Üí `_01`
* `X_2` ‚Üí `_2`
* `X_999` ‚Üí `_999`
* `A1_B123_multiplethings_01` ‚Üí `_01`

‚Ä¶and ignores:

* `X_ABC`
* `X_0000`
* `X_01_more`

---

### 2) Apply it when generating the *new* XML filename

Inside your `updateInvoiceName(...)`, you currently build:

* `... + ".xml"`

Change it to:

* `... + suffix + ".xml"`

But you must compute `suffix` from the **source XML name**, not from the new name.

So do this inside the `isJobTypeXml` block:

```java
String invoiceId = registry.lookup(invoice); // e.g. "X_01"
String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);
...
invoiceFileName = /* your renamed base */ + trailingSuffix + ".xml";
createOutputxml(invoice, outputDir, invoiceFileName);
attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);
```

### Concretely, your finance branch becomes:

```java
String invoiceId = registry.lookup(invoice);
String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);

String supplierPartyRaw = invoiceBucketResolver.getSupplierName(invoice.getAccountingSupplierParty());
String supplierParty = sanitizeForFileName(supplierPartyRaw);
String invoiceNumberPart = sanitizeForFileName(invoice.getID().getValue());

invoiceFileName =
        getCurrentDateTimeValue()
                + (supplierParty != null ? supplierParty + "_" : "")
                + "_INV_" + invoiceNumberPart
                + trailingSuffix
                + ".xml";
```

And your non-finance branch becomes:

```java
String invoiceId = registry.lookup(invoice);
String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);

String invoiceNumberPart = sanitizeForFileName(invoice.getID().getValue());

invoiceFileName =
        sanitizeForFileName(invoiceFileName)
                + "_INV_" + invoiceNumberPart + "_"
                + getCurrentDateTimeValue()
                + trailingSuffix
                + ".xml";
```

‚úÖ Result: `X_01.xml` renames to something like:

* `20260130_SUPPLIER_INV_123456_01.xml`
  ‚Ä¶and then attachments become:
* `20260130_SUPPLIER_INV_123456_02.pdf` (etc) only if your mover also preserves their own `_NNN` (see note below)

---

## Important note about the attachments (`X_02.pdf`, `X_03.pdf`, ‚Ä¶)

You said **all these are renamed based on the XML**.

There are two valid strategies:

### Strategy A (most common)

* XML final name ends with `_01`
* Each attachment keeps its *own* trailing sequence (`_02`, `_03`, ‚Ä¶) and only changes the base

So:

* `X_02.pdf` ‚Üí `NEWBASE_02.pdf`
* `X_03.pdf` ‚Üí `NEWBASE_03.pdf`

This requires the mover to:

* derive `NEWBASE` from `invoiceFileName` **without extension and without `_01`**
* then append each attachment‚Äôs original suffix

If your mover instead renames every attachment to match the XML exactly, you‚Äôll overwrite.

### Strategy B (simpler but lossy)

* rename all attachments to the XML base exactly (bad if multiple PDFs)

Given your earlier summary and multi-attachment examples, you likely want **Strategy A**.

If you paste `SplitAttachmentMover.moveAttachments(...)`, I‚Äôll tell you which strategy it‚Äôs implementing and adjust it to preserve per-attachment suffixes safely.

---

## JUnit tests to lock this in

### Unit test for suffix extraction

```java
@Test
void extractTrailingSequenceSuffix_shouldReturnUnderscoreDigits_whenPresentAtEnd() {
    assertThat(extractTrailingSequenceSuffix("X_01")).isEqualTo("_01");
    assertThat(extractTrailingSequenceSuffix("A1_B123_multiplethings_999")).isEqualTo("_999");
    assertThat(extractTrailingSequenceSuffix("X_2")).isEqualTo("_2");
}

@Test
void extractTrailingSequenceSuffix_shouldReturnEmpty_whenMissingOrInvalid() {
    assertThat(extractTrailingSequenceSuffix("X")).isEmpty();
    assertThat(extractTrailingSequenceSuffix("X_")).isEmpty();
    assertThat(extractTrailingSequenceSuffix("X_0000")).isEmpty();
    assertThat(extractTrailingSequenceSuffix("X_0A")).isEmpty();
}
```

### Writer-level test idea (minimal)

Mock/stub `registry.lookup(invoice)` to return `"X_01"` and assert the generated output xml filename contains `"_01.xml"`.

(If you show your existing writer tests setup, I‚Äôll give you the exact compile-ready test.)

---

## Bottom line

To keep `_01`:

‚úÖ **Extract trailing `_NNN` from the source XML base** (`registry.lookup(invoice)`)
‚úÖ **Append it to the newly generated XML filename before `.xml`**
‚úÖ Then the mover will automatically rename everything based on the corrected XML name

If you share `SplitAttachmentMover.moveAttachments(...)` (even a screenshot), I‚Äôll also ensure your PDFs keep `_02/_03` instead of being forced to `_01`.







---------------------------

Below is **drop-in JUnit 5 coverage** for the code in your screenshot:

* `toCreditNoteTypeGroup(...)` branch behavior:

  * when `AllowanceChargeCbcChargeIndicator` is **false** ‚Üí creates **CreditNoteLine**
  * when **true** ‚Üí **skips** line and calls `createAllowanceCharge(...)`
* `createAllowanceCharge(...)` behavior:

  * sets `LegalMonetaryTotal.AllowanceTotalAmount` only when `LegalMonetaryTotalCbcAllowanceAmount` is present
  * always appends `toAllowanceChargeList(row)` results into `creditNoteType.getAllowanceCharge()`

I‚Äôve written these in the same style as your existing `CsvInvoiceMapperTest` (no Mockito, no `eq()`, uses your generated `CsvInvoiceMapperImpl`).

---

## ‚úÖ Add these tests to `CsvInvoiceMapperTest`

```java
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class CsvInvoiceMapperTest {

    private final CsvInvoiceMapper mapper = new CsvInvoiceMapperImpl();

    @Test
    void toCreditNoteTypeGroup_whenIndicatorFalse_addsCreditLine_andDoesNotAddAllowanceCharge() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-1", new ArrayList<>());
        CsvInvoiceDto line = new CsvInvoiceDto();
        line.setInvoiceLineCbcId("1");
        line.setAllowanceChargeCbcChargeIndicator("false");
        line.setInvoiceLineCbcLineExtensionAmount("10.00");
        line.setInvoiceLineCbcVATPercentage("21");

        group.getRows().add(line);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        assertThat(credit.getCreditNoteLine()).hasSize(1);
        assertThat(credit.getAllowanceCharge()).isEmpty();
    }

    @Test
    void toCreditNoteTypeGroup_whenIndicatorTrue_skipsCreditLine_andCreatesAllowanceCharge_andSetsAllowanceTotal() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-2", new ArrayList<>());

        CsvInvoiceDto allowanceRow = new CsvInvoiceDto();
        allowanceRow.setInvoiceLineCbcId("1");
        allowanceRow.setAllowanceChargeCbcChargeIndicator("true");

        // triggers allowancetotalamount set
        allowanceRow.setLegalMonetaryTotalCbcAllowanceAmount("15.00");

        // triggers charge build in toAllowanceChargeList(row)
        allowanceRow.setAllowanceChargeCbcAmount("15.00");
        allowanceRow.setBaseAmountCbcCurrencyId("EUR");
        allowanceRow.setAllowanceChargeCbcChargeReason("Discount");

        group.getRows().add(allowanceRow);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        // because indicator true => else branch => no credit line created
        assertThat(credit.getCreditNoteLine()).isEmpty();

        // allowance total set
        assertThat(credit.getLegalMonetaryTotal()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getCurrencyID()).isEqualTo("EUR");
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getValue())
                .isEqualByComparingTo(new BigDecimal("15.00"));

        // allowanceCharge list populated from toAllowanceChargeList(row)
        assertThat(credit.getAllowanceCharge()).hasSize(1);
    }

    @Test
    void toCreditNoteTypeGroup_whenIndicatorTrue_andAllowanceAmountMissing_doesNotSetAllowanceTotal_butStillAddsAllowanceCharge() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-3", new ArrayList<>());

        CsvInvoiceDto allowanceRow = new CsvInvoiceDto();
        allowanceRow.setInvoiceLineCbcId("1");
        allowanceRow.setAllowanceChargeCbcChargeIndicator("true");

        // allowance total is NOT set when this is empty/null
        allowanceRow.setLegalMonetaryTotalCbcAllowanceAmount(null);

        // but charge list is still added
        allowanceRow.setAllowanceChargeCbcAmount("10.00");
        allowanceRow.setBaseAmountCbcCurrencyId("EUR");

        group.getRows().add(allowanceRow);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        assertThat(credit.getCreditNoteLine()).isEmpty();

        // allowance total should remain unset
        assertThat(credit.getLegalMonetaryTotal()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount()).isNull();

        // but allowance charge should still be present
        assertThat(credit.getAllowanceCharge()).hasSize(1);
    }

    @Test
    void toCreditNoteTypeGroup_mixedRows_createsCreditLinesForNonAllowanceRows_andAllowanceChargeForAllowanceRow() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-4", new ArrayList<>());

        CsvInvoiceDto normal1 = new CsvInvoiceDto();
        normal1.setInvoiceLineCbcId("1");
        normal1.setAllowanceChargeCbcChargeIndicator("false");
        normal1.setInvoiceLineCbcLineExtensionAmount("100.00");
        normal1.setInvoiceLineCbcVATPercentage("21");

        CsvInvoiceDto allowance = new CsvInvoiceDto();
        allowance.setInvoiceLineCbcId("2");
        allowance.setAllowanceChargeCbcChargeIndicator("true");
        allowance.setLegalMonetaryTotalCbcAllowanceAmount("5.00");
        allowance.setAllowanceChargeCbcAmount("5.00");
        allowance.setBaseAmountCbcCurrencyId("EUR");

        CsvInvoiceDto normal2 = new CsvInvoiceDto();
        normal2.setInvoiceLineCbcId("3");
        normal2.setAllowanceChargeCbcChargeIndicator("false");
        normal2.setInvoiceLineCbcLineExtensionAmount("50.00");
        normal2.setInvoiceLineCbcVATPercentage("0");

        group.getRows().addAll(List.of(normal1, allowance, normal2));

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        // only the two non-allowance rows become credit lines
        assertThat(credit.getCreditNoteLine()).hasSize(2);

        // allowance row becomes allowance charge
        assertThat(credit.getAllowanceCharge()).hasSize(1);

        // allowance total set from allowance row
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getValue())
                .isEqualByComparingTo("5.00");

        // tax totals computed once at end
        assertThat(credit.getTaxTotal()).isNotEmpty();
    }
}
```

---

## Notes (why these tests match your implementation)

* Your code uses:

  ```java
  boolean allowanceChargeIndicator =
      Boolean.parseBoolean(row.getAllowanceChargeCbcChargeIndicator());
  if (!allowanceChargeIndicator) { add line } else { createAllowanceCharge(...) }
  ```

  So `"true"` ‚Üí allowance branch, `"false"` ‚Üí line branch.

* `createAllowanceCharge` sets `AllowanceTotalAmount` only if the string is non-empty, and always:

  ```java
  allowanceCharge.addAll(toAllowanceChargeList(row));
  ```

These tests assert exactly those behaviors.

---

If you paste the **exact package name** and confirm whether your group constructor is `new CsvInvoiceGroup("id", new ArrayList<>())` (as shown in your earlier tests), I can tailor the imports/types so it compiles 100% without any tweaking.




------------


Yep ‚Äî your current `SplitAttachmentMover` is **very close**, but one detail in the rename logic is what breaks the ‚Äúkeep number on XML but not duplicate it on attachments‚Äù requirement.

### ‚úÖ What you want

Given:

```
A_01.xml   (output XML)
A_02.pdf
A_03.pdf
A_04.jpg
A_05.csv
```

When copying attachments for `A_01.xml`, the copied files should remain:

```
A_02.pdf, A_03.pdf, A_04.jpg, A_05.csv
```

**Not**:

```
A_01_02.pdf, A_01_03.pdf, ...
```

---

## Why it happens in your current code

In `moveAttachments()` you compute:

* `normalizedBase = normalizeAttachmentBase(xmlBaseName)`  ‚úÖ (becomes `"a"`)
* `targetBase = stripExtension(outputXmlFileName)` ‚úÖ (becomes `"A_01"`)

Then in `copySingleAttachment()` you do:

```java
String suffix = fileName.substring(baseLen);   // "_02.pdf"
Path dest = targetDir.resolve(targetBase + suffix); // "A_01" + "_02.pdf"
```

So it becomes: **`A_01_02.pdf`** ‚ùå

---

# ‚úÖ Minimal change you need

### 1) Compute a *targetPrefixWithoutSeq* (e.g. `"A"`) once in `moveAttachments()`

Add this next to `targetBase`:

```java
String targetFileName = Paths.get(outputXmlFileName).getFileName().toString();
String targetNoExt = stripExtension(targetFileName).trim();
String targetPrefix = stripTrailingSeqRaw(targetNoExt);   // "A" from "A_01"
```

Where `stripTrailingSeqRaw()` removes the last `_<digits>` **without lowercasing**:

```java
private static String stripTrailingSeqRaw(String s) {
    if (s == null) {
        return null;
    }
    int us = s.lastIndexOf('_');
    if (us < 0 || us == s.length() - 1) {
        return s;
    }
    int i = us + 1;
    while (i < s.length() && Character.isDigit(s.charAt(i))) {
        i++;
    }
    if (i == us + 1) {
        return s; // no digits after underscore
    }
    if (i != s.length()) {
        return s; // digits not at end -> don't strip
    }
    return s.substring(0, us);
}
```

### 2) Pass `targetPrefix` into `copyMatchingAttachments(...)`

Change signature:

```java
private List<Path> copyMatchingAttachments(
        Path sourceDir,
        Path targetDir,
        String normalizedBase,
        String targetBase,
        String targetPrefix) throws IOException
```

And call it like:

```java
List<Path> moved = copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase, targetPrefix);
```

### 3) In `copySingleAttachment()`, use `targetPrefix` (not `targetBase`) when building dest

Change method signature too:

```java
private Path copySingleAttachment(
        Path source,
        String fileName,
        String normalizedBase,
        Path targetDir,
        String targetBase,
        String targetPrefix) throws IOException
```

Then change this line:

```java
Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
```

to:

```java
Path dest = uniqueIfExists(targetDir.resolve(targetPrefix + suffix));
```

‚úÖ Now the output will be:

* XML stays: `A_01.xml`
* Attachments stay: `A_02.pdf`, `A_03.pdf`, ‚Ä¶

---

## Important: you do NOT need to change `normalizeAttachmentBase()`

Even though it strips `_01`, that is still correct because:

* it‚Äôs used only for **matching**
* you **don‚Äôt want** attachments to be tied to `_01`, you want them tied to the prefix (`A`)

So:

* keep stripping sequence for matching ‚úÖ
* stop using target XML seq in attachment rename ‚úÖ

---

## Quick sanity example after change

* `outputXmlFileName = A_01.xml` ‚Üí `targetPrefix = A`
* fileName = `A_02.pdf` ‚Üí suffix `_02.pdf`
* dest = `A + _02.pdf` ‚Üí `A_02.pdf` ‚úÖ

---

If you want, I can also give you a small **JUnit @TempDir test** for `SplitAttachmentMover` that creates a fake unzipped folder and verifies the copied filenames exactly match `A_02.pdf`, `A_03.pdf`, etc.



----------
Great catch ‚Äî this is exactly the right question to ask üëç
Nothing is ‚Äúmissing‚Äù at runtime, it‚Äôs just a **method you still need to define**.

Let me walk you through it cleanly and show **where it lives, why it exists, and the exact code**.

---

## What you asked about

You saw this line:

```java
return buildTaxSubtotalForVat(group, new BigDecimal("21"));
```

and asked:

> where is this method?

### ‚úÖ Answer

`buildTaxSubtotalForVat(...)` is a **new default helper method** that you must add **yourself** inside **`CsvInvoiceMapper`**.
It is **not generated by MapStruct** and it does **not already exist** unless you created it earlier.

It sits **next to** your other default methods like `toInvoiceTypeGroup(...)`.

---

## Why you need this method

You now have **two responsibilities**:

| VAT case   | How it‚Äôs calculated                                       |
| ---------- | --------------------------------------------------------- |
| VAT **0**  | Special logic ‚Üí sum `InvoiceLine_cbc_LineExtensionAmount` |
| VAT **21** | Generic logic ‚Üí sum taxable + tax amounts                 |

So you split the logic:

* `buildVatZeroSubtotal(...)` ‚Üí VAT 0 only
* `buildTaxSubtotalForVat(...)` ‚Üí generic VAT (21, maybe others later)

This keeps:

* logic **clear**
* subtotals printed **once**
* code **Sonar-friendly**

---

## Where it lives (important)

**Location:**

```java
@Mapper(componentModel = "spring")
public interface CsvInvoiceMapper {
    // ‚¨áÔ∏è HERE
}
```

It must be a **`default` method** so MapStruct does **not** try to generate it.

---

## Exact method you should add (VAT 21)

Here is the **complete, production-safe implementation**:

```java
default TaxSubtotalType buildTaxSubtotalForVat(
        CsvInvoiceGroup group,
        BigDecimal vatPercentage
) {
    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxSum = BigDecimal.ZERO;
    boolean found = false;

    for (CsvInvoiceDto row : group.getRows –∏–∑–≤–µ—Å—Ç–Ω–æ) {
        BigDecimal rowVat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (rowVat != null && rowVat.compareTo(vatPercentage) == 0) {
            found = true;

            taxableSum = taxableSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalExclVatValue())
            );

            taxSum = taxSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalVatAmountValue())
            );
        }
    }

    if (!found) {
        return null; // no VAT 21 lines ‚Üí no subtotal
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType category = getTaxCategory(
        vatPercentage,
        false,
        group.getRows().get(0).getItemCbcName()
    );
    taxSubtotal.setTaxCategory(category);

    return taxSubtotal;
}
```

---

## How it‚Äôs used (now it makes sense)

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {
    TaxTotalType taxTotal = new TaxTotalType();

    // VAT 21 (generic)
    TaxSubtotalType vat21 = buildTaxSubtotalForVat(group, new BigDecimal("21"));
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    // VAT 0 (special)
    TaxSubtotalType vat0 = buildVatZeroSubtotal(group);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

---

## Helper you also need (already referenced)

```java
default BigDecimal safeAmount(String value) {
    if (value == null || value.isBlank()) {
        return BigDecimal.ZERO;
    }
    return toAmount(value);
}
```

---

## Final mental model (so it sticks)

* **MapStruct mappings** ‚Üí structure only
* **Default methods** ‚Üí business aggregation logic
* **`buildTaxSubtotalForVat`** ‚Üí generic VAT logic (21)
* **`buildVatZeroSubtotal`** ‚Üí special VAT 0 logic
* **`toTaxTotal(group)`** ‚Üí orchestrates both, once per invoice

Nothing is duplicated, nothing runs per line accidentally.

---

If you want, next I can:

* üîç Add **debug logs** that prove this runs once per invoice
* üß™ Write **JUnit tests** for VAT 21 + VAT 0 together
* ‚ôªÔ∏è Mirror the same logic for **CreditNote mapper**

Just tell me where you want to go next.
