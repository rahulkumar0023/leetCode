Perfect ‚Äî understood üëå
If your boss is presenting this to management, the text should be:
	‚Ä¢	Concise (no long paragraphs)
	‚Ä¢	Step-based (clear actions, easy to follow)
	‚Ä¢	Outcome-oriented (shows results + value of your work)

Here‚Äôs a polished playbook version of your flow, ready to present:

‚∏ª

Dev Connectivity & Access Playbook

‚∏ª

0. How Requests Start
	‚Ä¢	Dev raises issue (email, dev community, or call).
	‚Ä¢	We categorize request into one of five buckets:
	1.	Firewall / Connectivity
	2.	Database Access (SQL/Oracle)
	3.	API Connectivity
	4.	SFTP / WinSCP
	5.	Other Tooling (Liberty, IntelliJ, AS400, etc.)

‚∏ª

1. Firewall / Connectivity
	1.	Check if request is for Dev/Test ‚Üí firewall request is enough.
	2.	If other servers ‚Üí validate CyberArk ticket.
	3.	Raise firewall request in tracker ‚Üí share with infra.
	4.	Infra implements ‚Üí we validate.
	5.	Dev tests ‚Üí if OK ‚Üí close request.
	6.	If not working ‚Üí escalate for further troubleshooting.

‚∏ª

2. Database Access (SQL/Oracle)
	1.	Confirm DB must go via CyberArk.
	2.	Infra configures DB connection in CyberArk.
	3.	Raise user onboarding request.
	4.	User validates connection.
	5.	If OK ‚Üí close request.
	6.	Future onboarding ‚Üí handled via ServiceNow.

‚∏ª

3. API Connectivity (Postman/Bruno)
	1.	Initially checked via firewall ‚Üí later found APIs behind proxies.
	2.	Worked with infra to confirm setup.
	3.	Dev must configure:
	‚Ä¢	Proxy settings in Postman/Bruno.
	‚Ä¢	Certificates in Postman.
	‚Ä¢	Proxy setup on Mac.
	4.	We guide devs (calls + docs).
	5.	If API works via proxy ‚Üí close request.

‚∏ª

4. SFTP / WinSCP
	1.	Onboard user to CyberArk.
	2.	Test login + file access (early phase: we acted as test users, reported permission gaps).
	3.	Infra adjusts permissions.
	4.	Verify file access + WinSCP directory mapping.
	5.	Provide docs:
	‚Ä¢	CyberArk access from Mac.
	‚Ä¢	WinSCP upload/download steps.
	6.	Dev validates ‚Üí close request.

‚∏ª

5. Other Tooling / Environment
	1.	Devs often lack time to configure tools.
	2.	We test, configure, and create step-by-step guides.
	‚Ä¢	IntelliJ Ultimate ‚Üí added to self-service (with infra + Mac support).
	‚Ä¢	AS400 Access ‚Üí TN5250 client added.
	‚Ä¢	Liberty Server ‚Üí configured locally, docs created.
	3.	Share setup guides with devs.
	4.	Provide initial support calls if needed.
	5.	Once confirmed ‚Üí close request.

‚∏ª

6. Closure & Knowledge Sharing
	‚Ä¢	Every resolved issue = documented steps.
	‚Ä¢	Built a library of guides (Postman, CyberArk, WinSCP, Liberty, AS400, IntelliJ).
	‚Ä¢	Developers can now self-serve for repeat issues.

‚∏ª

üëâ This format shows management:
	‚Ä¢	Clear flows
	‚Ä¢	Your coordination role with infra + devs
	‚Ä¢	Deliverables produced (docs, configs, tools)
	‚Ä¢	Ongoing value (knowledge base for devs)

‚∏ª

Would you like me to also make a 1-page executive summary version (super high-level, for slides), or keep it only as this playbook-style text?


‚Äî‚Äî‚Äî‚Äî


Got it ‚úÖ
Here‚Äôs a complete step-based flow that captures how requests start, how you categorize, what you/your team do, how it progresses, and how it closes. I‚Äôve kept it structured but detailed so it reflects your actual work:

‚∏ª

Step-Based Flow for Handling Dev Requests

‚∏ª

0. Entry Point ‚Äì Issue Reported
	‚Ä¢	A developer reports an issue (via email, dev community, or call).
	‚Ä¢	We log the request and start by categorizing the type of issue:
	‚Ä¢	Firewall / Connectivity (MQ, Kafka, server-to-server)
	‚Ä¢	Database Access (SQL Server, Oracle)
	‚Ä¢	API Connectivity (Postman/Bruno, proxy settings)
	‚Ä¢	SFTP / WinSCP (server login, file transfer)
	‚Ä¢	Other Tooling / Environment (Liberty, IntelliJ Ultimate, AS400 console, etc.)

‚∏ª

1. Firewall / Connectivity Requests
	1.	Identify if the request is for Dev/Test environment.
	‚Ä¢	If yes ‚Üí opening a firewall rule is usually enough.
	‚Ä¢	If not ‚Üí confirm valid CyberArk onboarding and ticket.
	2.	Create a firewall request in the request tracker.
	3.	Share request details with infra team.
	4.	Infra team implements the firewall and notifies us.
	5.	We validate the connection from our side.
	6.	If firewall is okay, we ask the developer to test.
	7.	If dev confirms it works ‚Üí close request.
	8.	If not ‚Üí continue debugging, check logs, troubleshoot further.

‚∏ª

2. Database Access (SQL Server, Oracle)
	1.	Dev requests DB connection.
	2.	We ensure DB connection must go through CyberArk.
	3.	Early phase: we worked with infra team to clarify setup requirements.
	4.	Infra configures DB connection in CyberArk based on info shared.
	5.	Once config is ready ‚Üí raise user onboarding request.
	6.	After onboarding ‚Üí requestor is asked to validate DB connection.
	7.	If connection works ‚Üí close request.
	8.	New onboarding requests must now go via ServiceNow (regular process).

‚∏ª

3. API Connectivity (Postman/Bruno)
	1.	Initially we requested firewall openings, but later found APIs are behind proxies.
	2.	Worked with Inna + infra team to troubleshoot and confirm proxy setup.
	3.	Developers need to:
	‚Ä¢	Adapt proxy settings in Postman or Bruno.
	‚Ä¢	Add certificates in Postman.
	‚Ä¢	Configure Postman proxy on Mac (we created docs for this).
	4.	We often walk devs through initial setups on calls.
	5.	Once proxy configuration is correct ‚Üí developer validates API call.
	6.	If successful ‚Üí close request.
	7.	If not ‚Üí more troubleshooting to see in which scenarios proxy works.

‚∏ª

4. SFTP / WinSCP (Server & File Access)
	1.	Dev needs server or file access.
	2.	First step ‚Üí onboarding user to CyberArk.
	3.	Early phase: we acted as test users to identify issues (e.g., able to log in but couldn‚Äôt see files due to missing permissions).
	4.	Reported issues back to infra for corrections.
	5.	Once CyberArk setup works:
	‚Ä¢	Dev can log in to server.
	‚Ä¢	File access permissions are verified.
	‚Ä¢	WinSCP local directory mapping is tested (upload/download).
	6.	We created documentation for:
	‚Ä¢	Accessing CyberArk from Mac.
	‚Ä¢	Steps to use WinSCP for file transfers.
	7.	After developer validates access ‚Üí close request.

‚∏ª

5. Other Tooling / Environment Requests
	1.	Devs sometimes lack time to configure local tools (e.g., Liberty server).
	‚Ä¢	We experiment, configure, and document step-by-step setup guides.
	2.	Example achievements:
	‚Ä¢	IntelliJ Ultimate was not in self-service ‚Üí we raised it with infra + Mac support ‚Üí package added.
	‚Ä¢	AS400 Access: TN5250 client was missing ‚Üí we got it added, now accessible from Mac.
	‚Ä¢	Liberty server: we tested locally and created working setup steps for devs.
	3.	Once tools are ready:
	‚Ä¢	We share documentation and guides with devs.
	‚Ä¢	Support devs in initial calls if needed.
	‚Ä¢	Requests are closed once dev confirms setup works.

‚∏ª

6. Closure & Knowledge Sharing
	‚Ä¢	After any category request is completed:
	‚Ä¢	Developer validates ‚Üí request closed.
	‚Ä¢	Steps/findings are documented (Mac setup guides, Postman configs, WinSCP usage, Liberty setup, etc.).
	‚Ä¢	Shared with devs for self-service in future.
	‚Ä¢	Over time, created a library of troubleshooting docs and how-to guides.

‚∏ª

‚úÖ This is your work summarized as a structured step-based flow:
	‚Ä¢	Categorize issues
	‚Ä¢	Drive the technical + coordination steps with infra
	‚Ä¢	Validate and troubleshoot
	‚Ä¢	Close requests
	‚Ä¢	Document for future reuse

‚∏ª

Would you like me to now restructure this into a concise ‚Äúplaybook‚Äù format (like numbered flows per category, shorter wording) so it reads more like an official process guide rather than a detailed report?

Absolutely‚Äîhere are focused, drop-in **JUnit 5** test classes to cover:

1. the **processor** (CSV ‚Üí `InvoiceType` or `CreditNoteType`)
2. the **classifier writer** (routes to your two writers)
3. an **end-to-end step test** (reader ‚Üí processor ‚Üí classifier writer) proving items are routed correctly

Assumptions:

* Package names for UBL classes are the standard ones (adjust if yours differ).
* You have `spring-boot-starter-test`, `spring-batch-test`, and `mockito` on the classpath.

---

# 1) Processor test

```java
package com.alphacredit.batch.processing;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvToUblProcessor processor;

  @Test
  void returnsCreditNote_whenTypeCode381() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381");
    var cn = new CreditNoteType();
    when(mapper.toCreditNoteType(dto)).thenReturn(cn);

    Object out = processor.process(dto);

    assertTrue(out instanceof CreditNoteType);
    verify(mapper).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void returnsInvoice_otherwise() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380");
    var inv = new InvoiceType();
    when(mapper.toInvoiceType(dto)).thenReturn(inv);

    Object out = processor.process(dto);

    assertTrue(out instanceof InvoiceType);
    verify(mapper).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }
}
```

---

# 2) Classifier writer test

This verifies that objects are dispatched to the correct writer.

```java
package com.alphacredit.batch.writer;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UblClassifierWriterTest {

  @SuppressWarnings("unchecked")
  @Test
  void routesToCorrectDelegate() throws Exception {
    // Arrange: two concrete writers
    ItemWriter<InvoiceType> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<CreditNoteType> creditWriter = mock(ItemWriter.class);

    // Build the classifier writer just like in your WriterConfig
    ClassifierCompositeItemWriter<Object> classifier = new ClassifierCompositeItemWriter<>();
    classifier.setClassifier(item -> {
      if (item instanceof InvoiceType) return (ItemWriter<Object>)(ItemWriter<?>)invoiceWriter;
      if (item instanceof CreditNoteType) return (ItemWriter<Object>)(ItemWriter<?>)creditWriter;
      throw new IllegalArgumentException("Unsupported: " + item.getClass());
    });

    // Input batch: 2 invoices + 1 credit note
    var inv1 = new InvoiceType();
    var inv2 = new InvoiceType();
    var cn1  = new CreditNoteType();

    // Act
    classifier.write(List.of(inv1, cn1, inv2));

    // Assert: each delegate got only the items of its type
    ArgumentCaptor<List<InvoiceType>> invCap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(2)).write(invCap.capture());
    // Because ClassifierCompositeItemWriter calls delegate per-item, we expect multiple single-item lists
    assertEquals(2, invCap.getAllValues().size());
    assertTrue(invCap.getAllValues().stream().allMatch(l -> l.size() == 1 && l.get(0) instanceof InvoiceType));

    ArgumentCaptor<List<CreditNoteType>> cnCap = ArgumentCaptor.forClass(List.class);
    verify(creditWriter, times(1)).write(cnCap.capture());
    assertEquals(1, cnCap.getAllValues().size());
    assertEquals(1, cnCap.getValue().size());
    assertTrue(cnCap.getValue().get(0) instanceof CreditNoteType);

    verifyNoMoreInteractions(invoiceWriter, creditWriter);
  }
}
```

---

# 3) End-to-end step test (Spring Batch)

This spins up a minimal Spring context and proves that:

* the **processor** converts based on `InvoiceTypeCode`
* the **classifier** routes to the right writer
* both writers get called the expected number of times

We‚Äôll use **stub writers** that just record what they saw.

```java
package com.alphacredit.batch.step;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.*;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.*;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CsvToXmlStepTest.Config.class)
class CsvToXmlStepTest {

  @Autowired JobLauncher launcher;
  @Autowired Job job;
  @Autowired Config.RecordingInvoiceWriter invWriter;
  @Autowired Config.RecordingCreditWriter cnWriter;

  @Test
  void routesInvoicesAndCreditNotes() throws Exception {
    JobExecution exec = launcher.run(job, new JobParameters());
    assertEquals(BatchStatus.COMPLETED, exec.getStatus());

    // We fed 2 invoices + 1 creditnote (see reader below)
    assertEquals(2, invWriter.items.size());
    assertEquals(1, cnWriter.items.size());
  }

  // ---- Test configuration ----
  @Configuration
  @EnableBatchProcessing
  static class Config {

    // Simple reader that returns 3 DTOs: 2 invoices (380) + 1 credit (381)
    @Bean
    ItemReader<CsvInvoiceDto> reader() {
      List<CsvInvoiceDto> list = new ArrayList<>();
      list.add(dto("INV-1", "380"));
      list.add(dto("INV-2", "380"));
      list.add(dto("CN-1",  "381"));
      return new ListItemReader<>(list);
    }

    private static CsvInvoiceDto dto(String id, String typeCode) {
      CsvInvoiceDto d = new CsvInvoiceDto();
      d.setInvoiceNumber(id);
      d.setInvoiceTypeCode(typeCode);
      return d;
    }

    // Mapper stub that makes minimal UBL objects
    @Bean
    CsvInvoiceMapper mapper() {
      return new CsvInvoiceMapper() {
        @Override public InvoiceType toInvoiceType(CsvInvoiceDto src) {
          InvoiceType inv = new InvoiceType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          inv.setID(id);
          return inv;
        }
        @Override public CreditNoteType toCreditNoteType(CsvInvoiceDto src) {
          CreditNoteType cn = new CreditNoteType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          cn.setID(id);
          return cn;
        }
      };
    }

    @Bean CsvToUblProcessor processor(CsvInvoiceMapper mapper) { return new CsvToUblProcessor(mapper); }

    // Recording writers (stand-ins for your XMLInvoiceWriter / XMLCreditNoteWriter)
    @Bean RecordingInvoiceWriter invoiceWriter() { return new RecordingInvoiceWriter(); }
    @Bean RecordingCreditWriter creditWriter()   { return new RecordingCreditWriter(); }

    @Bean
    @SuppressWarnings("unchecked")
    ClassifierCompositeItemWriter<Object> classifierWriter(RecordingInvoiceWriter inv, RecordingCreditWriter cn) {
      ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();
      cw.setClassifier(item -> {
        if (item instanceof InvoiceType)     return (ItemWriter<Object>)(ItemWriter<?>) inv;
        if (item instanceof CreditNoteType)  return (ItemWriter<Object>)(ItemWriter<?>) cn;
        throw new IllegalArgumentException("Unsupported: " + item);
      });
      return cw;
    }

    @Bean
    Job job(JobRepository repo, PlatformTransactionManager tx,
            ItemReader<CsvInvoiceDto> reader,
            CsvToUblProcessor processor,
            ClassifierCompositeItemWriter<Object> writer) {
      Step step = new StepBuilder("csvToXmlStep", repo)
          .<CsvInvoiceDto, Object>chunk(10, tx)
          .reader(reader)
          .processor(processor)
          .writer(writer)
          .build();
      return new JobBuilder("testJob", repo).start(step).build();
    }

    // --- recording writers
    static class RecordingInvoiceWriter implements ItemWriter<InvoiceType> {
      final List<InvoiceType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends InvoiceType> items) { this.items.addAll(items); }
    }
    static class RecordingCreditWriter implements ItemWriter<CreditNoteType> {
      final List<CreditNoteType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends CreditNoteType> items) { this.items.addAll(items); }
    }
  }
}
```

---

## What these tests give you

* ‚úÖ **Processor logic**: confidently flips to `CreditNoteType` when `InvoiceTypeCode == 381`.
* ‚úÖ **Routing**: classifier sends each object to the correct concrete writer.
* ‚úÖ **Step integration**: with a real Batch step, confirms two invoices + one credit note end up in the expected writers.

If you want, I can also add quick tests for your `BucketResolver` on both `InvoiceType` and `CreditNoteType` using your latest implementation, but since you already validated that earlier, these three should cover your CSV‚Üípolymorphic UBL flow end-to-end.


Absolutely‚Äîhere are focused, drop-in **JUnit 5** test classes to cover:

1. the **processor** (CSV ‚Üí `InvoiceType` or `CreditNoteType`)
2. the **classifier writer** (routes to your two writers)
3. an **end-to-end step test** (reader ‚Üí processor ‚Üí classifier writer) proving items are routed correctly

Assumptions:

* Package names for UBL classes are the standard ones (adjust if yours differ).
* You have `spring-boot-starter-test`, `spring-batch-test`, and `mockito` on the classpath.

---

# 1) Processor test

```java
package com.alphacredit.batch.processing;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvToUblProcessor processor;

  @Test
  void returnsCreditNote_whenTypeCode381() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381");
    var cn = new CreditNoteType();
    when(mapper.toCreditNoteType(dto)).thenReturn(cn);

    Object out = processor.process(dto);

    assertTrue(out instanceof CreditNoteType);
    verify(mapper).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void returnsInvoice_otherwise() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380");
    var inv = new InvoiceType();
    when(mapper.toInvoiceType(dto)).thenReturn(inv);

    Object out = processor.process(dto);

    assertTrue(out instanceof InvoiceType);
    verify(mapper).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }
}
```

---

# 2) Classifier writer test

This verifies that objects are dispatched to the correct writer.

```java
package com.alphacredit.batch.writer;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UblClassifierWriterTest {

  @SuppressWarnings("unchecked")
  @Test
  void routesToCorrectDelegate() throws Exception {
    // Arrange: two concrete writers
    ItemWriter<InvoiceType> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<CreditNoteType> creditWriter = mock(ItemWriter.class);

    // Build the classifier writer just like in your WriterConfig
    ClassifierCompositeItemWriter<Object> classifier = new ClassifierCompositeItemWriter<>();
    classifier.setClassifier(item -> {
      if (item instanceof InvoiceType) return (ItemWriter<Object>)(ItemWriter<?>)invoiceWriter;
      if (item instanceof CreditNoteType) return (ItemWriter<Object>)(ItemWriter<?>)creditWriter;
      throw new IllegalArgumentException("Unsupported: " + item.getClass());
    });

    // Input batch: 2 invoices + 1 credit note
    var inv1 = new InvoiceType();
    var inv2 = new InvoiceType();
    var cn1  = new CreditNoteType();

    // Act
    classifier.write(List.of(inv1, cn1, inv2));

    // Assert: each delegate got only the items of its type
    ArgumentCaptor<List<InvoiceType>> invCap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(2)).write(invCap.capture());
    // Because ClassifierCompositeItemWriter calls delegate per-item, we expect multiple single-item lists
    assertEquals(2, invCap.getAllValues().size());
    assertTrue(invCap.getAllValues().stream().allMatch(l -> l.size() == 1 && l.get(0) instanceof InvoiceType));

    ArgumentCaptor<List<CreditNoteType>> cnCap = ArgumentCaptor.forClass(List.class);
    verify(creditWriter, times(1)).write(cnCap.capture());
    assertEquals(1, cnCap.getAllValues().size());
    assertEquals(1, cnCap.getValue().size());
    assertTrue(cnCap.getValue().get(0) instanceof CreditNoteType);

    verifyNoMoreInteractions(invoiceWriter, creditWriter);
  }
}
```

---

# 3) End-to-end step test (Spring Batch)

This spins up a minimal Spring context and proves that:

* the **processor** converts based on `InvoiceTypeCode`
* the **classifier** routes to the right writer
* both writers get called the expected number of times

We‚Äôll use **stub writers** that just record what they saw.

```java
package com.alphacredit.batch.step;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.*;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.*;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CsvToXmlStepTest.Config.class)
class CsvToXmlStepTest {

  @Autowired JobLauncher launcher;
  @Autowired Job job;
  @Autowired Config.RecordingInvoiceWriter invWriter;
  @Autowired Config.RecordingCreditWriter cnWriter;

  @Test
  void routesInvoicesAndCreditNotes() throws Exception {
    JobExecution exec = launcher.run(job, new JobParameters());
    assertEquals(BatchStatus.COMPLETED, exec.getStatus());

    // We fed 2 invoices + 1 creditnote (see reader below)
    assertEquals(2, invWriter.items.size());
    assertEquals(1, cnWriter.items.size());
  }

  // ---- Test configuration ----
  @Configuration
  @EnableBatchProcessing
  static class Config {

    // Simple reader that returns 3 DTOs: 2 invoices (380) + 1 credit (381)
    @Bean
    ItemReader<CsvInvoiceDto> reader() {
      List<CsvInvoiceDto> list = new ArrayList<>();
      list.add(dto("INV-1", "380"));
      list.add(dto("INV-2", "380"));
      list.add(dto("CN-1",  "381"));
      return new ListItemReader<>(list);
    }

    private static CsvInvoiceDto dto(String id, String typeCode) {
      CsvInvoiceDto d = new CsvInvoiceDto();
      d.setInvoiceNumber(id);
      d.setInvoiceTypeCode(typeCode);
      return d;
    }

    // Mapper stub that makes minimal UBL objects
    @Bean
    CsvInvoiceMapper mapper() {
      return new CsvInvoiceMapper() {
        @Override public InvoiceType toInvoiceType(CsvInvoiceDto src) {
          InvoiceType inv = new InvoiceType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          inv.setID(id);
          return inv;
        }
        @Override public CreditNoteType toCreditNoteType(CsvInvoiceDto src) {
          CreditNoteType cn = new CreditNoteType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          cn.setID(id);
          return cn;
        }
      };
    }

    @Bean CsvToUblProcessor processor(CsvInvoiceMapper mapper) { return new CsvToUblProcessor(mapper); }

    // Recording writers (stand-ins for your XMLInvoiceWriter / XMLCreditNoteWriter)
    @Bean RecordingInvoiceWriter invoiceWriter() { return new RecordingInvoiceWriter(); }
    @Bean RecordingCreditWriter creditWriter()   { return new RecordingCreditWriter(); }

    @Bean
    @SuppressWarnings("unchecked")
    ClassifierCompositeItemWriter<Object> classifierWriter(RecordingInvoiceWriter inv, RecordingCreditWriter cn) {
      ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();
      cw.setClassifier(item -> {
        if (item instanceof InvoiceType)     return (ItemWriter<Object>)(ItemWriter<?>) inv;
        if (item instanceof CreditNoteType)  return (ItemWriter<Object>)(ItemWriter<?>) cn;
        throw new IllegalArgumentException("Unsupported: " + item);
      });
      return cw;
    }

    @Bean
    Job job(JobRepository repo, PlatformTransactionManager tx,
            ItemReader<CsvInvoiceDto> reader,
            CsvToUblProcessor processor,
            ClassifierCompositeItemWriter<Object> writer) {
      Step step = new StepBuilder("csvToXmlStep", repo)
          .<CsvInvoiceDto, Object>chunk(10, tx)
          .reader(reader)
          .processor(processor)
          .writer(writer)
          .build();
      return new JobBuilder("testJob", repo).start(step).build();
    }

    // --- recording writers
    static class RecordingInvoiceWriter implements ItemWriter<InvoiceType> {
      final List<InvoiceType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends InvoiceType> items) { this.items.addAll(items); }
    }
    static class RecordingCreditWriter implements ItemWriter<CreditNoteType> {
      final List<CreditNoteType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends CreditNoteType> items) { this.items.addAll(items); }
    }
  }
}
```

---

## What these tests give you

* ‚úÖ **Processor logic**: confidently flips to `CreditNoteType` when `InvoiceTypeCode == 381`.
* ‚úÖ **Routing**: classifier sends each object to the correct concrete writer.
* ‚úÖ **Step integration**: with a real Batch step, confirms two invoices + one credit note end up in the expected writers.

If you want, I can also add quick tests for your `BucketResolver` on both `InvoiceType` and `CreditNoteType` using your latest implementation, but since you already validated that earlier, these three should cover your CSV‚Üípolymorphic UBL flow end-to-end.
