Perfect üëç ‚Äî let‚Äôs lock this down cleanly and safely without Schematron for now.
Below is a **complete setup** that ensures:

‚úÖ You never lose which XML failed (logs file name on read/write errors).
‚úÖ Reader validates early (no null or malformed XMLs).
‚úÖ Writer logs and skips gracefully when a file can‚Äôt be written.
‚úÖ Batch keeps running instead of dying midway.
‚úÖ 100% ready for you to drop Schematron later.

---

## üß© **1. UblXmlReader.java**

Handles both `Invoice` and `CreditNote` XMLs + validation for empty/malformed files.

```java
package com.alphacredit.batch.reader;

import lombok.extern.slf4j.Slf4j;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemStreamReader;
import org.springframework.batch.item.ResourceAware;
import org.springframework.batch.item.file.ResourceAwareItemReaderItemStream;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamReader;
import java.io.InputStream;

@Slf4j
@Component
public class UblXmlReader implements ResourceAwareItemReaderItemStream<UblItem> {

    private Resource resource;
    private boolean alreadyRead = false;

    @Override
    public void setResource(Resource resource) {
        this.resource = resource;
        this.alreadyRead = false;
        log.debug("Reader set resource: {}", resource.getFilename());
    }

    @Override
    public UblItem read() throws Exception {
        if (resource == null || alreadyRead) return null;
        alreadyRead = true;
        String fileName = resource.getFilename();

        try (InputStream in = resource.getInputStream()) {
            XMLStreamReader xsr = XMLInputFactory.newFactory().createXMLStreamReader(in);
            xsr.nextTag(); // move to root

            String root = xsr.getLocalName();
            log.info("Reading XML file: {}", fileName);

            Object ubl;
            if ("Invoice".equals(root)) {
                ubl = JAXBContext.newInstance(InvoiceType.class)
                        .createUnmarshaller()
                        .unmarshal(xsr, InvoiceType.class)
                        .getValue();
            } else if ("CreditNote".equals(root)) {
                ubl = JAXBContext.newInstance(CreditNoteType.class)
                        .createUnmarshaller()
                        .unmarshal(xsr, CreditNoteType.class)
                        .getValue();
            } else {
                throw new ValidationException("Unsupported root element in " + fileName);
            }

            // Basic validation
            validateUbl(ubl, fileName);

            return new UblItem(ubl, fileName);

        } catch (Exception e) {
            log.error("Failed to read XML file {}: {}", fileName, e.getMessage());
            throw new ValidationException("Error reading " + fileName, e);
        }
    }

    private void validateUbl(Object ubl, String fileName) {
        String id = null;
        if (ubl instanceof InvoiceType inv && inv.getID() != null)
            id = inv.getID().getValue();
        if (ubl instanceof CreditNoteType cn && cn.getID() != null)
            id = cn.getID().getValue();

        if (id == null || id.isBlank()) {
            throw new ValidationException("Missing ID in file: " + fileName);
        }
    }

    @Override public void open(ExecutionContext executionContext) {}
    @Override public void update(ExecutionContext executionContext) {}
    @Override public void close() {}
}
```

---

## üß© **2. UblItem.java**

A simple record (wrapper) carrying both UBL object + original filename.

```java
package com.alphacredit.batch.reader;

public record UblItem(Object ubl, String sourceName) {}
```

---

## üß© **3. ValidationException.java**

For consistent error handling (read/validation issues).

```java
package com.alphacredit.batch.reader;

public class ValidationException extends RuntimeException {
    public ValidationException(String message) { super(message); }
    public ValidationException(String message, Throwable cause) { super(message, cause); }
}
```

---

## üß© **4. SafeUblWriter.java**

Logs the filename on failure and skips bad XMLs gracefully.

```java
package com.alphacredit.batch.writer;

import com.alphacredit.batch.reader.UblItem;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class SafeUblWriter implements ItemWriter<UblItem> {

    private final UblDocumentWriter ublWriter;

    @Value("${work.output}")
    private Path outputDir;

    @Override
    public void write(List<? extends UblItem> items) throws Exception {
        for (UblItem item : items) {
            Object ubl = item.ubl();
            String source = item.sourceName();

            try {
                String id = extractId(ubl);
                if (id == null || id.isBlank()) {
                    id = source != null ? source.replace(".xml", "") : UUID.randomUUID().toString();
                    log.warn("No ID found for {}, using filename fallback '{}'", source, id);
                }

                Files.createDirectories(outputDir);
                Path target = outputDir.resolve(id + ".xml");

                ublWriter.write(ubl, target);
                log.info("Written output: {}", target.getFileName());

            } catch (Exception e) {
                log.error("‚ùå Failed to write XML for file '{}': {}", source, e.getMessage(), e);
                throw new BadXmlException("Write failed for " + source, e);
            }
        }
    }

    private String extractId(Object ubl) {
        if (ubl instanceof InvoiceType inv && inv.getID() != null)
            return inv.getID().getValue();
        if (ubl instanceof CreditNoteType cn && cn.getID() != null)
            return cn.getID().getValue();
        return null;
    }
}
```

---

## üß© **5. BadXmlException.java**

```java
package com.alphacredit.batch.writer;

public class BadXmlException extends RuntimeException {
    public BadXmlException(String message, Throwable cause) { super(message, cause); }
}
```

---

## üß© **6. SkipLoggingListener.java**

Central place for clean skip logs (file name + reason).

```java
package com.alphacredit.batch.config;

import com.alphacredit.batch.reader.UblItem;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.SkipListener;

@Slf4j
public class SkipLoggingListener implements SkipListener<UblItem, UblItem> {

    @Override
    public void onSkipInRead(Throwable t) {
        log.warn("‚ö†Ô∏è Skipped file during read: {}", t.getMessage());
    }

    @Override
    public void onSkipInProcess(UblItem item, Throwable t) {
        log.warn("‚ö†Ô∏è Skipped processing {}: {}", item.sourceName(), t.getMessage());
    }

    @Override
    public void onSkipInWrite(UblItem item, Throwable t) {
        log.warn("‚ö†Ô∏è Skipped writing {}: {}", item.sourceName(), t.getMessage());
    }
}
```

---

## üß© **7. Step Configuration**

```java
@Bean
public Step xmlInvoiceStep(JobRepository repo,
                           PlatformTransactionManager tx,
                           UblXmlReader reader,
                           SafeUblWriter writer) {

    return new StepBuilder("xmlInvoiceStep", repo)
        .<UblItem, UblItem>chunk(10, tx)
        .reader(reader)
        .writer(writer)
        .faultTolerant()
        .skipPolicy((t, skipCount) ->
            t instanceof BadXmlException ||
            t instanceof ValidationException ||
            (t.getCause() != null && (
                t.getCause() instanceof BadXmlException ||
                t.getCause() instanceof ValidationException)))
        .listener(new SkipLoggingListener())
        .build();
}
```

---

## ‚úÖ **What you get now**

| Situation            | Result                                |
| -------------------- | ------------------------------------- |
| Empty or invalid XML | Logged with filename, skipped safely  |
| Missing ID           | Warned + uses filename fallback       |
| Writer failure       | Logs exact filename, batch continues  |
| Everything else      | Continues normally, 0 silent failures |

---

### üß† Example log output

```
INFO  Reading XML file: invoice123.xml
WARN  No ID found for invoice123.xml, using filename fallback 'invoice123'
INFO  Written output: invoice123.xml
ERROR ‚ùå Failed to write XML for file 'creditnote_998.xml': unexpected element 'TaxTotal'
WARN  ‚ö†Ô∏è Skipped writing creditnote_998.xml: Write failed for creditnote_998.xml
```

---

‚úÖ You can drop this in right away ‚Äî no changes to your step logic needed.
Later, if you reintroduce Schematron, you can just inject it back into `SafeUblWriter` ‚Äî everything else stays the same.

---

Would you like me to show you how to make the **output directory + chunk size configurable** per job (via job parameters) next? That‚Äôs super useful for multi-file runs.




Perfect ‚Äî this is a very common (and smart) question for UBL / Spring Batch pipelines üëç

You‚Äôre basically saying:

> ‚ÄúSome XMLs are blank or malformed (e.g. empty root or invalid schema).
> When unmarshalling or writing, the batch step fails with a cryptic stacktrace.
> I want the batch to **skip those files gracefully** and **log which XML caused it.**‚Äù

Let‚Äôs fix that cleanly ‚Äî without losing visibility.

---

## ‚úÖ Step 1: Wrap your reader in a fail-safe

Your current `UblXmlReader` may throw exceptions like `JAXBException` or `XMLStreamException` when parsing empty/malformed XMLs.
Instead of letting them crash the step, you can **catch + rethrow as a custom checked exception** that includes the file name.

```java
@Override
public Object read() throws Exception {
    log.info("UblXmlReader.read started for {}", resource);
    if (resource == null || alreadyRead) return null;

    try (InputStream in = resource.getInputStream()) {
        alreadyRead = true;
        XMLStreamReader xsr = XMLInputFactory.newFactory().createXMLStreamReader(in);
        xsr.nextTag(); // may fail on empty XML
        String root = xsr.getLocalName();

        if ("Invoice".equals(root)) {
            JAXBContext ctx = JAXBContext.newInstance(InvoiceType.class);
            return ctx.createUnmarshaller().unmarshal(xsr, InvoiceType.class).getValue();
        } else if ("CreditNote".equals(root)) {
            JAXBContext ctx = JAXBContext.newInstance(CreditNoteType.class);
            return ctx.createUnmarshaller().unmarshal(xsr, CreditNoteType.class).getValue();
        } else {
            throw new BadXmlException("Unsupported or empty root element", resource.getFilename());
        }
    } catch (Exception e) {
        throw new BadXmlException("Failed to parse XML: " + resource.getFilename(), e);
    }
}
```

and define:

```java
public class BadXmlException extends Exception {
    public BadXmlException(String message, String fileName) {
        super(message + " [file=" + fileName + "]");
    }
    public BadXmlException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

This ensures the exception message *always includes the filename*.

---

## ‚úÖ Step 2: Add a SkipPolicy

In your step definition:

```java
@Bean
public Step xmlInvoiceStep(JobRepository repo,
                           PlatformTransactionManager tx,
                           UblXmlReader reader,
                           ClassifierCompositeItemWriter<Object> writer) {

    return new StepBuilder("xmlInvoiceStep", repo)
        .<Object, Object>chunk(10, tx)
        .reader(reader)
        .writer(writer)
        .faultTolerant()
        .skipPolicy(new BadXmlSkipPolicy())
        .listener(new SkipLoggingListener())
        .build();
}
```

The skip policy decides which exceptions are skippable:

```java
public class BadXmlSkipPolicy implements SkipPolicy {
    @Override
    public boolean shouldSkip(Throwable t, long skipCount) {
        return t instanceof BadXmlException
            || t.getCause() instanceof BadXmlException
            || t instanceof JAXBException;
    }
}
```

---

## ‚úÖ Step 3: Add a SkipListener for visibility

```java
@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object> {
    @Override
    public void onSkipInRead(Throwable t) {
        log.warn("Skipped XML during read: {}", t.getMessage());
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        log.warn("Skipped XML during process: {} - {}", item, t.getMessage());
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        log.warn("Skipped XML during write: {} - {}", item, t.getMessage());
    }
}
```

Now your logs will say, for example:

```
WARN  Skipped XML during read: Failed to parse XML: invoice-003.xml
```

‚Ä¶and the batch will continue to process the next file instead of failing.

---

## ‚úÖ Step 4: Optional ‚Äî write bad XMLs to a quarantine folder

If you want to keep them for debugging:

```java
catch (Exception e) {
    Files.copy(resource.getFile().toPath(), 
               Paths.get("/tmp/quarantine/" + resource.getFilename()),
               StandardCopyOption.REPLACE_EXISTING);
    throw new BadXmlException("Failed to parse XML: " + resource.getFilename(), e);
}
```

---

## üöÄ Result

* Bad XMLs are **skipped safely**.
* Logs tell you **exactly which file** caused the issue.
* Job doesn‚Äôt stop processing good XMLs.
* You can optionally keep failed ones for later inspection.

---

üëâ Do you want me to also make this ‚Äúquarantine‚Äù behavior configurable (e.g. enable/disable via `application.properties`)? That‚Äôs handy in production.



Perfect üëç ‚Äî I see your CosProcessedCleanupListener implementation. You want to add JUnit coverage for it. Let‚Äôs do that.

‚∏ª

‚úÖ What we‚Äôll test
	1.	When job COMPLETED ‚Üí it should call cos.listKeys() and cos.deleteFile() for each key.
	2.	When job FAILED ‚Üí it should not call cos.deleteFile() (files stay in processed/).

‚∏ª

‚úÖ Example JUnit 5 Test (with Mockito)

package com.example.batch;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;

import java.util.List;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CosProcessedCleanupListenerTest {

    @Mock
    private CosStorageService cos;

    private CosProcessedCleanupListener listener;

    @BeforeEach
    void setUp() {
        listener = new CosProcessedCleanupListener(cos, "processed/");
    }

    @Test
    void deletesProcessedFiles_whenJobCompleted() {
        // Arrange
        JobExecution jobExecution = new JobExecution(1L);
        jobExecution.setStatus(BatchStatus.COMPLETED);

        when(cos.listKeys("processed/")).thenReturn(List.of("processed/file1", "processed/file2"));

        // Act
        listener.afterJob(jobExecution);

        // Assert
        verify(cos).listKeys("processed/");
        verify(cos).deleteFile("processed/file1");
        verify(cos).deleteFile("processed/file2");
        verifyNoMoreInteractions(cos);
    }

    @Test
    void keepsFiles_whenJobFailed() {
        // Arrange
        JobExecution jobExecution = new JobExecution(2L);
        jobExecution.setStatus(BatchStatus.FAILED);

        // Act
        listener.afterJob(jobExecution);

        // Assert
        verifyNoInteractions(cos);
    }
}


‚∏ª

‚úÖ Notes
	‚Ä¢	Uses Mockito to fake the CosStorageService.
	‚Ä¢	Confirms the listener behaves differently depending on BatchStatus.
	‚Ä¢	Keeps tests clean by injecting "processed/" directly into the constructor.

‚∏ª

üëâ Do you also want me to show you how to make this test Spring Boot style (loading the bean from context with @SpringBatchTest), or keep it lean like this with just Mockito?


Thanks for sharing the screenshot üôå ‚Äî I see your current `XmlInvoiceReader` is:

* `implements ResourceAwareItemReaderItemStream<InvoiceType>`
* Hard-wired to **InvoiceType only**
* Always unmarshals into `InvoiceType` via `JAXBElement<InvoiceType>`

That‚Äôs why you can‚Äôt reuse it for credit notes ‚Äî it assumes the XML root is `<Invoice>`.

---

### ‚úÖ How to evolve this reader

Since UBL XMLs can be `<Invoice>` **or** `<CreditNote>`, you can generalize your reader:

1. **Return `Object`** (instead of `InvoiceType` only).
2. Peek at the XML root element first.
3. Choose the right JAXB context (`InvoiceType.class` or `CreditNoteType.class`).
4. Unmarshal accordingly.

---

### üîÑ Refactored Reader

```java
@Component
@Slf4j
@StepScope
public class UblXmlReader implements ResourceAwareItemReaderItemStream<Object> {

    private Resource resource;
    private boolean alreadyRead = false;

    @Override
    public void setResource(Resource resource) {
        log.debug("UblXmlReader.setResource started: {}", resource);
        this.resource = resource;
        this.alreadyRead = false;
        log.debug("UblXmlReader.setResource completed");
    }

    @Override
    public Object read() throws Exception {
        log.info("UblXmlReader.read started");
        if (resource == null || alreadyRead) {
            return null;
        }

        try (InputStream in = resource.getInputStream()) {
            alreadyRead = true;

            XMLStreamReader xsr = XMLInputFactory.newFactory().createXMLStreamReader(in);
            xsr.nextTag(); // advance to root element
            String root = xsr.getLocalName();
            log.debug("Root element detected: {}", root);

            if ("Invoice".equals(root)) {
                JAXBContext ctx = JAXBContext.newInstance(
                        oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class);
                return ctx.createUnmarshaller()
                          .unmarshal(resource.getFile(), 
                                     oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class)
                          .getValue();
            } else if ("CreditNote".equals(root)) {
                JAXBContext ctx = JAXBContext.newInstance(
                        oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class);
                return ctx.createUnmarshaller()
                          .unmarshal(resource.getFile(), 
                                     oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class)
                          .getValue();
            } else {
                throw new IllegalArgumentException("Unsupported UBL root element: " + root);
            }
        }
    }

    @Override
    public void open(ExecutionContext executionContext) { }
    @Override
    public void update(ExecutionContext executionContext) { }
    @Override
    public void close() { }
}
```

---

### ‚úÖ Why this works

* Handles **both Invoices and Credit Notes** in one place.
* Returns `Object` ‚Üí later routed to the correct writer by your `ClassifierCompositeItemWriter`.
* Still supports Spring Batch `MultiResourceItemReader` (since it implements `ResourceAwareItemReaderItemStream`).

---

üëâ Do you want me to also show you the **JUnit test** for this reader that feeds it an `Invoice.xml` and `CreditNote.xml` and asserts the correct object type comes out? That will give you confidence before wiring into the step.


Awesome üéâ ‚Äî that‚Äôs the cleanest setup:

* **One reader** that looks at the XML root and unmarshals into either `InvoiceType` or `CreditNoteType`.
* **One step**, with a `ClassifierCompositeItemWriter<Object>` to delegate to your `XMLInvoiceWriter` and `XMLCreditNoteWriter`.

---

## ‚úÖ Reader (polymorphic)

```java
@Component
@StepScope
public class UblXmlReader implements ItemReader<Object> {

    private final Iterator<Resource> files;

    public UblXmlReader(@Value("#{jobParameters['inputFiles']}") List<Resource> resources) {
        this.files = resources.iterator();
    }

    @Override
    public Object read() throws Exception {
        if (!files.hasNext()) return null;

        Resource res = files.next();

        try (InputStream in = res.getInputStream()) {
            XMLStreamReader xsr = XMLInputFactory.newFactory().createXMLStreamReader(in);
            xsr.nextTag(); // advance to root element
            String root = xsr.getLocalName();

            if ("Invoice".equals(root)) {
                JAXBContext ctx = JAXBContext.newInstance(
                        oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class);
                return ctx.createUnmarshaller().unmarshal(res.getFile(), 
                        oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class).getValue();
            } else if ("CreditNote".equals(root)) {
                JAXBContext ctx = JAXBContext.newInstance(
                        oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class);
                return ctx.createUnmarshaller().unmarshal(res.getFile(), 
                        oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class).getValue();
            } else {
                throw new IllegalArgumentException("Unsupported UBL root element: " + root);
            }
        }
    }
}
```

---

## ‚úÖ Writer (classifier)

```java
@Configuration
public class WriterConfig {

    @Bean
    @StepScope
    @SuppressWarnings("unchecked")
    public ClassifierCompositeItemWriter<Object> ublClassifierWriter(
            XMLInvoiceWriter invoiceWriter,
            XMLCreditNoteWriter creditNoteWriter) {

        ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();

        cw.setClassifier(item -> {
            if (item instanceof oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType) {
                return (ItemWriter<Object>) (ItemWriter<?>) invoiceWriter;
            } else if (item instanceof oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType) {
                return (ItemWriter<Object>) (ItemWriter<?>) creditNoteWriter;
            } else {
                throw new IllegalArgumentException("Unsupported type: " + item.getClass());
            }
        });

        return cw;
    }
}
```

---

## ‚úÖ Step wiring

```java
@Bean
public Step xmlInvoiceStep(JobRepository repo,
                           PlatformTransactionManager tx,
                           UblXmlReader reader,
                           ClassifierCompositeItemWriter<Object> writer) {

    return new StepBuilder("xmlInvoiceStep", repo)
            .<Object, Object>chunk(10, tx)
            .reader(reader)
            .writer(writer)
            .build();
}
```

---

### üöÄ Flow

1. Reader peeks at XML root ‚Üí produces `InvoiceType` or `CreditNoteType`.
2. Classifier writer checks instance type ‚Üí routes to correct concrete writer.
3. You keep **specialized writer logic** (file naming, grouping, etc.) but have **only one step** to maintain.

---

üëâ Do you want me to also give you a **JUnit test** that feeds two XML files (one invoice, one credit note) into this step and proves they get routed to the right writer?

Perfect üëç now you‚Äôve got your `/processed` directory populated with the actual files you moved in there (inputs after fetch, outputs after upload).

To delete them only **if the batch job completed successfully**, the cleanest way is to use a **JobExecutionListener** that fires after the job ends:

---

## ‚úÖ Listener-based cleanup

```java
@Component
@RequiredArgsConstructor
public class CosProcessedCleanupListener implements JobExecutionListener {

    private final CosStorageService cos;

    @Value("${cos.bucket}")
    private String bucket;

    @Value("${cos.processed-prefix:processed/}")
    private String processedPrefix;

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            // list all objects under processed/ and delete
            List<String> keys = cos.listKeys(bucket, processedPrefix);
            keys.forEach(k -> cos.deleteObject(bucket, k));
        } else {
            // optional: leave processed/ intact for debugging
            log.warn("Job failed, keeping files in {}/{}", bucket, processedPrefix);
        }
    }
}
```

---

## ‚úÖ Service methods in your `CosStorageService`

```java
public List<String> listKeys(String bucket, String prefix) {
    List<String> keys = new ArrayList<>();
    ObjectListing listing = s3Client.listObjects(bucket, prefix);
    while (true) {
        for (S3ObjectSummary s : listing.getObjectSummaries()) {
            keys.add(s.getKey());
        }
        if (listing.isTruncated()) {
            listing = s3Client.listNextBatchOfObjects(listing);
        } else break;
    }
    return keys;
}

public void deleteObject(String bucket, String key) {
    s3Client.deleteObject(bucket, key);
}
```

---

## ‚úÖ Wiring it into your job

In your job config:

```java
@Bean
public Job invoiceJob(JobRepository repo, PlatformTransactionManager tx,
                      Step fetchStep, Step processStep, Step uploadStep,
                      CosProcessedCleanupListener cleanupListener) {
    return new JobBuilder("invoiceJob", repo)
        .listener(cleanupListener)  // attach listener here
        .start(fetchStep)
        .next(processStep)
        .next(uploadStep)
        .build();
}
```

---

### üîë Advantages

* Deletes only if the job `COMPLETED`.
* Leaves files if the job `FAILED` (so you can debug).
* No need to pass filenames around in execution context ‚Äî it just wipes the whole `processed/` prefix when successful.

---

üëâ Do you want me to adapt this so it **only deletes the specific keys your tasklets recorded in ExecutionContext** (instead of scanning all of `processed/`)? That‚Äôs safer if multiple jobs run in parallel.




You‚Äôre right ‚Äî those assertions only pass if your classes implement **value-based equality**.
Right now `SupplierEntity` and `CosConfig` only have `@Getter/@Setter`, so they inherit `Object.equals/hashCode` (identity). Two different instances ‚Üí **not equal**, and hash codes usually differ.

Below are two ways forward. I‚Äôll default to **fixing the tests** to match current code (identity semantics). If you want value-based equality instead, I‚Äôve added the exact Lombok changes + matching tests too.

---

# A) Keep current code (identity equality) ‚Äî ‚úÖ revised tests

## `SupplierEntityTest.java`

```java
package com.bnpp.pf.einvoice.connect.batch.entity;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class SupplierEntityTest {

    @Test
    void gettersAndSettersWork() {
        SupplierEntity s = new SupplierEntity();
        s.setId(1L);
        s.setEnterpriseNumber("ENT-123");
        s.setCompanyName("Alpha Ltd");

        assertThat(s.getId()).isEqualTo(1L);
        assertThat(s.getEnterpriseNumber()).isEqualTo("ENT-123");
        assertThat(s.getCompanyName()).isEqualTo("Alpha Ltd");
    }

    @Test
    void equalsIsIdentity_basedOnObjectImplementation() {
        SupplierEntity s1 = new SupplierEntity();
        s1.setEnterpriseNumber("ENT-123");

        SupplierEntity s2 = new SupplierEntity();
        s2.setEnterpriseNumber("ENT-123");

        // identity semantics
        assertThat(s1).isNotEqualTo(s2);
        assertThat(s1).isEqualTo(s1);
        assertThat(s1).isNotEqualTo(null);
    }

    @Test
    void toStringContainsFields() {
        SupplierEntity s = new SupplierEntity();
        s.setEnterpriseNumber("E-5");
        s.setCompanyName("Zeta Ltd");
        assertThat(s.toString()).contains("E-5").contains("Zeta Ltd");
    }
}
```

## `CosConfigTest.java`

```java
package com.bnpp.pf.einvoice.connect.cos.config;

import org.junit.jupiter.api.Test;
import org.springframework.test.util.ReflectionTestUtils;

import static org.assertj.core.api.Assertions.assertThat;

class CosConfigTest {

    @Test
    void gettersAndSettersWork() {
        CosConfig c = new CosConfig();
        c.setInstance("dev-instance");
        c.setTimeOut(30);
        assertThat(c.getInstance()).isEqualTo("dev-instance");
        assertThat(c.getTimeOut()).isEqualTo(30);
    }

    @Test
    void complexFieldsViaReflection() {
        CosConfig c = new CosConfig();
        Object bucket = new Object(); // replace with real Bucket if available
        Object iam = new Object();    // replace with real Iam if available
        ReflectionTestUtils.setField(c, "bucket", bucket);
        ReflectionTestUtils.setField(c, "iam", iam);
        assertThat(c.getBucket()).isSameAs(bucket);
        assertThat(c.getIam()).isSameAs(iam);
    }

    @Test
    void equalsIsIdentity_andToStringHasUsefulInfo() {
        CosConfig c1 = new CosConfig();
        c1.setInstance("A"); c1.setTimeOut(5);

        CosConfig c2 = new CosConfig();
        c2.setInstance("A"); c2.setTimeOut(5);

        // object identity semantics
        assertThat(c1).isNotEqualTo(c2);
        assertThat(c1).isEqualTo(c1);
        assertThat(c1.toString()).contains("A");
    }
}
```

These tests won‚Äôt assert hash equality/inequality (since `Object.hashCode()` is identity-based and not something we should rely on deterministically across JVMs). They still give you coverage for the class behavior you actually have.

---

# B) If you **want value-based equality** (optional) ‚Äî change Lombok + tests

## Production changes

### For JPA entities (recommended pattern)

Use a stable, unique business key (you already have `enterprise_number UNIQUE`), not the generated `id`:

```java
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "suppliers")
@Getter @Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class SupplierEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @EqualsAndHashCode.Include
    @Column(name = "enterprise_number", nullable = false, unique = true)
    private String enterpriseNumber;

    @Column(name = "company_name")
    private String companyName;
}
```

### For `CosConfig`

If you want simple value equality over its fields:

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "cos")
@Data // generates getters, setters, equals, hashCode, toString
public class CosConfig {
    private String instance;
    private Bucket bucket;
    private Iam iam;
    private int timeOut;
}
```

## Matching tests (when value-based equality is enabled)

```java
// SupplierEntity equality by enterpriseNumber
@Test
void supplierEqualityByBusinessKey() {
    SupplierEntity a = new SupplierEntity(); a.setEnterpriseNumber("ENT-123");
    SupplierEntity b = new SupplierEntity(); b.setEnterpriseNumber("ENT-123");
    assertThat(a).isEqualTo(b);
    assertThat(a.hashCode()).isEqualTo(b.hashCode());
}

// CosConfig value-based equality
@Test
void cosConfigValueEquality() {
    CosConfig c1 = new CosConfig(); c1.setInstance("A"); c1.setTimeOut(5);
    CosConfig c2 = new CosConfig(); c2.setInstance("A"); c2.setTimeOut(5);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
}
```

---

## Which should you pick?

* If you don‚Äôt want to modify production code right now, **use option A** (updated tests).
* If equality by content is desired (often useful for DTO/configs; for JPA be careful), **use option B**, with the JPA-friendly `@EqualsAndHashCode` approach on `SupplierEntity`.

If you tell me which route you prefer, I can adjust the rest of your suite in the same style.

```

These tests won‚Äôt assert hash equality/inequality (since `Object.hashCode()` is identity-based and not something we should rely on deterministically across JVMs). They still give you coverage for the class behavior you actually have.

---

# B) If you **want value-based equality** (optional) ‚Äî change Lombok + tests

## Production changes

### For JPA entities (recommended pattern)

Use a stable, unique business key (you already have `enterprise_number UNIQUE`), not the generated `id`:

```java
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "suppliers")
@Getter @Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class SupplierEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @EqualsAndHashCode.Include
    @Column(name = "enterprise_number", nullable = false, unique = true)
    private String enterpriseNumber;

    @Column(name = "company_name")
    private String companyName;
}
```

### For `CosConfig`

If you want simple value equality over its fields:

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "cos")
@Data // generates getters, setters, equals, hashCode, toString
public class CosConfig {
    private String instance;
    private Bucket bucket;
    private Iam iam;
    private int timeOut;
}
```

## Matching tests (when value-based equality is enabled)

```java
// SupplierEntity equality by enterpriseNumber
@Test
void supplierEqualityByBusinessKey() {
    SupplierEntity a = new SupplierEntity(); a.setEnterpriseNumber("ENT-123");
    SupplierEntity b = new SupplierEntity(); b.setEnterpriseNumber("ENT-123");
    assertThat(a).isEqualTo(b);
    assertThat(a.hashCode()).isEqualTo(b.hashCode());
}

// CosConfig value-based equality
@Test
void cosConfigValueEquality() {
    CosConfig c1 = new CosConfig(); c1.setInstance("A"); c1.setTimeOut(5);
    CosConfig c2 = new CosConfig(); c2.setInstance("A"); c2.setTimeOut(5);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
}
```

---

## Which should you pick?

* If you don‚Äôt want to modify production code right now, **use option A** (updated tests).
* If equality by content is desired (often useful for DTO/configs; for JPA be careful), **use option B**, with the JPA-friendly `@EqualsAndHashCode` approach on `SupplierEntity`.

If you tell me which route you prefer, I can adjust the rest of your suite in the same style.

```

---

### ‚úÖ What this covers

* **SupplierEntity**: all Lombok-generated getters/setters, `equals`, `hashCode`, `toString`.
* **CosConfig**: getters/setters, reflection injection for `bucket` + `iam`, equality/hashCode/toString.

---

üëâ Do you also want me to add **negative tests** (e.g. `equals` with different values, `null` checks) to hit more branches in Lombok-generated methods?
