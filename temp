great—thanks for the code shots. here are ready-to-drop JUnit 5 tests for the three classes you shared. they avoid MapStruct/JAXB complexity by using Mockito and Spring Batch primitives, but still exercise real behavior/branches.

⸻

1) CsvFilePresenceDeciderTest

Covers: hasCsv=true → CONTINUE, false/null → SKIP.

package com.bnpp.pf.einvoice.connect.batch.csv;

import org.junit.jupiter.api.Test;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;

import static org.assertj.core.api.Assertions.assertThat;

class CsvFilePresenceDeciderTest {

  private final CsvFilePresenceDecider decider = new CsvFilePresenceDecider();

  private StepExecution newStepExecution() {
    JobExecution jobExecution = new JobExecution(1L);
    return new StepExecution("testStep", jobExecution);
  }

  @Test
  void decide_returnsContinue_whenHasCsvTrue() {
    StepExecution step = newStepExecution();
    step.getJobExecution().getExecutionContext().put("hasCsv", Boolean.TRUE);

    FlowExecutionStatus status = decider.decide(step.getJobExecution(), step);
    assertThat(status.getName()).isEqualTo("CONTINUE");
  }

  @Test
  void decide_returnsSkip_whenHasCsvFalse() {
    StepExecution step = newStepExecution();
    step.getJobExecution().getExecutionContext().put("hasCsv", Boolean.FALSE);

    FlowExecutionStatus status = decider.decide(step.getJobExecution(), step);
    assertThat(status.getName()).isEqualTo("SKIP");
  }

  @Test
  void decide_returnsSkip_whenHasCsvMissing() {
    StepExecution step = newStepExecution(); // no key in EC

    FlowExecutionStatus status = decider.decide(step.getJobExecution(), step);
    assertThat(status.getName()).isEqualTo("SKIP");
  }
}


⸻

2) CsvInvoiceProcessorTest

Covers:
	•	beforeStep (reset path) and afterStep (COMPLETED).
	•	Branching: "381" → credit note, anything else → invoice.
	•	Verifies the correct mapper method is invoked.

package com.bnpp.pf.einvoice.connect.batch.csv;

import com.bnpp.pf.einvoice.connect.batch.csv.dto.CsvInvoiceDto;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

class CsvInvoiceProcessorTest {

  @Test
  void beforeAndAfterStep_areSafe() {
    CsvInvoiceMapper mapper = mock(CsvInvoiceMapper.class);
    CsvInvoiceProcessor processor = new CsvInvoiceProcessor(mapper);

    StepExecution step = new StepExecution("s", new JobExecution(1L));
    processor.beforeStep(step);
    assertThat(processor.afterStep(step)).isEqualTo(ExitStatus.COMPLETED);
  }

  @Test
  void process_routesToInvoice_whenTypeIsNot381() throws Exception {
    CsvInvoiceMapper mapper = mock(CsvInvoiceMapper.class);
    CsvInvoiceProcessor processor = new CsvInvoiceProcessor(mapper);

    CsvInvoiceDto dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380"); // ordinary invoice

    InvoiceType expected = new InvoiceType();
    when(mapper.toInvoiceType(ArgumentMatchers.same(dto))).thenReturn(expected);

    Object result = processor.process(dto);

    assertThat(result).isSameAs(expected);
    verify(mapper, times(1)).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }

  @Test
  void process_routesToCreditNote_whenTypeIs381() throws Exception {
    CsvInvoiceMapper mapper = mock(CsvInvoiceMapper.class);
    CsvInvoiceProcessor processor = new CsvInvoiceProcessor(mapper);

    CsvInvoiceDto dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381"); // credit note

    CreditNoteType expected = new CreditNoteType();
    when(mapper.toCreditNoteType(ArgumentMatchers.same(dto))).thenReturn(expected);

    Object result = processor.process(dto);

    assertThat(result).isSameAs(expected);
    verify(mapper, times(1)).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void process_defaultsToInvoice_whenTypeNull() throws Exception {
    CsvInvoiceMapper mapper = mock(CsvInvoiceMapper.class);
    CsvInvoiceProcessor processor = new CsvInvoiceProcessor(mapper);

    CsvInvoiceDto dto = new CsvInvoiceDto(); // invoiceTypeCode null
    when(mapper.toInvoiceType(dto)).thenReturn(new InvoiceType());

    Object result = processor.process(dto);

    assertThat(result).isInstanceOf(InvoiceType.class);
    verify(mapper).toInvoiceType(dto);
  }
}


⸻

3) CsvXmlWriterConfigTest

Covers:
	•	Delegation to invoice writer when item is InvoiceType.
	•	Delegation to credit note writer when item is CreditNoteType.
	•	Unsupported type throws IllegalArgumentException.

package com.bnpp.pf.einvoice.connect.batch.csv;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.*;

class CsvXmlWriterConfigTest {

  @SuppressWarnings("unchecked")
  @Test
  void classifierDelegatesToInvoiceWriter() throws Exception {
    var config = new CsvXmlWriterConfig();

    ItemWriter<Object> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<Object> creditWriter  = mock(ItemWriter.class);

    var cw = config.ublClassifierWriter(invoiceWriter, creditWriter);

    InvoiceType invoice = new InvoiceType();
    cw.write(List.of(invoice));

    @SuppressWarnings("unchecked")
    ArgumentCaptor<List<Object>> cap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(1)).write(cap.capture());
    verify(creditWriter, never()).write(any());

    // ensure the same item reached the delegate
    assertThat(cap.getValue()).containsExactly(invoice);
  }

  @SuppressWarnings("unchecked")
  @Test
  void classifierDelegatesToCreditNoteWriter() throws Exception {
    var config = new CsvXmlWriterConfig();

    ItemWriter<Object> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<Object> creditWriter  = mock(ItemWriter.class);

    var cw = config.ublClassifierWriter(invoiceWriter, creditWriter);

    CreditNoteType credit = new CreditNoteType();
    cw.write(List.of(credit));

    verify(creditWriter, times(1)).write(any());
    verify(invoiceWriter, never()).write(any());
  }

  @Test
  void classifierThrowsForUnsupportedType() {
    var config = new CsvXmlWriterConfig();
    @SuppressWarnings("unchecked")
    ItemWriter<Object> invoiceWriter = mock(ItemWriter.class);
    @SuppressWarnings("unchecked")
    ItemWriter<Object> creditWriter  = mock(ItemWriter.class);

    var cw = config.ublClassifierWriter(invoiceWriter, creditWriter);

    assertThatThrownBy(() -> cw.write(List.of("not-a-ubl-type")))
        .isInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Unsupported type:");
  }
}


⸻

notes / tweaks
	•	Package names match your screenshots: com.bnpp.pf.einvoice.connect.batch.csv. Adjust if needed.
	•	These tests use only JUnit 5, Mockito, and Spring Batch core; no Spring context is required (fast!).
	•	If your CsvInvoiceMapper is in a different package, update imports. We’re mocking it, so no MapStruct impl is required at test time.
	•	If your build enforces strict generics, change ItemWriter<Object> mocks to the concrete types your bean method accepts (e.g., XmlInvoiceWriter, XmlCreditNoteWriter) but they still implement ItemWriter<?>, so Mockito works either way.

Drop these in and re-run tests—csv should jump to high 80s/90s coverage, and those previously 0% classes will be green. Want the next batch (PDF writer/reader or scheduler)?
