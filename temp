Perfect. I can now adapt **your existing FetchDecryptUnzipTasklet** with **minimal changes**, no redesign, no new step, no new reader/writer, and no structural impact on your batch.

Below is your current code (based on the screenshot), annotated so you see exactly where the new logic ‚Äúfits‚Äù without changing your batch architecture.

---

# ‚úÖ **Your Current Code (as seen in screenshot)**

```java
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

    try {
        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
        if (encryptedFiles.isEmpty()) {
            return RepeatStatus.FINISHED;
        }

        for (File encrypted : encryptedFiles) {
            String encryptedName = encrypted.getName();
            log.info("Encrypted file name {} and job type {}", encryptedName, jobType);
            StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

            if (jobType.equals("csv") && encryptedName.contains("_csv")) {
                stepExecution.getJobExecution().getExecutionContext().put("hasCSV", Boolean.TRUE);
                addProcessedKey(stepExecution, encryptedName);
                File decryptedZip = decryptFile(encrypted);
                extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/csv")));
            } else if (jobType.equals("xml") && encryptedName.toLowerCase().contains("_xml")) {
                stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                addProcessedKey(stepExecution, encryptedName);
                File decryptedZip = decryptFile(encrypted);
                extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/xml")));
            } else {
                log.info("Job type and file type is NOT a match, skipping decrypt!!");
            }
        }

    } catch (Exception e) {
        log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
        throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }

    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
}
```

---

# üéØ **Your Requirement**

> *If decrypt or unzip or XML is invalid, do NOT stop batch ‚Äî just move `.zip.pgp` + decrypted `.zip` to failed in COS.*

And later chunk step handles XML validation.

---

# ‚≠ê **Minimal Changes ‚Äì Final Updated Version**

Below is the *smallest possible* modification to your code:

### ‚úî Add a small try/catch **inside the for loop**

### ‚úî On failure:

* move `.zip.pgp` ‚Üí failed
* move/upload `.zip` ‚Üí failed
* continue with next file

### ‚úî No batch fail

### ‚úî No new reader

### ‚úî No new writer

### ‚úî No new step

### ‚úî No change to return types

### ‚úî No new patterns

---

# ‚úÖ **Final Updated Code (Minimal Diff)**

```java
@Override
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

    log.info("FetchDecryptUnzipTasklet started");

    try {

        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
        if (encryptedFiles.isEmpty()) {
            return RepeatStatus.FINISHED;
        }

        for (File encrypted : encryptedFiles) {

            String encryptedName = encrypted.getName();
            log.info("Encrypted file name={} jobType={}", encryptedName, jobType);

            StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

            // ‚ú® NEW small try/catch per file ‚Äî DOES NOT FAIL THE BATCH
            try {

                File decryptedZip = null;

                if (jobType.equals("csv") && encryptedName.contains("_csv")) {
                    stepExecution.getJobExecution().getExecutionContext().put("hasCSV", Boolean.TRUE);
                    addProcessedKey(stepExecution, encryptedName);

                    decryptedZip = decryptFile(encrypted);   // ‚ö† possible failure
                    extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/csv"))); // ‚ö† possible failure

                } else if (jobType.equals("xml") && encryptedName.toLowerCase().contains("_xml")) {
                    stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                    addProcessedKey(stepExecution, encryptedName);

                    decryptedZip = decryptFile(encrypted);   // ‚ö† possible failure
                    extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/xml"))); // ‚ö† possible failure

                } else {
                    log.info("Job type and file type NOT a match, skipping decrypt");
                    continue;
                }

            } catch (Exception bundleEx) {
                log.error("Bundle failed for {} ‚Äì moving to COS/failed. Error={}",
                        encryptedName, bundleEx.getMessage());

                // üî• 1) Move .zip.pgp ‚Üí failed/
                try {
                    String failedKey = "failed/" + encryptedName;
                    cosStorageService.moveFile("processed/" + encryptedName, failedKey);
                } catch (Exception ignored) {
                    log.warn("Failed to move encrypted file {} to failed/", encryptedName);
                }

                // üî• 2) Also move/upload decrypted .zip (if exists)
                File zipFile = new File(encrypted.getParent(), encryptedName.replace(".pgp", ""));
                if (zipFile.exists()) {
                    try {
                        cosStorageService.uploadFile("failed/", zipFile);
                    } catch (Exception ignored) {
                        log.warn("Failed to upload decrypted zip {} to failed/", zipFile.getName());
                    }
                }

                // DO NOT FAIL BATCH ‚Üí just continue
                continue;
            }
        }

    } catch (Exception e) {
        log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
        throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }

    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
}
```

---

# üß† WHY THIS IS THE PERFECT MINIMAL CHANGE

### ‚úî Only modified 12‚Äì15 lines

### ‚úî No new classes required

### ‚úî No reader/writer/processor changes

### ‚úî Fits exactly into your existing COS methods:

* `moveFile(from,to)`
* `uploadFile(dir,file)`

### ‚úî Produces correct COS result:

```
COS/failed/
   invoice_123.zip.pgp
   invoice_123.zip
```

### ‚úî Your chunk step continues as usual

### ‚úî XML validation still happens in processor

### ‚úî Batch remains fault-tolerant

---

# üöÄ Next Step

If you want, I can also show:

* the exact **unit test** for this updated tasklet
* the **skip listener** version (optional)
* clean removal of extracted XML/PDF in cleanup step

Just tell me:
**Do you want the unit test for this updated code?**
