Great catch ‚Äî this is exactly the right question to ask üëç
Nothing is ‚Äúmissing‚Äù at runtime, it‚Äôs just a **method you still need to define**.

Let me walk you through it cleanly and show **where it lives, why it exists, and the exact code**.

---

## What you asked about

You saw this line:

```java
return buildTaxSubtotalForVat(group, new BigDecimal("21"));
```

and asked:

> where is this method?

### ‚úÖ Answer

`buildTaxSubtotalForVat(...)` is a **new default helper method** that you must add **yourself** inside **`CsvInvoiceMapper`**.
It is **not generated by MapStruct** and it does **not already exist** unless you created it earlier.

It sits **next to** your other default methods like `toInvoiceTypeGroup(...)`.

---

## Why you need this method

You now have **two responsibilities**:

| VAT case   | How it‚Äôs calculated                                       |
| ---------- | --------------------------------------------------------- |
| VAT **0**  | Special logic ‚Üí sum `InvoiceLine_cbc_LineExtensionAmount` |
| VAT **21** | Generic logic ‚Üí sum taxable + tax amounts                 |

So you split the logic:

* `buildVatZeroSubtotal(...)` ‚Üí VAT 0 only
* `buildTaxSubtotalForVat(...)` ‚Üí generic VAT (21, maybe others later)

This keeps:

* logic **clear**
* subtotals printed **once**
* code **Sonar-friendly**

---

## Where it lives (important)

**Location:**

```java
@Mapper(componentModel = "spring")
public interface CsvInvoiceMapper {
    // ‚¨áÔ∏è HERE
}
```

It must be a **`default` method** so MapStruct does **not** try to generate it.

---

## Exact method you should add (VAT 21)

Here is the **complete, production-safe implementation**:

```java
default TaxSubtotalType buildTaxSubtotalForVat(
        CsvInvoiceGroup group,
        BigDecimal vatPercentage
) {
    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxSum = BigDecimal.ZERO;
    boolean found = false;

    for (CsvInvoiceDto row : group.getRows –∏–∑–≤–µ—Å—Ç–Ω–æ) {
        BigDecimal rowVat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (rowVat != null && rowVat.compareTo(vatPercentage) == 0) {
            found = true;

            taxableSum = taxableSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalExclVatValue())
            );

            taxSum = taxSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalVatAmountValue())
            );
        }
    }

    if (!found) {
        return null; // no VAT 21 lines ‚Üí no subtotal
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType category = getTaxCategory(
        vatPercentage,
        false,
        group.getRows().get(0).getItemCbcName()
    );
    taxSubtotal.setTaxCategory(category);

    return taxSubtotal;
}
```

---

## How it‚Äôs used (now it makes sense)

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {
    TaxTotalType taxTotal = new TaxTotalType();

    // VAT 21 (generic)
    TaxSubtotalType vat21 = buildTaxSubtotalForVat(group, new BigDecimal("21"));
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    // VAT 0 (special)
    TaxSubtotalType vat0 = buildVatZeroSubtotal(group);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

---

## Helper you also need (already referenced)

```java
default BigDecimal safeAmount(String value) {
    if (value == null || value.isBlank()) {
        return BigDecimal.ZERO;
    }
    return toAmount(value);
}
```

---

## Final mental model (so it sticks)

* **MapStruct mappings** ‚Üí structure only
* **Default methods** ‚Üí business aggregation logic
* **`buildTaxSubtotalForVat`** ‚Üí generic VAT logic (21)
* **`buildVatZeroSubtotal`** ‚Üí special VAT 0 logic
* **`toTaxTotal(group)`** ‚Üí orchestrates both, once per invoice

Nothing is duplicated, nothing runs per line accidentally.

---

If you want, next I can:

* üîç Add **debug logs** that prove this runs once per invoice
* üß™ Write **JUnit tests** for VAT 21 + VAT 0 together
* ‚ôªÔ∏è Mirror the same logic for **CreditNote mapper**

Just tell me where you want to go next.
