Perfect, then let‚Äôs wire it exactly like this:

* You **keep the files in `incoming/` & `outgoing/` during the job** (other API can read them).
* You already have a **wait time based on file size**, so by the time the job ends, the API *should* have had time to transfer.
* In the **cleanup listener**:

  * On **SUCCESS** ‚Üí delete tracked input/output files.
  * On **FAILURE** ‚Üí move them to `/failed/...` and never delete.

Here‚Äôs a clean implementation + JUnit for **both success and fail scenarios**.

---

## 1Ô∏è‚É£ Context helper ‚Äì track files to clean up

```java
package com.yourcompany.batch.cos;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.item.ExecutionContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public interface CosCleanupContextSupport {

    String FILES_TO_DELETE_ON_SUCCESS = "filesToDeleteOnSuccess";

    @SuppressWarnings("unchecked")
    default void addFileToDeleteOnSuccess(StepExecution stepExecution, String key) {
        JobExecution jobExecution = stepExecution.getJobExecution();
        ExecutionContext jobContext = jobExecution.getExecutionContext();

        List<String> keys = (List<String>) jobContext.get(FILES_TO_DELETE_ON_SUCCESS);
        if (keys == null) {
            keys = new ArrayList<>();
        }

        keys.add(key);
        // IMPORTANT: re-put list so Spring Batch marks EC as dirty
        jobContext.put(FILES_TO_DELETE_ON_SUCCESS, keys);
    }

    @SuppressWarnings("unchecked")
    default List<String> getFilesToDeleteOnSuccess(JobExecution jobExecution) {
        ExecutionContext jobContext = jobExecution.getExecutionContext();
        List<String> keys = (List<String>) jobContext.get(FILES_TO_DELETE_ON_SUCCESS);
        return keys == null ? Collections.emptyList() : keys;
    }
}
```

üëâ **Contract:** you store the **real COS keys** you used, e.g.:

* `incoming/file1.csv.zip.pgp`
* `outgoing/invoices_001.xml.zip.pgp`

No `/processed`, no leading `/`.

---

## 2Ô∏è‚É£ Listener ‚Äì delete on success, move to `/failed` on failure

```java
package com.yourcompany.batch.cos;

import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class CosCleanupListener implements JobExecutionListener, CosCleanupContextSupport {

    private final CosService cosService;

    public CosCleanupListener(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // nothing
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        List<String> keys = getFilesToDeleteOnSuccess(jobExecution);
        if (keys.isEmpty()) {
            // No input/output files tracked (e.g. no-file day)
            return;
        }

        BatchStatus status = jobExecution.getStatus();

        if (status == BatchStatus.COMPLETED) {
            // ‚úÖ SUCCESS ‚Üí delete from incoming/outgoing
            keys.forEach(cosService::deleteFile);

        } else if (status == BatchStatus.FAILED
                || status == BatchStatus.STOPPED
                || status == BatchStatus.ABANDONED) {
            // ‚ùå FAIL/STOPPED ‚Üí archive under /failed and keep
            keys.forEach(cosService::moveToFailed);
        }
        // For STARTING/STARTED etc, do nothing.
    }
}
```

And your `CosService` roughly like:

```java
public class CosService {

    private final AmazonS3 s3Client;
    private final String bucketName;

    public CosService(AmazonS3 s3Client, String bucketName) {
        this.s3Client = s3Client;
        this.bucketName = bucketName;
    }

    public void deleteFile(String key) {
        if (!s3Client.doesObjectExist(bucketName, key)) {
            return; // or log and return
        }
        s3Client.deleteObject(bucketName, key);
    }

    public String moveToFailed(String key) {
        // incoming/file1.csv.zip.pgp ‚Üí failed/incoming/file1.csv.zip.pgp
        String failedKey = "failed/" + key;

        CopyObjectRequest copyReq =
                new CopyObjectRequest(bucketName, key, bucketName, failedKey);
        s3Client.copyObject(copyReq);
        s3Client.deleteObject(bucketName, key);

        return failedKey;
    }
}
```

---

## 3Ô∏è‚É£ JUnit ‚Äì success & fail scenarios

### Test class for listener

```java
package com.yourcompany.batch.cos;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

class CosCleanupListenerTest {

    private CosService cosService;
    private CosCleanupListener listener;
    private CosCleanupContextSupport contextSupport;

    @BeforeEach
    void setUp() {
        this.cosService = Mockito.mock(CosService.class);
        this.listener = new CosCleanupListener(cosService);
        this.contextSupport = listener; // listener implements the interface
    }

    @Test
    void afterJob_completed_shouldDeleteTrackedFiles() {
        // given
        JobExecution jobExecution = new JobExecution(1L);
        StepExecution stepExecution = new StepExecution("step1", jobExecution);

        // Track original keys (incoming + outgoing)
        contextSupport.addFileToDeleteOnSuccess(stepExecution, "incoming/file1.csv.zip.pgp");
        contextSupport.addFileToDeleteOnSuccess(stepExecution, "outgoing/invoices_001.xml.zip.pgp");

        jobExecution.setStatus(BatchStatus.COMPLETED);

        // when
        listener.afterJob(jobExecution);

        // then
        verify(cosService).deleteFile("incoming/file1.csv.zip.pgp");
        verify(cosService).deleteFile("outgoing/invoices_001.xml.zip.pgp");
        verify(cosService, never()).moveToFailed(anyString());
        verifyNoMoreInteractions(cosService);
    }

    @Test
    void afterJob_failed_shouldMoveTrackedFilesToFailed() {
        // given
        JobExecution jobExecution = new JobExecution(2L);
        StepExecution stepExecution = new StepExecution("step1", jobExecution);

        contextSupport.addFileToDeleteOnSuccess(stepExecution, "incoming/file1.csv.zip.pgp");
        contextSupport.addFileToDeleteOnSuccess(stepExecution, "outgoing/invoices_001.xml.zip.pgp");

        jobExecution.setStatus(BatchStatus.FAILED);

        // when
        listener.afterJob(jobExecution);

        // then
        verify(cosService).moveToFailed("incoming/file1.csv.zip.pgp");
        verify(cosService).moveToFailed("outgoing/invoices_001.xml.zip.pgp");
        verify(cosService, never()).deleteFile(anyString());
        verifyNoMoreInteractions(cosService);
    }

    @Test
    void afterJob_completedAndNoTrackedFiles_shouldDoNothing() {
        // given
        JobExecution jobExecution = new JobExecution(3L);
        jobExecution.setStatus(BatchStatus.COMPLETED);

        // when
        listener.afterJob(jobExecution);

        // then
        verifyNoInteractions(cosService);
    }

    @Test
    void afterJob_startedStatus_shouldDoNothingEvenIfKeysExist() {
        // given
        JobExecution jobExecution = new JobExecution(4L);
        StepExecution stepExecution = new StepExecution("step1", jobExecution);

        contextSupport.addFileToDeleteOnSuccess(stepExecution, "incoming/file1.csv.zip.pgp");
        jobExecution.setStatus(BatchStatus.STARTED);

        // when
        listener.afterJob(jobExecution);

        // then
        verifyNoInteractions(cosService);
    }
}
```

This covers your **success** and **fail** scenarios exactly:

* ‚úÖ `COMPLETED` ‚Üí `deleteFile(...)` called for each tracked key.
* ‚úÖ `FAILED` ‚Üí `moveToFailed(...)` called for each tracked key.
* üîá No keys ‚Üí no COS calls.
* üîá Non-final status (e.g. STARTED) ‚Üí no cleanup.

---

Given you already have the **size-based wait time**, this approach is a good first attempt:

* Other API has time to read from `incoming/` / `outgoing/`.
* Once your batch finishes:

  * If all good ‚Üí those files are cleaned.
  * If something broke ‚Üí they are preserved under `/failed/...` forever.

If you later notice even the wait isn‚Äôt always enough, you can still switch to a **delayed cleanup job** without changing how you track keys.
