Gotcha, that makes sense now üëç

You want a *much simpler* flow:

> **POST ‚Üí wait (size-based) ‚Üí single GET**
> If GET says `CANCELLED` (or error) ‚Üí do **one more** `POST ‚Üí wait ‚Üí GET`.
> No polling loop, no multiple GETs.

Also: `sentinel = PRE_PROC` should *not* be treated as a failure.

Let‚Äôs do this step by step and keep the code small and readable.

---

## 1. Desired behavior (in words)

For each file:

1. **First attempt**

   1. Call `POST /transfers` (your existing notify)
      ‚Æï response contains `idtu`.
   2. Wait for your **size-based duration** (e.g. `6s + X per MB`).
   3. Call **one** `GET /transfers/{idtu}`.
   4. Interpret result:

      * If `sentinel == "CANCELLED"` **or** `diagi != 0` ‚Üí treat as *error*.
      * Any other `sentinel` (`COMPLETED`, `PRE_PROC`, `SENDING`, ‚Ä¶) with `diagi == 0` ‚Üí treat as **success**.

2. **If first attempt is error** (`CANCELLED` or `diagi != 0`)
   ‚ûú Do **one more full attempt**:

   * `POST` again (new `idtu`)
   * wait again
   * `GET` once
   * If still error ‚Üí throw exception ‚Üí batch step fails.

So:

* ‚úÖ No multiple GETs per attempt (exactly one).
* ‚úÖ GET happens **only after** the wait.
* ‚úÖ `PRE_PROC` is considered OK as long as `diagi == 0`.
* ‚úÖ At most **2 POSTs** per file (initial + 1 retry).

---

## 2. DTO for GET `/transfers/{idtu}`

```java
public class TransferStatusResponse {

    private String idtu;
    private String sentinel;   // e.g. "COMPLETED", "PRE_PROC", "SENDING", "CANCELLED"
    private int diagi;         // 0 = OK
    private String diagnostic; // descriptive text

    // getters and setters
}
```

Adjust field names with `@JsonProperty` if needed.

---

## 3. Helper: GET status once

In your `CftApiClient`:

```java
private TransferStatusResponse getTransferStatus(String idtu) {
    String url = baseURL + "/transfers/{idtu}";   // adjust if needed

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("idtu", idtu);

    ResponseEntity<String> response =
            restTemplate.exchange(url, HttpMethod.GET, null, String.class, uriVariables);

    log.info("CFT GET status for idtu={} -> {}", idtu, response.getStatusCode());
    log.debug("CFT GET body: {}", response.getBody());

    try {
        return objectMapper.readValue(response.getBody(), TransferStatusResponse.class);
    } catch (Exception e) {
        throw new IllegalStateException("Failed to parse CFT status for idtu=" + idtu, e);
    }
}
```

---

## 4. Helper: POST once and return `idtu`

This is basically your current POST, wrapped:

```java
private String triggerTransferOnce(String outPath, String fileName, int attempt) throws Exception {
    String apiUrl = baseURL + "?part={part}&idtf={idtf}";

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);

    Map<String, String> requestBody = new HashMap<>();
    requestBody.put("fname", outPath);
    requestBody.put("pname", fileName);
    requestBody.put("sync", "YES");

    String jsonPayload = objectMapper.writeValueAsString(requestBody);
    HttpEntity<String> requestEntity = new HttpEntity<>(jsonPayload, headers);

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("part", destPART);
    uriVariables.put("idtf", destIDF);

    log.info("Sending CFT POST attempt {} to: {}", attempt, apiUrl);
    log.info("Headers: {}", headers);
    log.info("Body   : {}", requestBody);

    ResponseEntity<String> response =
            restTemplate.exchange(apiUrl, HttpMethod.POST, requestEntity,
                                  String.class, uriVariables);

    log.info("CFT POST attempt {} status: {}", attempt, response.getStatusCode());
    log.info("CFT POST attempt {} body  : {}", attempt, response.getBody());

    JsonNode root = objectMapper.readTree(response.getBody());
    String idtu = root.path("idtu").asText(null);   // adjust field name if needed

    if (idtu == null || idtu.isEmpty()) {
        throw new IllegalStateException("CFT POST response did not contain idtu (attempt " + attempt + ")");
    }

    return idtu;
}
```

---

## 5. Helper: evaluate if this status is an **error**

You said: *‚Äúretry POST request once again in case of error if (`sentinel = CANCELLED` or `diagi != 0`)‚Äù*.

```java
private boolean isErrorStatus(TransferStatusResponse status) {
    String sentinel = status.getSentinel();
    int diagi = status.getDiagi();

    // log always, for visibility
    log.info("CFT status: idtu={} sentinel={} diagi={} diagnostic={}",
             status.getIdtu(), sentinel, diagi, status.getDiagnostic());

    // Only treat CANCELLED or diagi != 0 as errors
    if ("CANCELLED".equalsIgnoreCase(sentinel) || diagi != 0) {
        return true;
    }

    // PRE_PROC, COMPLETED, SENDING with diagi==0 are considered OK
    return false;
}
```

So your `PRE_PROC` case with `diagi == 0` becomes **success** ‚úÖ

---

## 6. Single attempt: POST ‚Üí wait ‚Üí GET ‚Üí decide

```java
private TransferStatusResponse doSingleAttempt(String outPath,
                                               String fileName,
                                               Duration waitTime,
                                               int attempt) {
    try {
        // 1) POST
        String idtu = triggerTransferOnce(outPath, fileName, attempt);

        // 2) WAIT based on file size (you pass this in)
        if (!waitTime.isZero() && !waitTime.isNegative()) {
            log.info("Waiting {} ms before status GET for idtu={}", waitTime.toMillis(), idtu);
            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before CFT GET", e);
            }
        }

        // 3) GET once
        TransferStatusResponse status = getTransferStatus(idtu);
        return status;

    } catch (Exception ex) {
        throw new IllegalStateException("CFT POST/GET attempt " + attempt + " failed for file " + fileName, ex);
    }
}
```

Note: **GET is now called only after the wait**, exactly as you asked.

---

## 7. Public method: retry POST+WAIT+GET once on error

```java
public void notifyAndWaitForCompletion(String outPath,
                                       String fileName,
                                       Duration waitTime) {

    // FIRST attempt
    TransferStatusResponse status = doSingleAttempt(outPath, fileName, waitTime, 1);

    if (!isErrorStatus(status)) {
        // OK: sentinel != CANCELLED and diagi == 0 (COMPLETED, PRE_PROC, SENDING, etc.)
        log.info("CFT transfer considered SUCCESS on first attempt for file {} (sentinel={}, diagi={})",
                 fileName, status.getSentinel(), status.getDiagi());
        return;
    }

    // We are in the error scenario: CANCELLED or diagi != 0
    log.warn("CFT transfer ERROR on first attempt for file {} ‚Äì sentinel={} diagi={} diagnostic={}. Retrying once...",
             fileName, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

    // SECOND (and last) attempt
    TransferStatusResponse status2 = doSingleAttempt(outPath, fileName, waitTime, 2);

    if (isErrorStatus(status2)) {
        // still error ‚Üí fail the batch
        throw new IllegalStateException(
                String.format("CFT transfer FAILED after retry for file %s. Last status: sentinel=%s diagi=%d diagnostic=%s",
                              fileName,
                              status2.getSentinel(),
                              status2.getDiagi(),
                              status2.getDiagnostic()));
    }

    log.info("CFT transfer considered SUCCESS on second attempt for file {} (sentinel={}, diagi={})",
             fileName, status2.getSentinel(), status2.getDiagi());
}
```

---

## 8. How your tasklet calls it

Back in `PackageAndUploadFilesTasklet`, you already compute a wait based on file size.

Where you had:

```java
if (cftEnabled) {
    // old: notifyUpload(...) + Thread.sleep(...) here
}
```

Change to:

```java
if (cftEnabled) {
    long bytes = encryptedFile.length();
    Duration waitTime = pickWaitByTier(bytes, waittime);  // your existing size-based logic

    log.info("Payload size={} bytes. Using waitTime={} before CFT status GET.", bytes, waitTime);
    cftApiClient.notifyAndWaitForCompletion(key, encryptedFileName, waitTime);
}
```

---

### Summary

* We removed the polling loop and **multiple GETs**.
* We now strictly do: **POST ‚Üí wait ‚Üí GET once**.
* We only treat `sentinel = CANCELLED` or `diagi != 0` as error ‚Üí triggers a **second full attempt** (POST+wait+GET).
* `sentinel = PRE_PROC` with `diagi == 0` is treated as **success**, same for `COMPLETED`, `SENDING`, etc.
* GET is **only** called after your size-based wait.

If you paste a sample actual GET JSON (with `PRE_PROC`), I can double-check the field names so you don‚Äôt get parsing surprises.
