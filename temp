package com.bnpp.pt.einvoice.connect.batch.csv;

import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.TaxCategoryType;
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.TaxSubtotalType;
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.TaxTotalType;
import org.junit.jupiter.api.Test;
import org.mapstruct.factory.Mappers;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class CsvInvoiceMapperTaxTotalCoverageTest {

    private final CsvInvoiceMapper mapper = Mappers.getMapper(CsvInvoiceMapper.class);

    @Test
    void toTaxTotal_whenVat21AndVat0Present_returnsOneTaxTotalWithTwoSubtotals_andMainTaxAmountIsSum() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("INV-1", new ArrayList<>());
        group.getRows().add(row("21", "100.00", "21.00"));
        group.getRows().add(row("21", "50.00", "21.00")); // repeated per-row, should be taken once
        group.getRows().add(row("0", "20.00", null));
        group.getRows().add(row("0", "10.00", null));

        List<TaxTotalType> taxTotals = mapper.toTaxTotal(group);

        assertEquals(1, taxTotals.size());

        TaxTotalType taxTotal = taxTotals.get(0);
        assertNotNull(taxTotal.getTaxAmount());
        assertBdEquals("21.00", taxTotal.getTaxAmount().getValue());

        assertEquals(2, taxTotal.getTaxSubtotal().size());

        TaxSubtotalType vat21 = findSubtotalByPercent(taxTotal.getTaxSubtotal(), new BigDecimal("21"));
        assertNotNull(vat21);
        assertBdEquals("150.00", vat21.getTaxableAmount().getValue());
        assertBdEquals("21.00", vat21.getTaxAmount().getValue());
        assertTaxCategory(vat21.getTaxCategory(), "S", "21");

        TaxSubtotalType vat0 = findSubtotalByPercent(taxTotal.getTaxSubtotal(), BigDecimal.ZERO);
        assertNotNull(vat0);
        assertBdEquals("30.00", vat0.getTaxableAmount().getValue());
        assertBdEquals("0", vat0.getTaxAmount().getValue());
        assertTaxCategory(vat0.getTaxCategory(), "E", "0");

        // Your final code adds "Exempt" for VAT 0 when isClassified=false
        assertFalse(vat0.getTaxCategory().getTaxExemptionReason().isEmpty());
        assertEquals("Exempt", vat0.getTaxCategory().getTaxExemptionReason().get(0).getValue());
    }

    @Test
    void toTaxTotal_whenOnlyVat21Present_returnsOneTaxTotalWithOneSubtotal() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("INV-2", new ArrayList<>());
        group.getRows().add(row("21", "40.00", "8.40"));
        group.getRows().add(row("21", "60.00", "8.40"));

        List<TaxTotalType> taxTotals = mapper.toTaxTotal(group);

        assertEquals(1, taxTotals.size());

        TaxTotalType taxTotal = taxTotals.get(0);
        assertEquals(1, taxTotal.getTaxSubtotal().size());
        assertBdEquals("8.40", taxTotal.getTaxAmount().getValue());

        TaxSubtotalType vat21 = taxTotal.getTaxSubtotal().get(0);
        assertBdEquals("100.00", vat21.getTaxableAmount().getValue());
        assertBdEquals("8.40", vat21.getTaxAmount().getValue());
        assertTaxCategory(vat21.getTaxCategory(), "S", "21");
    }

    @Test
    void toTaxTotal_whenOnlyVat0Present_returnsOneTaxTotalWithOneSubtotal_andMainTaxAmountZero() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("INV-3", new ArrayList<>());
        group.getRows().add(row("0", "10.00", null));
        group.getRows().add(row("0", "15.00", null));

        List<TaxTotalType> taxTotals = mapper.toTaxTotal(group);

        assertEquals(1, taxTotals.size());

        TaxTotalType taxTotal = taxTotals.get(0);
        assertEquals(1, taxTotal.getTaxSubtotal().size());
        assertBdEquals("0", taxTotal.getTaxAmount().getValue());

        TaxSubtotalType vat0 = taxTotal.getTaxSubtotal().get(0);
        assertBdEquals("25.00", vat0.getTaxableAmount().getValue());
        assertBdEquals("0", vat0.getTaxAmount().getValue());
        assertTaxCategory(vat0.getTaxCategory(), "E", "0");
        assertFalse(vat0.getTaxCategory().getTaxExemptionReason().isEmpty());
    }

    @Test
    void toTaxTotal_whenNoVat21AndNoVat0_returnsEmptyList() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("INV-4", new ArrayList<>());
        group.getRows().add(row("6", "100.00", "6.00"));

        List<TaxTotalType> taxTotals = mapper.toTaxTotal(group);

        assertTrue(taxTotals.isEmpty());
    }

    @Test
    void buildTaxSubtotalForVat_whenVat21Present_usesCsvVatAmountOnlyOnce_evenIfMultipleLines() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("INV-5", new ArrayList<>());
        group.getRows().add(row("21", "100.00", "21.00"));
        group.getRows().add(row("21", "50.00", "999.99")); // should NOT override, because first match is taken once

        TaxSubtotalType vat21 = mapper.buildTaxSubtotalForVat(group, new BigDecimal("21"));

        assertNotNull(vat21);
        assertBdEquals("150.00", vat21.getTaxableAmount().getValue());
        assertBdEquals("21.00", vat21.getTaxAmount().getValue());
        assertTaxCategory(vat21.getTaxCategory(), "S", "21");
    }

    @Test
    void buildTaxSubtotalForVat_whenVat21PresentButCsvVatAmountMissing_defaultsTaxAmountToZero() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("INV-6", new ArrayList<>());
        group.getRows().add(row("21", "100.00", null));
        group.getRows().add(row("21", "50.00", null));

        TaxSubtotalType vat21 = mapper.buildTaxSubtotalForVat(group, new BigDecimal("21"));

        assertNotNull(vat21);
        assertBdEquals("150.00", vat21.getTaxableAmount().getValue());
        assertBdEquals("0", vat21.getTaxAmount().getValue());
        assertTaxCategory(vat21.getTaxCategory(), "S", "21");
    }

    // ---------------- helpers ----------------

    private CsvInvoiceDto row(String vatPercent, String lineExtAmount, String subTotalVatAmountValue) {
        CsvInvoiceDto dto = new CsvInvoiceDto();
        dto.setInvoiceLineCbcVATPercentage(vatPercent);
        dto.setInvoiceLineCbcLineExtensionAmount(lineExtAmount);
        dto.setAdditionalItemPropertyCbcSubTotalVatAmountValue(subTotalVatAmountValue);
        return dto;
    }

    private static void assertBdEquals(String expected, BigDecimal actual) {
        assertNotNull(actual);
        BigDecimal exp = new BigDecimal(expected);
        assertEquals(0, exp.compareTo(actual), "Expected " + exp + " but was " + actual);
    }

    private static TaxSubtotalType findSubtotalByPercent(List<TaxSubtotalType> subtotals, BigDecimal percent) {
        for (TaxSubtotalType subtotal : subtotals) {
            TaxCategoryType cat = subtotal.getTaxCategory();
            if (cat != null
                    && cat.getPercent() != null
                    && cat.getPercent().getValue() != null
                    && cat.getPercent().getValue().compareTo(percent) == 0) {
                return subtotal;
            }
        }
        return null;
    }

    private static void assertTaxCategory(TaxCategoryType cat, String expectedId, String expectedPercent) {
        assertNotNull(cat);

        assertNotNull(cat.getID());
        assertEquals(expectedId, cat.getID().getValue());

        assertNotNull(cat.getPercent());
        assertNotNull(cat.getPercent().getValue());
        assertEquals(0, new BigDecimal(expectedPercent).compareTo(cat.getPercent().getValue()));

        assertNotNull(cat.getTaxScheme());
        assertNotNull(cat.getTaxScheme().getID());
        assertEquals("VAT", cat.getTaxScheme().getID().getValue());
    }
}


-------------
default TaxSubtotalType buildTaxSubtotalForVat(CsvInvoiceGroup group, BigDecimal vatPercentage) {

    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxAmountValue = null;
    boolean foundVat = false;

    for (CsvInvoiceDto row : group.getRows()) {

        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat != null && vat.compareTo(vatPercentage) == 0) {

            foundVat = true;

            // taxable base: sum LineExtensionAmount for matching VAT
            BigDecimal lineExt = toAmount(row.getInvoiceLineCbcLineExtensionAmount());
            if (lineExt != null) {
                taxableSum = taxableSum.add(lineExt);
            }

            // tax amount: take it ONCE from CSV subtotal VAT amount (do not sum per line)
            if (vatPercentage.compareTo(BigDecimal.ZERO) > 0 && taxAmountValue == null) {
                taxAmountValue = toAmount(row.getAdditionalItemPropertyCbcSubTotalVatAmountValue());
            }
        }
    }

    if (!foundVat) {
        return null;
    }

    if (taxAmountValue == null) {
        taxAmountValue = BigDecimal.ZERO;
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxAmountValue);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType taxCategory =
            getTaxCategory(vatPercentage, false, group.getRows().get(0).getItemCbcName());
    taxSubtotal.setTaxCategory(taxCategory);

    return taxSubtotal;
}


----------------------
Yep — here’s the **final code** (only what you need), with:

* **VAT 21 subtotal printed once** (tax amount taken **from CSV**, not calculated)
* **VAT 0 subtotal printed once** (taxable = **sum of LineExtensionAmount** for VAT 0)
* **TaxTotal/cbc:TaxAmount is always set** (sum of subtotals)
* **No extra `money()` method**, and **only uses your `toAmount()`**
* No duplicated VAT21/VAT0 methods — **one generic builder**

---

## 1) Mapping change (required)

```java
@Mapping(target = "taxTotal", ignore = true)
InvoiceType toInvoiceType(CsvInvoiceDto dto);
```

---

## 2) Set tax totals once per group (in your existing group method)

```java
default InvoiceType toInvoiceTypeGroup(CsvInvoiceGroup group) {

    CsvInvoiceDto first = group.getRows().get(0);
    InvoiceType invoice = toInvoiceType(first);

    invoice.getInvoiceLine().clear();
    for (CsvInvoiceDto row : group.getRows()) {
        invoice.getInvoiceLine().add(toInvoiceLine(row));
    }

    invoice.getTaxTotal().clear();
    invoice.getTaxTotal().addAll(toTaxTotal(group));

    return invoice;
}
```

---

## 3) Group-level TaxTotal (VAT 21 + VAT 0 once, and TaxTotal TaxAmount set)

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {

    TaxTotalType taxTotal = new TaxTotalType();
    BigDecimal totalTaxSum = BigDecimal.ZERO;

    TaxSubtotalType vat21 = buildTaxSubtotalForVat(group, new BigDecimal("21"));
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
        totalTaxSum = totalTaxSum.add(vat21.getTaxAmount().getValue());
    }

    TaxSubtotalType vat0 = buildTaxSubtotalForVat(group, BigDecimal.ZERO);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
        totalTaxSum = totalTaxSum.add(vat0.getTaxAmount().getValue());
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    TaxAmountType totalTaxAmount = new TaxAmountType();
    totalTaxAmount.setCurrencyID("EUR");
    totalTaxAmount.setValue(totalTaxSum);
    taxTotal.setTaxAmount(totalTaxAmount);

    return Collections.singletonList(taxTotal);
}
```

---

## 4) One generic subtotal builder (no duplication)

```java
default TaxSubtotalType buildTaxSubtotalForVat(CsvInvoiceGroup group, BigDecimal vatPercentage) {

    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxSum = BigDecimal.ZERO;
    boolean foundVat = false;

    for (CsvInvoiceDto row : group.getRows()) {

        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat == null || vat.compareTo(vatPercentage) != 0) {
            continue;
        }

        foundVat = true;

        // Taxable base: sum LineExtensionAmount (works for both VAT 21 and VAT 0)
        BigDecimal lineExt = toAmount(row.getInvoiceLineCbcLineExtensionAmount());
        if (lineExt != null) {
            taxableSum = taxableSum.add(lineExt);
        }

        // Tax amount:
        // - VAT 0 => 0
        // - VAT 21 => take VAT amount directly from CSV (no calculations)
        if (vatPercentage.compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal csvVatAmount = toAmount(row.getAdditionalItemPropertyCbcSubTotalVatAmountValue());
            if (csvVatAmount != null) {
                taxSum = taxSum.add(csvVatAmount);
            }
        }
    }

    if (!foundVat) {
        return null;
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType taxCategory =
            getTaxCategory(vatPercentage, false, group.getRows().get(0).getItemCbcName());
    taxSubtotal.setTaxCategory(taxCategory);

    return taxSubtotal;
}
```

> Note: This uses `continue;` once. If you want strict Sonar style (“avoid continue”), I can rewrite that if-block into a nested `if` with identical logic.

---

If you paste your existing `getTaxCategory(...)` signature (just that method), I’ll ensure it produces Peppol-correct:

* VAT 21 → `ID=S`, `Percent=21`, `TaxScheme VAT`
* VAT 0 → `ID=E`, `Percent=0`, `TaxScheme VAT` (+ exemption reason if you have it)
