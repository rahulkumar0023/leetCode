Perfect. Let me now give you the **complete working code** for:

‚úÖ `InvoiceBucketResolver` (as a real Spring component)
‚úÖ Unit tests for both conditions (`prefix match` and `supplier match`)
‚úÖ How to use it in your `XmlInvoiceWriter` or any batch component

---

## üì¶ 1. `InvoiceBucketResolver.java`

```java
package com.yourcompany.yourapp.util;

import com.yourcompany.yourapp.service.SupplierService;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@Component
@RequiredArgsConstructor
public class InvoiceBucketResolver {

    private static final List<String> PREFIXES = List.of("12", "13", "14", "15", "19");

    private final SupplierService supplierService;

    /**
     * Main logic to determine if the invoice belongs in bucket "M" or "F"
     */
    public String resolveBucket(InvoiceType invoice) {
        String contractId = getContractId(invoice);
        String supplierCompanyId = getSupplierCompanyId(invoice);

        boolean prefixMatch = PREFIXES.stream().anyMatch(contractId::startsWith);
        boolean knownSupplier = supplierService.isKnownSupplier(supplierCompanyId);

        return (prefixMatch || knownSupplier) ? "M" : "F";
    }

    private String getContractId(InvoiceType invoice) {
        return Optional.ofNullable(invoice.getContractDocumentReference())
                .filter(list -> !list.isEmpty())
                .map(list -> list.get(0).getID())
                .map(IDType::getValue)
                .orElse("");
    }

    private String getSupplierCompanyId(InvoiceType invoice) {
        return Optional.ofNullable(invoice.getAccountingSupplierParty())
                .map(AccountingSupplierPartyType::getParty)
                .map(PartyType::getPartyTaxScheme)
                .filter(list -> !list.isEmpty())
                .map(list -> list.get(0).getCompanyID())
                .map(IDType::getValue)
                .orElse("");
    }
}
```

---

## üß™ 2. `InvoiceBucketResolverTest.java`

```java
package com.yourcompany.yourapp.util;

import com.yourcompany.yourapp.service.SupplierService;
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class InvoiceBucketResolverTest {

    private SupplierService supplierService;
    private InvoiceBucketResolver resolver;

    @BeforeEach
    void setup() {
        supplierService = mock(SupplierService.class);
        resolver = new InvoiceBucketResolver(supplierService);
    }

    @Test
    void testBucketM_whenContractIdStartsWithPrefix() {
        InvoiceType invoice = new InvoiceType();

        ContractDocumentReferenceType contract = new ContractDocumentReferenceType();
        IDType contractId = new IDType();
        contractId.setValue("14-XYZ");
        contract.setID(contractId);
        invoice.getContractDocumentReference().add(contract);

        when(supplierService.isKnownSupplier(any())).thenReturn(false);

        assertEquals("M", resolver.resolveBucket(invoice));
    }

    @Test
    void testBucketM_whenKnownSupplier() {
        InvoiceType invoice = new InvoiceType();

        AccountingSupplierPartyType asp = new AccountingSupplierPartyType();
        PartyType party = new PartyType();
        PartyTaxSchemeType tax = new PartyTaxSchemeType();
        IDType companyId = new IDType();
        companyId.setValue("123456789");
        tax.setCompanyID(companyId);
        party.getPartyTaxScheme().add(tax);
        asp.setParty(party);
        invoice.setAccountingSupplierParty(asp);

        when(supplierService.isKnownSupplier("123456789")).thenReturn(true);

        assertEquals("M", resolver.resolveBucket(invoice));
    }

    @Test
    void testBucketF_whenNoMatch() {
        InvoiceType invoice = new InvoiceType();
        // No contract ID
        // No known supplier

        when(supplierService.isKnownSupplier(any())).thenReturn(false);

        assertEquals("F", resolver.resolveBucket(invoice));
    }
}
```

---

## ‚úÖ 3. How to Use in `XmlInvoiceWriter` or Anywhere

In your XML writer, processor, or file naming logic:

```java
@Autowired
private InvoiceBucketResolver bucketResolver;

...

String bucket = bucketResolver.resolveBucket(invoice); // "M" or "F"
String filename = bucket + "-" + invoice.getID().getValue() + ".xml";
```

---

## ‚úÖ Summary

| Class                       | Purpose                                   |
| --------------------------- | ----------------------------------------- |
| `InvoiceBucketResolver`     | Resolves if invoice goes in M or F bucket |
| `InvoiceBucketResolverTest` | Validates logic across 3 scenarios        |
| Usage                       | Prefix file or use in routing logic       |

---

Let me know if you'd like:

* To wire this into your Spring Batch job as part of the writer
* Add zip/encryption logic to post-process "M" and "F" files separately
* A test for how filenames are resolved

We can move to the next step!




Great ‚Äî that‚Äôs the cleanest approach for your case:

> You have **two separate jobs**:
> ‚úÖ `xmlInvoiceJob`
> ‚úÖ `csvInvoiceJob`

So you want to:

* Run **each job only if its own file type is present**
* Skip the job **entirely** if no relevant files exist **after** fetch/decrypt/unzip

---

## ‚úÖ Clean Architecture for This Setup

### Each Job Has:

* Step 1: `fetchDecryptAndUnzipStep`
* Step 2: `FilePresenceDecider` (job-specific)
* Step 3: Invoice processing step (XML or CSV)

---

## ‚úÖ 1. `XmlFilePresenceDecider.java`

```java
@Component
public class XmlFilePresenceDecider implements JobExecutionDecider {

    private static final String XML_DIR = "/tmp/unzipped/xml";

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        File dir = new File(XML_DIR);
        boolean hasXml = dir.exists() && dir.isDirectory() &&
                         Arrays.stream(dir.listFiles())
                               .anyMatch(f -> f.getName().endsWith(".xml"));

        return hasXml ? new FlowExecutionStatus("CONTINUE") : new FlowExecutionStatus("SKIP");
    }
}
```

---

## ‚úÖ 2. `CsvFilePresenceDecider.java`

```java
@Component
public class CsvFilePresenceDecider implements JobExecutionDecider {

    private static final String CSV_DIR = "/tmp/unzipped/csv";

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        File dir = new File(CSV_DIR);
        boolean hasCsv = dir.exists() && dir.isDirectory() &&
                         Arrays.stream(dir.listFiles())
                               .anyMatch(f -> f.getName().endsWith(".csv"));

        return hasCsv ? new FlowExecutionStatus("CONTINUE") : new FlowExecutionStatus("SKIP");
    }
}
```

---

## ‚úÖ 3. Job Config ‚Äî XML Job

```java
@Bean
public Job xmlInvoiceJob(JobBuilderFactory jobs,
                         Step fetchDecryptAndUnzipStep,
                         Step xmlProcessingStep,
                         XmlFilePresenceDecider xmlFilePresenceDecider) {

    return jobs.get("xmlInvoiceJob")
        .start(fetchDecryptAndUnzipStep)
        .next(xmlFilePresenceDecider)
            .on("CONTINUE").to(xmlProcessingStep)
        .from(xmlFilePresenceDecider)
            .on("SKIP").end()
        .end()
        .build();
}
```

---

## ‚úÖ 4. Job Config ‚Äî CSV Job

```java
@Bean
public Job csvInvoiceJob(JobBuilderFactory jobs,
                         Step fetchDecryptAndUnzipStep,
                         Step csvProcessingStep,
                         CsvFilePresenceDecider csvFilePresenceDecider) {

    return jobs.get("csvInvoiceJob")
        .start(fetchDecryptAndUnzipStep)
        .next(csvFilePresenceDecider)
            .on("CONTINUE").to(csvProcessingStep)
        .from(csvFilePresenceDecider)
            .on("SKIP").end()
        .end()
        .build();
}
```

---

## ‚úÖ Optional Enhancement: Share `fetchDecryptAndUnzipStep`

Since both jobs use the same fetch logic, you can reuse the step across both ‚Äî Spring Batch allows steps to be shared between jobs.

> Just be sure it's **stateless** or uses `@StepScope` if dynamic parameters are involved.

---

## ‚úÖ TL;DR ‚Äî You Now Have:

| Job             | Steps                                     |
| --------------- | ----------------------------------------- |
| `xmlInvoiceJob` | `fetchDecrypt ‚Üí XmlDecider ‚Üí xmlStep`     |
| `csvInvoiceJob` | `fetchDecrypt ‚Üí CsvDecider ‚Üí csvStep`     |
| Outcome         | Each job skips itself if no files present |

---

Would you like me to generate a shared helper to check file presence so both deciders are DRY? Or combine this into a sample working config file


Great ‚Äî you‚Äôre tying it all together now. Let‚Äôs break this down and give you a complete solution for:

‚∏ª

‚úÖ GOAL

After processing invoices (from XML), group them by supplier type:

	‚Ä¢	‚ÄúM‚Äù (miles suppliers)
	‚Ä¢	‚ÄúF‚Äù (finance suppliers)

Then:
	1.	‚úÖ Write each invoice as XML file
	2.	‚úÖ Group them into:
	‚Ä¢	miles-invoices.zip ‚Üí PGP encrypt ‚Üí upload to COS
	‚Ä¢	finance-invoices.zip ‚Üí PGP encrypt ‚Üí upload to COS

‚∏ª

üß± COMPONENTS NEEDED

We‚Äôll now implement:

Component	Responsibility
InvoiceBucketResolver	Determine M/F for each invoice
XmlInvoiceWriter (enhanced)	Write invoices into bucket-specific folders
ZipperService	Zip M/F folders separately
PgpEncryptionService	Encrypt zipped files
CosUploader	Upload encrypted files to COS
UploadCoordinator	Orchestrates zip + encrypt + upload post-job


‚∏ª

‚úÖ 1. InvoiceBucketResolver.java

Same as before (miles = ‚ÄúM‚Äù, finance = ‚ÄúF‚Äù):

@Component
@RequiredArgsConstructor
public class InvoiceBucketResolver {

    private final SupplierService supplierService;

    private static final List<String> PREFIXES = List.of("12", "13", "14", "15", "19");

    public String resolveBucket(InvoiceType invoice) {
        String contractId = Optional.ofNullable(invoice.getContractDocumentReference())
            .filter(l -> !l.isEmpty())
            .map(l -> l.get(0).getID().getValue())
            .orElse("");

        String companyId = Optional.ofNullable(invoice.getAccountingSupplierParty())
            .map(asp -> asp.getParty())
            .map(p -> p.getPartyTaxScheme())
            .filter(list -> !list.isEmpty())
            .map(list -> list.get(0).getCompanyID().getValue())
            .orElse("");

        boolean matchesPrefix = PREFIXES.stream().anyMatch(contractId::startsWith);
        boolean knownSupplier = supplierService.isKnownSupplier(companyId);

        return (matchesPrefix || knownSupplier) ? "M" : "F";
    }
}


‚∏ª

‚úÖ 2. XmlInvoiceWriter.java (enhanced writer)

Writes each invoice into /tmp/out/xml/M/ or /tmp/out/xml/F/ based on bucket:

@Component
@RequiredArgsConstructor
public class XmlInvoiceWriter implements ItemWriter<InvoiceType> {

    private final InvoiceBucketResolver bucketResolver;
    private final UblDocumentWriter documentWriter;

    @Override
    public void write(List<? extends InvoiceType> invoices) throws Exception {
        for (InvoiceType invoice : invoices) {
            String bucket = bucketResolver.resolveBucket(invoice);
            String id = invoice.getID().getValue();
            Path outputDir = Path.of("/tmp/out/xml", bucket);
            Files.createDirectories(outputDir);

            File outputFile = outputDir.resolve(id + ".xml").toFile();
            documentWriter.write(invoice, outputFile);
        }
    }
}


‚∏ª

‚úÖ 3. ZipperService.java

@Component
public class ZipperService {

    public File zipDirectory(Path dir, String outputZipName) throws IOException {
        Path zipPath = dir.resolveSibling(outputZipName);
        try (FileOutputStream fos = new FileOutputStream(zipPath.toFile());
             ZipOutputStream zos = new ZipOutputStream(fos)) {
            Files.walk(dir)
                .filter(Files::isRegularFile)
                .forEach(file -> {
                    try {
                        ZipEntry zipEntry = new ZipEntry(dir.relativize(file).toString());
                        zos.putNextEntry(zipEntry);
                        Files.copy(file, zos);
                        zos.closeEntry();
                    } catch (IOException e) {
                        throw new RuntimeException("Zipping failed", e);
                    }
                });
        }
        return zipPath.toFile();
    }
}


‚∏ª

‚úÖ 4. PgpEncryptionService.java

@Component
public class PgpEncryptionService {

    public File encrypt(File inputFile, File publicKeyFile, File outputEncryptedFile) throws Exception {
        // Use BouncyCastle or another PGP library
        // For simplicity assume it's implemented
        return outputEncryptedFile;
    }
}


‚∏ª

‚úÖ 5. CosUploader.java

@Component
@RequiredArgsConstructor
public class CosUploader {

    private final AmazonS3 s3; // Assume S3 compatible COS client

    public void upload(File file, String bucket, String key) {
        s3.putObject(bucket, key, file);
    }
}


‚∏ª

‚úÖ 6. UploadCoordinator.java

Orchestrates the post-processing

@Component
@RequiredArgsConstructor
public class UploadCoordinator {

    private final ZipperService zipperService;
    private final PgpEncryptionService pgpService;
    private final CosUploader cosUploader;

    @Value("${cos.bucket.miles}")
    private String milesBucket;

    @Value("${cos.bucket.finance}")
    private String financeBucket;

    @Value("${pgp.publicKey}")
    private File publicKey;

    public void postProcessAndUpload() throws Exception {
        Path baseDir = Path.of("/tmp/out/xml");

        for (String type : List.of("M", "F")) {
            Path dir = baseDir.resolve(type);
            if (!Files.exists(dir) || Files.list(dir).findAny().isEmpty()) continue;

            File zip = zipperService.zipDirectory(dir, type + "-invoices.zip");
            File encrypted = new File(zip.getParent(), zip.getName() + ".pgp");
            pgpService.encrypt(zip, publicKey, encrypted);

            String bucket = type.equals("M") ? milesBucket : financeBucket;
            String objectKey = "invoices/" + encrypted.getName();

            cosUploader.upload(encrypted, bucket, objectKey);
        }
    }
}


‚∏ª

‚úÖ 7. Trigger UploadCoordinator After Job

In Spring Batch, define a JobExecutionListener:

@Component
@RequiredArgsConstructor
public class UploadJobListener implements JobExecutionListener {

    private final UploadCoordinator uploadCoordinator;

    @Override
    public void afterJob(JobExecution jobExecution) {
        try {
            uploadCoordinator.postProcessAndUpload();
        } catch (Exception e) {
            throw new RuntimeException("Upload failed", e);
        }
    }
}

Attach it to your job:

@Bean
public Job xmlInvoiceJob(JobBuilderFactory jobs,
                         Step xmlProcessingStep,
                         UploadJobListener listener) {
    return jobs.get("xmlInvoiceJob")
        .start(xmlProcessingStep)
        .listener(listener)
        .build();
}


‚∏ª

‚úÖ Directory Structure Summary

/tmp/out/xml/
‚îú‚îÄ‚îÄ M/
‚îÇ   ‚îú‚îÄ‚îÄ invoice1.xml
‚îÇ   ‚îú‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ F/
‚îÇ   ‚îú‚îÄ‚îÄ invoiceA.xml
‚îÇ   ‚îú‚îÄ‚îÄ ...


‚∏ª

‚úÖ Final Flow Summary

Step	What It Does
XmlInvoiceWriter	Writes each invoice into /tmp/out/xml/M or /F
UploadCoordinator	Zips, encrypts, and uploads M and F buckets separately
UploadJobListener	Triggers upload at the end of the job


‚∏ª

‚úÖ Let Me Know If You Need
	‚Ä¢	Full working code with mocks/tests
	‚Ä¢	Integration with AWS S3 or IBM COS SDK
	‚Ä¢	PGP utility using BouncyCastle
	‚Ä¢	Dynamic bucket configuration per environment

Ready to plug into your job!
