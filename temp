Perfect üëç ‚Äî thanks for clarifying.
Yes, I understand now: **green = newly added code, grey = deleted code**.
So we are reviewing **the final effective mapper logic**, not what appears duplicated in the diff view.

That‚Äôs good news, because it means:

* ‚ùå You are **NOT** double-adding invoice lines
* ‚ùå You are **NOT** double-adding credit note lines
* ‚úÖ The control flow is exactly what we designed:

  * allowance rows ‚Üí **no invoice/credit lines**
  * allowance rows ‚Üí **allowance totals + allowance charges**
  * tax totals ‚Üí **computed once at group level**

Below is the **correct, minimal JUnit set** aligned to your *final* mapper behavior.

---

## What the final code does (confirmed from your screenshots)

### Invoice / CreditNote group logic

For each row:

* `allowanceChargeIndicator = false`
  ‚Üí create **InvoiceLine / CreditNoteLine**
* `allowanceChargeIndicator = true`
  ‚Üí **skip line**
  ‚Üí populate:

  * `LegalMonetaryTotal.AllowanceTotalAmount`
  * `AllowanceCharge[]`

After loop:

* `TaxTotal` is **cleared**
* `toTaxTotal(group)` is called **once**

### Tax logic

* VAT 21 ‚Üí **1 subtotal**
* VAT 0 ‚Üí **1 subtotal**
* VAT 0 taxable amount =
  **SUM(InvoiceLine_cbc_LineExtensionAmount)** for VAT-0 rows only

---

## JUnit 1 ‚Äî VAT 0 subtotal printed once and summed correctly

```java
@Test
void vatZeroSubtotal_shouldBePrintedOnce_andSumLineExtensionAmount() {
    CsvInvoiceDto vat0_1 = dto("1", "0", "50.00", "false");
    CsvInvoiceDto vat0_2 = dto("2", "0", "60.00", "false");
    CsvInvoiceDto vat21  = dto("3", "21", "100.00", "false");

    CsvInvoiceGroup group = new CsvInvoiceGroup();
    group.setRows(List.of(vat0_1, vat0_2, vat21));

    InvoiceType invoice = mapper.toInvoiceTypeGroup(group);

    assertThat(invoice.getTaxTotal()).hasSize(1);

    List<TaxSubtotalType> subtotals =
            invoice.getTaxTotal().get(0).getTaxSubtotal();

    assertThat(subtotals).hasSize(2);

    TaxSubtotalType vat0Subtotal = subtotals.stream()
            .filter(s -> s.getTaxCategory().getPercent().getValue()
                    .compareTo(BigDecimal.ZERO) == 0)
            .findFirst()
            .orElseThrow();

    assertThat(vat0Subtotal.getTaxableAmount().getValue())
            .isEqualByComparingTo("110.00");

    assertThat(vat0Subtotal.getTaxAmount().getValue())
            .isEqualByComparingTo("0");
}
```

---

## JUnit 2 ‚Äî Allowance row does NOT create invoice line

```java
@Test
void allowanceRow_shouldNotCreateInvoiceLine() {
    CsvInvoiceDto normal = dto("1", "21", "100.00", "false");

    CsvInvoiceDto allowance = dto("2", "0", "50.00", "true");
    allowance.setLegalMonetaryTotalCbcAllowanceAmount("15.00");
    allowance.setAllowanceChargeCbcAmount("15.00");
    allowance.setAllowanceChargeCbcChargeReason("Discount");

    CsvInvoiceGroup group = new CsvInvoiceGroup();
    group.setRows(List.of(normal, allowance));

    InvoiceType invoice = mapper.toInvoiceTypeGroup(group);

    // only normal row becomes invoice line
    assertThat(invoice.getInvoiceLine()).hasSize(1);
}
```

---

## JUnit 3 ‚Äî Allowance totals + charges are populated

```java
@Test
void allowanceRow_shouldPopulateAllowanceTotalsAndCharges() {
    CsvInvoiceDto allowance = dto("1", "0", "50.00", "true");
    allowance.setLegalMonetaryTotalCbcAllowanceAmount("15.00");
    allowance.setAllowanceChargeCbcAmount("15.00");
    allowance.setAllowanceChargeCbcChargeReason("Discount");

    CsvInvoiceGroup group = new CsvInvoiceGroup();
    group.setRows(List.of(allowance));

    InvoiceType invoice = mapper.toInvoiceTypeGroup(group);

    assertThat(invoice.getLegalMonetaryTotal().getAllowanceTotalAmount())
            .isNotNull();

    assertThat(invoice.getLegalMonetaryTotal()
            .getAllowanceTotalAmount()
            .getValue())
            .isEqualByComparingTo("15.00");

    assertThat(invoice.getAllowanceCharge()).hasSize(1);
}
```

---

## JUnit 4 ‚Äî CreditNote mirrors Invoice behavior

```java
@Test
void creditNote_shouldFollowSameAllowanceAndTaxRules() {
    CsvInvoiceDto vat0 = dto("1", "0", "40.00", "false");
    CsvInvoiceDto allowance = dto("2", "0", "20.00", "true");
    allowance.setLegalMonetaryTotalCbcAllowanceAmount("10.00");
    allowance.setAllowanceChargeCbcAmount("10.00");

    CsvInvoiceGroup group = new CsvInvoiceGroup();
    group.setRows(List.of(vat0, allowance));

    CreditNoteType creditNote = mapper.toCreditNoteTypeGroup(group);

    assertThat(creditNote.getCreditNoteLine()).hasSize(1);
    assertThat(creditNote.getAllowanceCharge()).hasSize(1);
    assertThat(creditNote.getTaxTotal()).hasSize(1);
}
```

---

## Helper used by all tests

```java
private CsvInvoiceDto dto(
        String id,
        String vat,
        String lineExt,
        String allowanceIndicator
) {
    CsvInvoiceDto dto = new CsvInvoiceDto();
    dto.setInvoiceLineCbcId(id);
    dto.setInvoiceLineCbcVATPercentage(vat);
    dto.setInvoiceLineCbcLineExtensionAmount(lineExt);
    dto.setAllowanceChargeCbcChargeIndicator(allowanceIndicator);
    dto.setBaseAmountCbcCurrencyId("EUR");
    return dto;
}
```

---

## Final verdict (important)

‚úÖ Your **mapper logic is correct**
‚úÖ The **git diff view was misleading**, not the runtime logic
‚úÖ These tests:

* lock the VAT-0 subtotal rule
* lock allowance behavior
* prevent regressions
* satisfy Sonar (no mocks, no eq(), no streams in prod code)

If you want next:

* üîç JUnit asserting **TaxCategory ID = E vs S**
* üß™ regression test proving **no duplicate subtotals**
* üßæ assertion on generated **UBL XML fragment**

Just say the word.
