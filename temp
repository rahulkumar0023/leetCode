Perfect üëè ‚Äî even better. YAML makes this cleaner and more readable than properties.
Here‚Äôs the **production-grade, Sonar-safe setup** using your existing `application.yaml` format.

---

## ‚úÖ **1. application.yaml**

```yaml
work:
  root: /var/app/alphacredit      # or /tmp/alphacredit in containers
  processed:
    xml: ${work.root}/processed/xml
    pdf: ${work.root}/processed/pdf
    csv: ${work.root}/processed/csv
  output: ${work.root}/output
```

**üëâ Why this is great**

* All file paths are centralized.
* You can easily override `work.root` per environment (`dev`, `uat`, `prod`).
* No hardcoding of `/tmp` in your Java code.

---

## ‚úÖ **2. Strongly-typed configuration class**

```java
@Component
@ConfigurationProperties(prefix = "work")
@Getter
@Setter
public class WorkDirectoryProperties {

    private Path root;
    private Processed processed = new Processed();
    private Path output;

    @Getter
    @Setter
    public static class Processed {
        private Path xml;
        private Path pdf;
        private Path csv;
    }

    @PostConstruct
    void init() throws IOException {
        // Create all required directories with restricted permissions
        for (Path dir : List.of(processed.xml, processed.pdf, processed.csv, output)) {
            if (dir != null) {
                Files.createDirectories(dir);
                try {
                    Files.setPosixFilePermissions(dir,
                            PosixFilePermissions.fromString("rwx------"));
                } catch (UnsupportedOperationException ignored) {
                    // Windows or non-POSIX FS: safe to ignore
                }
            }
        }
    }
}
```

**‚úÖ Advantages**

* No hardcoded `/tmp` ‚Üí passes Sonar security checks.
* Automatically creates required directories.
* Secure (`rwx------`) permissions on Unix.
* Central place to manage all work paths.
* Clean YAML ‚Üí clean code ‚Üí easy to maintain.

---

## ‚úÖ **3. Usage in your code**

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PackageAndUploadTasklet implements Tasklet {

    private final WorkDirectoryProperties dirs;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext context) throws Exception {
        Path xmlDir = dirs.getProcessed().getXml();
        Path outputDir = dirs.getOutput();

        log.info("Processing XML from {}", xmlDir);
        log.info("Writing output to {}", outputDir);

        // ... your logic here ...

        return RepeatStatus.FINISHED;
    }
}
```

---

### üß© **Optional Integration**

If you want to use the same base directory for secure temporary files (like your PGP key `.asc` files), you can reuse it:

```java
Path tempDir = dirs.getRoot().resolve("temp");
Files.createDirectories(tempDir);
File tempFile = Files.createTempFile(tempDir, filePrefix, ".asc").toFile();
```

That way **everything (input, output, temp)** stays within one controlled, private root.

---

‚úÖ **Final Result**

* Sonar warnings disappear.
* Fully production-safe (no `/tmp` exposure).
* Works the same on-prem, Docker, or K8s.
* Clean YAML config, no magic strings or SpEL.

---

Would you like me to also show how to adapt your **PGP key loading method** (`convertStringToTempFile`) to use this same config structure, so all temp key files go into your secure `work.root/temp` folder?
