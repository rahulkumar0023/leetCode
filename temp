Perfect ‚Äî that‚Äôs the ideal scenario for a **single Spring Batch job** with multiple well-defined steps.

Let‚Äôs structure this step-by-step and I‚Äôll give you sample code for each part. Here's how your job pipeline should look:

---

## ‚úÖ High-Level Job Plan

### üîÅ **Job: `invoiceJob`**

```text
Step 1: fetchAndUnzipStep          ‚Üê fetch from COS + decrypt + unzip
Step 2: xmlInvoiceStep             ‚Üê reads & processes XML invoices
Step 3: pdfInvoiceStep             ‚Üê reads & processes PDF invoices
Step 4: zipAndUploadStep           ‚Üê zips all processed & uploads back to COS
Step 5: cleanupStep (optional)     ‚Üê clears /tmp and logs
```

---

## ‚úÖ Step 1: `fetchAndUnzipStep` (Already Done)

Runs a `Tasklet` to:

* Fetch `.zip.pgp` from COS
* Decrypt to `.zip`
* Unzip `.xml` and `.pdf` into `/tmp/unzipped`

---

## ‚úÖ Step 2: `xmlInvoiceStep`

Already built with:

* `MultiResourceItemReader<InvoiceType>`
* `InvoiceProcessor`
* `InvoiceWriter` (writes to `/tmp/processed/xml` and `/tmp/processed/pdf`)

No changes needed unless you want to generate PDFs only here.

---

## ‚úÖ Step 3: `pdfInvoiceStep`

### üß© Reader: `PdfInvoiceReader`

```java
@Component
@StepScope
public class PdfInvoiceReader implements ItemReader<File> {
    private final Iterator<File> pdfFiles;

    public PdfInvoiceReader(@Value("#{jobParameters['inputDir']}") String inputDir) {
        File dir = new File(inputDir != null ? inputDir : "/tmp/unzipped");
        this.pdfFiles = Arrays.stream(dir.listFiles((d, name) -> name.endsWith(".pdf"))).iterator();
    }

    @Override
    public File read() {
        return pdfFiles.hasNext() ? pdfFiles.next() : null;
    }
}
```

---

### üß© Writer: `PdfInvoiceWriter`

```java
@Component
public class PdfInvoiceWriter implements ItemWriter<File> {
    @Override
    public void write(Chunk<? extends File> items) {
        for (File pdf : items) {
            try {
                Path targetDir = Path.of("/tmp/processed/pdf");
                Files.createDirectories(targetDir);
                Path target = targetDir.resolve(pdf.getName());
                Files.copy(pdf.toPath(), target, StandardCopyOption.REPLACE_EXISTING);
                log.info("üì• Copied PDF: {}", target);
            } catch (IOException e) {
                log.error("Failed to write PDF", e);
            }
        }
    }
}
```

---

### üß© Step Configuration

```java
@Bean
public Step pdfInvoiceStep(JobRepository jobRepository, PlatformTransactionManager txManager,
                           PdfInvoiceReader reader, PdfInvoiceWriter writer) {
    return new StepBuilder("pdfInvoiceStep", jobRepository)
            .<File, File>chunk(5, txManager)
            .reader(reader)
            .writer(writer)
            .build();
}
```

---

## ‚úÖ Step 4: `zipAndUploadStep`

This should:

* Zip all files from `/tmp/processed`
* Encrypt `.zip` to `.zip.pgp`
* Upload to COS bucket

You likely already have this or I can help implement it.

---

## ‚úÖ Full Job Definition

```java
@Bean
public Job invoiceJob(JobRepository jobRepository,
                      Step fetchAndUnzipStep,
                      Step xmlInvoiceStep,
                      Step pdfInvoiceStep,
                      Step zipAndUploadStep) {

    return new JobBuilder("invoiceJob", jobRepository)
            .start(fetchAndUnzipStep)
            .next(xmlInvoiceStep)
            .next(pdfInvoiceStep)
            .next(zipAndUploadStep)
            .build();
}
```

---

## ‚úÖ What‚Äôs Next?

Would you like help with:

* üß™ JUnit tests for `PdfInvoiceReader` & `PdfInvoiceWriter`?
* üîê Encrypt & zip logic in `zipAndUploadStep`?
* üìÅ Matching PDFs to XMLs by invoice ID?

Let‚Äôs build the rest cleanly ‚Äî one step at a time.



Great! Let‚Äôs build this cleanly.

---

## ‚úÖ 1. `PdfInvoiceReader` ‚Äî Code + JUnit Test

### üß© `PdfInvoiceReader.java`

```java
@Slf4j
@Component
@StepScope
public class PdfInvoiceReader implements ItemReader<File> {

    private Iterator<File> pdfFiles;

    @Value("#{jobParameters['inputDir'] ?: '/tmp/unzipped'}")
    public void setInputDirectory(String inputDir) {
        File dir = new File(inputDir);
        if (dir.exists() && dir.isDirectory()) {
            pdfFiles = Arrays.stream(dir.listFiles((d, name) -> name.toLowerCase().endsWith(".pdf"))).iterator();
        } else {
            pdfFiles = Collections.emptyIterator();
            log.warn("PDF input directory doesn't exist: {}", inputDir);
        }
    }

    @Override
    public File read() {
        return (pdfFiles != null && pdfFiles.hasNext()) ? pdfFiles.next() : null;
    }
}
```

---

### üß™ `PdfInvoiceReaderTest.java`

```java
@SpringBootTest
@ExtendWith(SpringExtension.class)
@ActiveProfiles("test")
class PdfInvoiceReaderTest {

    @Autowired
    private PdfInvoiceReader reader;

    @BeforeEach
    void setup() throws IOException {
        Path inputDir = Path.of("/tmp/unzipped");
        Files.createDirectories(inputDir);
        Files.writeString(inputDir.resolve("sample.pdf"), "Dummy PDF content");
    }

    @Test
    void shouldReadPdfFilesFromInputDir() {
        File file = reader.read();
        assertNotNull(file);
        assertTrue(file.getName().endsWith(".pdf"));
    }
}
```

---

## ‚úÖ 2. `PdfInvoiceWriter` ‚Äî Code + JUnit Test

### üß© `PdfInvoiceWriter.java`

```java
@Slf4j
@Component
public class PdfInvoiceWriter implements ItemWriter<File> {

    private final Path outputDir = Path.of("/tmp/processed/pdf");

    @Override
    public void write(Chunk<? extends File> items) {
        try {
            Files.createDirectories(outputDir);
            for (File file : items) {
                Path target = outputDir.resolve(file.getName());
                Files.copy(file.toPath(), target, StandardCopyOption.REPLACE_EXISTING);
                log.info("‚úÖ Copied PDF to: {}", target);
            }
        } catch (IOException e) {
            throw new UncheckedIOException("Failed to write PDF files", e);
        }
    }
}
```

---

### üß™ `PdfInvoiceWriterTest.java`

```java
@SpringBootTest
@ExtendWith(SpringExtension.class)
class PdfInvoiceWriterTest {

    @Autowired
    private PdfInvoiceWriter writer;

    @Test
    void shouldWritePdfFilesToOutputDir() throws IOException {
        File tempPdf = File.createTempFile("invoice", ".pdf");
        Files.writeString(tempPdf.toPath(), "test pdf content");

        writer.write(new Chunk<>(List.of(tempPdf)));

        Path writtenFile = Path.of("/tmp/processed/pdf", tempPdf.getName());
        assertTrue(Files.exists(writtenFile));
    }
}
```

---

## ‚úÖ 3. `zipAndUploadStep` ‚Äî Zip + Encrypt Logic

### üß© `ZipAndUploadTasklet.java`

```java
@Slf4j
@Component
public class ZipAndUploadTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {
        try {
            Path processedDir = Path.of("/tmp/processed");
            Path zipFile = Path.of("/tmp/final/invoices.zip");
            Path encryptedFile = Path.of("/tmp/final/invoices.zip.pgp");

            zipDirectory(processedDir, zipFile);
            encryptZip(zipFile, encryptedFile);

            uploadToCOS(encryptedFile);
            log.info("‚úÖ Final encrypted file uploaded to COS");

        } catch (Exception e) {
            log.error("‚ùå Failed to zip/encrypt/upload", e);
            throw new RuntimeException("Failed in zipAndUploadStep", e);
        }

        return RepeatStatus.FINISHED;
    }

    private void zipDirectory(Path sourceDir, Path zipPath) throws IOException {
        Files.createDirectories(zipPath.getParent());
        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()))) {
            Files.walk(sourceDir)
                 .filter(Files::isRegularFile)
                 .forEach(path -> {
                     ZipEntry entry = new ZipEntry(sourceDir.relativize(path).toString());
                     try (InputStream is = Files.newInputStream(path)) {
                         zos.putNextEntry(entry);
                         is.transferTo(zos);
                         zos.closeEntry();
                         log.info("üì¶ Added to zip: {}", path);
                     } catch (IOException e) {
                         throw new UncheckedIOException("Failed to zip file: " + path, e);
                     }
                 });
        }
    }

    private void encryptZip(Path zipPath, Path encryptedPath) throws Exception {
        // Placeholder logic: just rename. Replace with real OpenPGP encryption
        Files.move(zipPath, encryptedPath, StandardCopyOption.REPLACE_EXISTING);
        log.info("üîê Simulated encryption complete: {}", encryptedPath);
    }

    private void uploadToCOS(Path encryptedFile) {
        // COS client logic
        log.info("‚òÅÔ∏è Simulated upload to COS: {}", encryptedFile.getFileName());
    }
}
```

---

### üß© Register as Step in Batch Config

```java
@Bean
public Step zipAndUploadStep(JobRepository jobRepository, PlatformTransactionManager txManager,
                             ZipAndUploadTasklet tasklet) {
    return new StepBuilder("zipAndUploadStep", jobRepository)
            .tasklet(tasklet, txManager)
            .build();
}
```

---

Let me know if you‚Äôd like the real GPG encryption logic and COS client setup next.
