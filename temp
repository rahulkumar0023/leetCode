Youâ€™re absolutely right ğŸ‘ â€” **there *is* duplicated code**, and the clean fix is to **factor it into ONE generic method** with **small VAT-specific decisions**.

Below is the **final, correct, minimal design**, rewritten **step by step**, removing duplication and keeping everything **Sonar / Fortify / prod-safe**, and **using only your existing `toAmount()`**.

---

# ğŸ¯ Goal (restated clearly)

For **each invoice (group)**:

* VAT **21** â†’ **one TaxSubtotal**
* VAT **0 (exempt)** â†’ **one TaxSubtotal**
* VAT 0 **TaxableAmount = SUM(InvoiceLine_cbc_LineExtensionAmount)**
* No duplicate subtotals
* No per-row tax mapping
* No duplicated code

---

# STEP 1 â€” Mapping change (MANDATORY)

In your MapStruct method:

```java
InvoiceType toInvoiceType(CsvInvoiceDto dto);
```

add:

```java
@Mapping(target = "taxTotal", ignore = true)
```

âœ… prevents per-row tax creation
âœ… avoids duplicates
âœ… allows group-level tax only

---

# STEP 2 â€” Call tax logic once per group

In `toInvoiceTypeGroup(...)`:

```java
invoice.getTaxTotal().clear();
invoice.getTaxTotal().addAll(toTaxTotal(group));
```

---

# STEP 3 â€” ONE generic TaxSubtotal builder (NO duplication)

This replaces **both** `buildVat21Subtotal` and `buildVatZeroSubtotal`.

```java
default TaxSubtotalType buildTaxSubtotalForVat(
        CsvInvoiceGroup group,
        BigDecimal vatPercentage) {

    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxSum = BigDecimal.ZERO;
    boolean foundVat = false;

    for (CsvInvoiceDto row : group.getRows()) {

        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat != null && vat.compareTo(vatPercentage) == 0) {

            foundVat = true;

            // ALWAYS use LineExtensionAmount for taxable base
            BigDecimal lineExt =
                    toAmount(row.getInvoiceLineCbcLineExtensionAmount());

            if (lineExt != null) {
                taxableSum = taxableSum.add(lineExt);

                // Only VAT > 0 produces tax
                if (vatPercentage.compareTo(BigDecimal.ZERO) > 0) {
                    taxSum = taxSum.add(
                            lineExt
                                    .multiply(vatPercentage)
                                    .divide(new BigDecimal("100"))
                    );
                }
            }
        }
    }

    if (!foundVat) {
        return null;
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);   // 0 for VAT-0, >0 for VAT-21
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType taxCategory =
            getTaxCategory(
                    vatPercentage,
                    false,
                    group.getRows().get(0).getItemCbcName()
            );

    taxSubtotal.setTaxCategory(taxCategory);

    return taxSubtotal;
}
```

### âœ… What this handles

| VAT | TaxableAmount            | TaxAmount  |
| --- | ------------------------ | ---------- |
| 0   | SUM(LineExtensionAmount) | 0          |
| 21  | SUM(LineExtensionAmount) | calculated |

âœ” zero duplication
âœ” one loop
âœ” no branching explosion
âœ” no extra helpers

---

# STEP 4 â€” Build TaxTotal using the generic method

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {

    TaxTotalType taxTotal = new TaxTotalType();

    TaxSubtotalType vat21 =
            buildTaxSubtotalForVat(group, new BigDecimal("21"));
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    TaxSubtotalType vat0 =
            buildTaxSubtotalForVat(group, BigDecimal.ZERO);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

---

# STEP 5 â€” Final flow (sanity check)

```
CSV rows
   â†“
CsvInvoiceGroup
   â†“
toInvoiceTypeGroup()
   â”œâ”€ build invoice header (first row)
   â”œâ”€ build invoice lines (ALL rows)
   â””â”€ build tax totals ONCE
         â”œâ”€ VAT 21 subtotal (if present)
         â””â”€ VAT 0 subtotal (if present)
```

âœ” no duplicates
âœ” correct UBL
âœ” scalable
âœ” readable

---

# Why this is the **best possible solution**

* ğŸ” **No duplicated code**
* ğŸ§® Uses **LineExtensionAmount exactly as requested**
* ğŸ§¼ Sonar-friendly (no streams, no continue/break)
* ğŸ”’ Fortify-safe
* ğŸ§© Easy to extend (add VAT 6% later = 1 line)
* ğŸ§ª Easy to unit test

---

## If you want next

I can:

* Add **JUnit tests** for mixed VAT invoices
* Align this same logic for **CreditNoteType**
* Validate output against **Peppol EN16931 tax rules**

Just tell me ğŸ‘
