package com.alphacredit.util;

import org.junit.jupiter.api.*;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.junit.jupiter.api.Assertions.*;

class SafeApacheExtractorTest {

    private Path tempZip;
    private Path tempDir;

    @BeforeEach
    void setUp() throws IOException {
        tempDir = Files.createTempDirectory("extractor-test-");
        tempZip = Files.createTempFile("archive-", ".zip");

        // Create a simple ZIP with two entries
        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(tempZip))) {
            zos.putNextEntry(new ZipEntry("invoice1.txt"));
            zos.write("Invoice 1 content".getBytes());
            zos.closeEntry();

            zos.putNextEntry(new ZipEntry("nested/invoice2.txt"));
            zos.write("Nested invoice content".getBytes());
            zos.closeEntry();
        }
    }

    @AfterEach
    void tearDown() throws IOException {
        if (Files.exists(tempZip)) Files.deleteIfExists(tempZip);
        if (Files.exists(tempDir)) {
            Files.walk(tempDir)
                 .sorted((a, b) -> b.compareTo(a))
                 .forEach(p -> p.toFile().delete());
        }
    }

    @Test
    void testExtractSuccessfully() throws Exception {
        SafeApacheExtractor.extract(tempZip, tempDir);

        Path file1 = tempDir.resolve("invoice1.txt");
        Path file2 = tempDir.resolve("nested").resolve("invoice2.txt");

        assertTrue(Files.exists(file1), "invoice1.txt should be extracted");
        assertTrue(Files.exists(file2), "nested/invoice2.txt should be extracted");

        String content = Files.readString(file1).trim();
        assertEquals("Invoice 1 content", content);
    }

    @Test
    void testThrowsForInvalidZipFile() {
        Path fakeZip = tempDir.resolve("not-a-zip.zip");
        Exception ex = assertThrows(IOException.class, () -> SafeApacheExtractor.extract(fakeZip, tempDir));
        assertTrue(ex.getMessage().toLowerCase().contains("zip file"));
    }

    @Test
    void testThrowsForUnsafeEntry() throws IOException {
        Path badZip = Files.createTempFile("bad-", ".zip");
        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(badZip))) {
            zos.putNextEntry(new ZipEntry("../evil.txt"));
            zos.write("malicious".getBytes());
            zos.closeEntry();
        }

        IOException ex = assertThrows(IOException.class, () -> SafeApacheExtractor.extract(badZip, tempDir));
        assertTrue(ex.getMessage().toLowerCase().contains("unsafe") ||
                   ex.getMessage().toLowerCase().contains("escape"));
    }

    @Test
    void testThrowsWhenTargetIsNull() {
        Exception ex = assertThrows(IOException.class, () -> SafeApacheExtractor.extract(tempZip, null));
        assertTrue(ex.getMessage().toLowerCase().contains("invalid"));
    }

    @Test
    void testThrowsWhenZipFileIsNull() {
        Exception ex = assertThrows(IOException.class, () -> SafeApacheExtractor.extract(null, tempDir));
        assertTrue(ex.getMessage().toLowerCase().contains("invalid"));
    }

    @Test
    void testThrowsForTooManyEntries() throws IOException {
        Path largeZip = Files.createTempFile("large-", ".zip");
        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(largeZip))) {
            for (int i = 0; i < 10001; i++) {
                zos.putNextEntry(new ZipEntry("f" + i + ".txt"));
                zos.write("data".getBytes());
                zos.closeEntry();
            }
        }

        IOException ex = assertThrows(IOException.class, () -> SafeApacheExtractor.extract(largeZip, tempDir));
        assertTrue(ex.getMessage().toLowerCase().contains("too many"));
    }
}
