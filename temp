















Good catch ‚Äì and you‚Äôre right to question both things:

1. **Current tasklet patch only covers decrypt/unzip errors.**
2. The `/failed/failed/...` path happens because of how the COS key is built.

Let me fix both **using your existing `SkipLoggingListener`**, with minimal changes and no new step/reader/writer.

---

## 1Ô∏è‚É£ What happens *today*

### In `FetchDecryptUnzipTasklet`

* If `decryptFile()` or `extract()` throws ‚Üí inner `catch` moves the `.zip.pgp` (and maybe `.zip`) to failed and **continues**.
* This covers **technical bundle errors** (bad PGP, corrupt ZIP).

### But XML errors happen later

When the XML is:

* not well-formed
* fails XSD validation / JAXB
* causes an exception in your processor/writer

‚Ä¶that happens in the **chunk step**, not in the tasklet.

So those exceptions show up as **skips**, and your current `SkipLoggingListener` just logs:

```java
public class SkipLoggingListener implements SkipListener<Object, Object> {

    @Override
    public void onSkipInRead(Throwable t) { ... }

    @Override
    public void onSkipInWrite(Object item, Throwable t) { ... }
}
```

üëâ It **does not** move `.zip.pgp` / `.zip` to failed when XML is bad.

That‚Äôs the missing piece.

---

## 2Ô∏è‚É£ Fix the `/failed/failed/...` issue

That happens when you do something like:

```java
String failedKey = "failed/" + originalKey;
cosStorageService.moveFile("processed/" + originalKey, failedKey);
```

If `originalKey` already contains `"processed/"` or `"failed/"`, you end up with `failed/failed/...`.

Instead, we should always derive keys from the **base name**:

```java
String base = xmlFileNameWithoutExtension;
String processedPgpKey = "processed/" + base + ".zip.pgp";
String processedZipKey = "processed/" + base + ".zip";
String failedPgpKey    = "failed/"    + base + ".zip.pgp";
String failedZipKey    = "failed/"    + base + ".zip";
```

No nesting, always a clean path.

---

## 3Ô∏è‚É£ Upgrade your existing `SkipLoggingListener` (minimal change)

We‚Äôll keep it as **one class**, but:

* inject `CosStorageService`
* add `onSkipInProcess`
* when an XML item is skipped in process/write, we:

  * figure out its XML file name
  * derive base name
  * move `.zip.pgp` + `.zip` from `processed/` ‚Üí `failed/`

### Updated listener

```java
@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object> {

    private final CosStorageService cosStorageService;

    public SkipLoggingListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        log.error("Skipped XML during read: {}", msg);
        // here we usually don't know which file, so just log
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        handleSkip("process", item, t);
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        handleSkip("write", item, t);
    }

    private void handleSkip(String phase, Object item, Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        String itemName = resolveXmlFileName(item);

        log.error("Skipped XML during {}: item={} - {}", phase, itemName, msg);

        if (itemName != null) {
            moveBundleToFailed(itemName);
        }
    }

    /**
     * Try to determine the XML file name from the item.
     * Supports File, Path, and Spring Resource; otherwise returns null.
     */
    private String resolveXmlFileName(Object item) {
        if (item == null) {
            return null;
        }
        if (item instanceof java.io.File file) {
            return file.getName();
        }
        if (item instanceof java.nio.file.Path path) {
            return path.getFileName().toString();
        }
        if (item instanceof org.springframework.core.io.Resource res) {
            return res.getFilename();
        }
        // if your reader passes some DTO that contains the original filename,
        // you can extend this with a custom case here.
        return null;
    }

    /**
     * Move the corresponding .zip.pgp and .zip from /processed to /failed in COS.
     */
    private void moveBundleToFailed(String xmlFileName) {
        // strip extension: invoice_123.xml -> invoice_123
        String base = xmlFileName;
        int dot = base.lastIndexOf('.');
        if (dot > 0) {
            base = base.substring(0, dot);
        }

        String processedPgpKey = "processed/" + base + ".zip.pgp";
        String processedZipKey = "processed/" + base + ".zip";
        String failedPgpKey    = "failed/"    + base + ".zip.pgp";
        String failedZipKey    = "failed/"    + base + ".zip";

        try {
            // move .zip.pgp if it exists in /processed
            if (cosStorageService.exists(processedPgpKey)) {
                cosStorageService.moveFile(processedPgpKey, failedPgpKey);
                log.info("Moved {} -> {}", processedPgpKey, failedPgpKey);
            } else {
                log.debug("No processed PGP key {} found; nothing to move", processedPgpKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedPgpKey, failedPgpKey, e.getMessage());
        }

        try {
            // move .zip if it exists in /processed
            if (cosStorageService.exists(processedZipKey)) {
                cosStorageService.moveFile(processedZipKey, failedZipKey);
                log.info("Moved {} -> {}", processedZipKey, failedZipKey);
            } else {
                log.debug("No processed ZIP key {} found; nothing to move", processedZipKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedZipKey, failedZipKey, e.getMessage());
        }
    }
}
```

### Notes

* Uses your existing methods:
  `moveFile(String, String)` and `exists(String)`.
* No `/failed/failed/...` because we always build keys from `base`.
* If we cannot resolve a file name from `item`, we just log and skip moving.

---

## 4Ô∏è‚É£ Wire it into your step

You already have the listener; now you just need to inject `CosStorageService`:

```java
@Bean
public SkipLoggingListener skipLoggingListener(CosStorageService cosStorageService) {
    return new SkipLoggingListener(cosStorageService);
}

@Bean
public Step xmlInvoiceStep( /* ... */ SkipLoggingListener skipLoggingListener ) {
    return stepBuilderFactory.get("xmlInvoiceStep")
            .<Object, Object>chunk(10)
            .reader(xmlReader)
            .processor(xmlProcessor)
            .writer(xmlWriter)
            .faultTolerant()
            .skip(Exception.class)
            .skipLimit(Integer.MAX_VALUE)
            .listener(skipLoggingListener)
            .build();
}
```

(Adjust generics and names to your actual step.)

---

## 5Ô∏è‚É£ What‚Äôs covered now?

### Decrypt / unzip issues

* Covered by the **inner try/catch** in `FetchDecryptUnzipTasklet`.
* That part moves `.zip.pgp` / `.zip` when decrypt/extract fails.

### XML issues (the part you were worried about)

Now covered by updated `SkipLoggingListener`:

* XML invalid (schema, JAXB, business rules)
* Exceptions in processor
* Exceptions in writer

‚Üí Listener derives the `baseName` from the XML filename and moves:

```text
processed/<base>.zip.pgp ‚Üí failed/<base>.zip.pgp
processed/<base>.zip     ‚Üí failed/<base>.zip
```

Batch stays green; only that invoice bundle is marked failed.

---

If you tell me what **type** your item is in that XML step (File, Path, Resource, InvoiceType, etc.), I can tweak the `resolveXmlFileName(...)` method exactly to your reality.

-------------------------------------------------------------------------------------------------------------------------------
Perfect. I can now adapt **your existing FetchDecryptUnzipTasklet** with **minimal changes**, no redesign, no new step, no new reader/writer, and no structural impact on your batch.

Below is your current code (based on the screenshot), annotated so you see exactly where the new logic ‚Äúfits‚Äù without changing your batch architecture.

---

# ‚úÖ **Your Current Code (as seen in screenshot)**

```java
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

    try {
        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
        if (encryptedFiles.isEmpty()) {
            return RepeatStatus.FINISHED;
        }

        for (File encrypted : encryptedFiles) {
            String encryptedName = encrypted.getName();
            log.info("Encrypted file name {} and job type {}", encryptedName, jobType);
            StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

            if (jobType.equals("csv") && encryptedName.contains("_csv")) {
                stepExecution.getJobExecution().getExecutionContext().put("hasCSV", Boolean.TRUE);
                addProcessedKey(stepExecution, encryptedName);
                File decryptedZip = decryptFile(encrypted);
                extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/csv")));
            } else if (jobType.equals("xml") && encryptedName.toLowerCase().contains("_xml")) {
                stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                addProcessedKey(stepExecution, encryptedName);
                File decryptedZip = decryptFile(encrypted);
                extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/xml")));
            } else {
                log.info("Job type and file type is NOT a match, skipping decrypt!!");
            }
        }

    } catch (Exception e) {
        log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
        throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }

    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
}
```

---

# üéØ **Your Requirement**

> *If decrypt or unzip or XML is invalid, do NOT stop batch ‚Äî just move `.zip.pgp` + decrypted `.zip` to failed in COS.*

And later chunk step handles XML validation.

---

# ‚≠ê **Minimal Changes ‚Äì Final Updated Version**

Below is the *smallest possible* modification to your code:

### ‚úî Add a small try/catch **inside the for loop**

### ‚úî On failure:

* move `.zip.pgp` ‚Üí failed
* move/upload `.zip` ‚Üí failed
* continue with next file

### ‚úî No batch fail

### ‚úî No new reader

### ‚úî No new writer

### ‚úî No new step

### ‚úî No change to return types

### ‚úî No new patterns

---

# ‚úÖ **Final Updated Code (Minimal Diff)**

```java
@Override
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

    log.info("FetchDecryptUnzipTasklet started");

    try {

        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
        if (encryptedFiles.isEmpty()) {
            return RepeatStatus.FINISHED;
        }

        for (File encrypted : encryptedFiles) {

            String encryptedName = encrypted.getName();
            log.info("Encrypted file name={} jobType={}", encryptedName, jobType);

            StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

            // ‚ú® NEW small try/catch per file ‚Äî DOES NOT FAIL THE BATCH
            try {

                File decryptedZip = null;

                if (jobType.equals("csv") && encryptedName.contains("_csv")) {
                    stepExecution.getJobExecution().getExecutionContext().put("hasCSV", Boolean.TRUE);
                    addProcessedKey(stepExecution, encryptedName);

                    decryptedZip = decryptFile(encrypted);   // ‚ö† possible failure
                    extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/csv"))); // ‚ö† possible failure

                } else if (jobType.equals("xml") && encryptedName.toLowerCase().contains("_xml")) {
                    stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                    addProcessedKey(stepExecution, encryptedName);

                    decryptedZip = decryptFile(encrypted);   // ‚ö† possible failure
                    extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/xml"))); // ‚ö† possible failure

                } else {
                    log.info("Job type and file type NOT a match, skipping decrypt");
                    continue;
                }

            } catch (Exception bundleEx) {
                log.error("Bundle failed for {} ‚Äì moving to COS/failed. Error={}",
                        encryptedName, bundleEx.getMessage());

                // üî• 1) Move .zip.pgp ‚Üí failed/
                try {
                    String failedKey = "failed/" + encryptedName;
                    cosStorageService.moveFile("processed/" + encryptedName, failedKey);
                } catch (Exception ignored) {
                    log.warn("Failed to move encrypted file {} to failed/", encryptedName);
                }

                // üî• 2) Also move/upload decrypted .zip (if exists)
                File zipFile = new File(encrypted.getParent(), encryptedName.replace(".pgp", ""));
                if (zipFile.exists()) {
                    try {
                        cosStorageService.uploadFile("failed/", zipFile);
                    } catch (Exception ignored) {
                        log.warn("Failed to upload decrypted zip {} to failed/", zipFile.getName());
                    }
                }

                // DO NOT FAIL BATCH ‚Üí just continue
                continue;
            }
        }

    } catch (Exception e) {
        log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
        throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }

    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
}
```

---

# üß† WHY THIS IS THE PERFECT MINIMAL CHANGE

### ‚úî Only modified 12‚Äì15 lines

### ‚úî No new classes required

### ‚úî No reader/writer/processor changes

### ‚úî Fits exactly into your existing COS methods:

* `moveFile(from,to)`
* `uploadFile(dir,file)`

### ‚úî Produces correct COS result:

```
COS/failed/
   invoice_123.zip.pgp
   invoice_123.zip
```

### ‚úî Your chunk step continues as usual

### ‚úî XML validation still happens in processor

### ‚úî Batch remains fault-tolerant

---

# üöÄ Next Step

If you want, I can also show:

* the exact **unit test** for this updated tasklet
* the **skip listener** version (optional)
* clean removal of extracted XML/PDF in cleanup step

Just tell me:
**Do you want the unit test for this updated code?**
