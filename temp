Yes! You can use **Spring Boot Scheduler** to automate and test this entire process in a **new module**. The scheduler will **periodically scan a directory**, process the XML files (zip, encrypt, and upload), and **log success or errors**.

---

## **1Ô∏è‚É£ Steps to Implement the New Module**
1. **Create a new Maven module** in your project.
2. **Move all the existing logic** (zipping, encrypting, and uploading) into this new module.
3. **Create a Spring Boot Scheduler** to run this process **automatically** at intervals.

---

## **2Ô∏è‚É£ Create a New Maven Module**
Inside your project, create a new Maven module:

1. **Go to your root project folder**.
2. Run:
   ```bash
   mvn archetype:generate -DgroupId=com.example.cos -DartifactId=cos-file-processor -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
   ```
3. Add this new module to your **parent `pom.xml`**:
   ```xml
   <modules>
       <module>cos-file-processor</module>
   </modules>
   ```

---

## **3Ô∏è‚É£ Move the Existing Classes to the New Module**
Move your **ZipUtil**, **PGPEncryptor**, and **COSUploader** into `cos-file-processor/src/main/java/com/example/cos/utils/`.

Your module should have this structure:
```
cos-file-processor
‚îÇ‚îÄ‚îÄ src/main/java/com/example/cos/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ZipUtil.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PGPEncryptor.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ COSUploader.java
‚îÇ   ‚îú‚îÄ‚îÄ scheduler/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FileProcessingScheduler.java  <-- Scheduler class (NEW)
‚îÇ   ‚îú‚îÄ‚îÄ FileProcessorApplication.java  <-- Main class
‚îÇ‚îÄ‚îÄ pom.xml
```

---

## **4Ô∏è‚É£ Implement the Spring Scheduler**
Now, create a scheduler to automatically process XML files **every 1 minute**.

#### **`FileProcessingScheduler.java`**
```java
package com.example.cos.scheduler;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.example.cos.utils.COSUploader;
import com.example.cos.utils.PGPEncryptor;
import com.example.cos.utils.ZipUtil;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.file.*;
import java.util.stream.Stream;

@Component
public class FileProcessingScheduler {

    private final String inputDirectory = "/path/to/xml/files"; // Change this path
    private final String publicKeyPath = "/path/to/public-key.asc"; // Change this path
    private final String bucketName = "my-cos-bucket"; // Change this

    private final AmazonS3 s3Client = AmazonS3ClientBuilder.defaultClient();
    private final COSUploader cosUploader = new COSUploader(s3Client, bucketName);

    @Scheduled(fixedRate = 60000)  // Runs every 1 minute
    public void processFiles() {
        System.out.println("üîÑ Checking for new XML files...");

        try (Stream<Path> files = Files.list(Paths.get(inputDirectory))) {
            files.filter(Files::isRegularFile)
                 .filter(path -> path.toString().endsWith(".xml"))
                 .forEach(this::processFile);
        } catch (Exception e) {
            System.err.println("‚ùå Error scanning directory: " + e.getMessage());
        }
    }

    private void processFile(Path filePath) {
        System.out.println("üìÇ Processing file: " + filePath.getFileName());

        try {
            // Step 1: Read XML File as InputStream
            File xmlFile = filePath.toFile();
            InputStream xmlInputStream = new FileInputStream(xmlFile);

            // Step 2: Zip XML Stream
            InputStream zippedInputStream = ZipUtil.zipFile(xmlInputStream, xmlFile.getName());

            // Step 3: Encrypt the Zipped Stream
            InputStream publicKeyInputStream = new FileInputStream(publicKeyPath);
            InputStream encryptedInputStream = PGPEncryptor.encryptStream(zippedInputStream, publicKeyInputStream);

            // Step 4: Upload Encrypted Stream to COS
            cosUploader.uploadStream(encryptedInputStream, "uploads/" + xmlFile.getName() + ".zip.pgp", xmlFile.length());

            System.out.println("‚úÖ Successfully processed and uploaded: " + xmlFile.getName());

            // Optional: Move processed files to an archive folder
            Files.move(filePath, Paths.get(inputDirectory, "archive", filePath.getFileName().toString()), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("üì¶ Moved to archive: " + xmlFile.getName());

        } catch (Exception e) {
            System.err.println("‚ùå Error processing file " + filePath.getFileName() + ": " + e.getMessage());
        }
    }
}
```

---

## **5Ô∏è‚É£ Enable the Scheduler in Spring Boot**
Add `@EnableScheduling` to your **main application class**:

#### **`FileProcessorApplication.java`**
```java
package com.example.cos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class FileProcessorApplication {
    public static void main(String[] args) {
        SpringApplication.run(FileProcessorApplication.class, args);
    }
}
```

---

## **6Ô∏è‚É£ Run the Application**
Now, run the application:
```bash
mvn spring-boot:run
```

### **Expected Output Every 1 Minute**
```
üîÑ Checking for new XML files...
üìÇ Processing file: example.xml
‚úÖ Successfully processed and uploaded: example.xml
üì¶ Moved to archive: example.xml
```

---

## **7Ô∏è‚É£ Test Cases for the Scheduler**
Create **JUnit test cases** for each component:

### **Test 1: Ensure Files Are Picked Up by the Scheduler**
```java
@Test
public void testProcessFiles_SchedulerScansDirectory() throws Exception {
    FileProcessingScheduler scheduler = new FileProcessingScheduler();
    scheduler.processFiles(); // Manually invoke

    // Verify COS upload was called
    verify(mockCosUploader, times(1)).uploadStream(any(), any(), anyLong());
}
```

### **Test 2: Test Zip Streaming**
```java
@Test
public void testZipFileStream() throws Exception {
    InputStream xmlInputStream = new ByteArrayInputStream("<test>data</test>".getBytes());
    InputStream zippedStream = ZipUtil.zipFile(xmlInputStream, "test.xml");

    assertNotNull(zippedStream);
}
```

### **Test 3: Test PGP Encryption**
```java
@Test
public void testEncryptFileStream() throws Exception {
    InputStream xmlInputStream = new ByteArrayInputStream("<test>data</test>".getBytes());
    InputStream zippedStream = ZipUtil.zipFile(xmlInputStream, "test.xml");
    InputStream pubKeyStream = new FileInputStream("/path/to/public-key.asc");

    InputStream encryptedStream = PGPEncryptor.encryptStream(zippedStream, pubKeyStream);
    assertNotNull(encryptedStream);
}
```

### **Test 4: Mock COS Upload**
```java
@Test
public void testUploadToCOS() {
    COSUploader mockUploader = mock(COSUploader.class);
    mockUploader.uploadStream(new ByteArrayInputStream("test".getBytes()), "test.zip.pgp", 100);

    verify(mockUploader, times(1)).uploadStream(any(), any(), anyLong());
}
```

---

## **üéØ Final Summary**
‚úÖ **Modularized** into a separate **Spring Boot module**.  
‚úÖ **Added a Spring Scheduler** to **automatically scan and process XML files** every 1 minute.  
‚úÖ **Implemented Stream-Based Processing** (No temporary files).  
‚úÖ **Archived processed files** after uploading.  
‚úÖ **Added JUnit Test Cases** for each step.  

üöÄ **Now, every new XML file in the directory will be processed, encrypted, and uploaded automatically!** üöÄ

---

### **Next Steps**
- Adjust the **scheduling interval** as needed.
- Deploy the **new module as a microservice**.
- Configure **AWS credentials** in `application.properties` for production.

Let me know if you need any modifications! üöÄüòä
