Perfect üëå ‚Äî let‚Äôs add **JUnit 5** tests for the 3 big changes you just introduced:

1. **Grouping reader** (rows with same `invoiceId` ‚Üí `CsvInvoiceGroup`)
2. **Mapper group methods** (`toInvoiceTypeGroup`, `toCreditNoteTypeGroup`)
3. **Processor** (`CsvGroupToUblProcessor` ‚Üí picks Invoice/CreditNote + marks self-billing)

I‚Äôll keep them lightweight but enough to catch regressions.

---

## 1. GroupingCsvReaderTest

```java
@ExtendWith(MockitoExtension.class)
class GroupingCsvReaderTest {

  @Mock CsvInvoiceReader delegate; // your existing FlatFileItemReader
  GroupingCsvReader reader;

  @BeforeEach
  void init() {
    reader = new GroupingCsvReader(delegate);
  }

  @Test
  void groupsRowsByInvoiceId() throws Exception {
    CsvInvoiceDto r1 = new CsvInvoiceDto(); r1.setInvoiceNumber("INV-1");
    CsvInvoiceDto r2 = new CsvInvoiceDto(); r2.setInvoiceNumber("INV-1");
    CsvInvoiceDto r3 = new CsvInvoiceDto(); r3.setInvoiceNumber("INV-2");

    when(delegate.read())
        .thenReturn(r1)
        .thenReturn(r2)
        .thenReturn(r3)
        .thenReturn(null);

    CsvInvoiceGroup g1 = reader.read();
    assertEquals("INV-1", g1.getInvoiceId());
    assertEquals(2, g1.getRows().size());

    CsvInvoiceGroup g2 = reader.read();
    assertEquals("INV-2", g2.getInvoiceId());
    assertEquals(1, g2.getRows().size());

    assertNull(reader.read()); // end
  }
}
```

---

## 2. CsvInvoiceMapperGroupTest

```java
class CsvInvoiceMapperGroupTest {

  // Use real MapStruct impl
  private final CsvInvoiceMapper mapper = new CsvInvoiceMapperImpl();

  @Test
  void toInvoiceTypeGroup_addsAllLines() {
    CsvInvoiceDto r1 = new CsvInvoiceDto(); r1.setInvoiceNumber("INV-1");
    CsvInvoiceDto r2 = new CsvInvoiceDto(); r2.setInvoiceNumber("INV-1");
    CsvInvoiceGroup group = new CsvInvoiceGroup("INV-1", List.of(r1, r2));

    InvoiceType inv = mapper.toInvoiceTypeGroup(group);

    assertEquals("INV-1", inv.getID().getValue());
    assertEquals(2, inv.getInvoiceLine().size());
  }

  @Test
  void toCreditNoteTypeGroup_addsAllLines() {
    CsvInvoiceDto r1 = new CsvInvoiceDto(); r1.setInvoiceNumber("CN-9");
    CsvInvoiceDto r2 = new CsvInvoiceDto(); r2.setInvoiceNumber("CN-9");
    CsvInvoiceGroup group = new CsvInvoiceGroup("CN-9", List.of(r1, r2));

    CreditNoteType cn = mapper.toCreditNoteTypeGroup(group);

    assertEquals("CN-9", cn.getID().getValue());
    assertEquals(2, cn.getCreditNoteLine().size());
  }
}
```

---

## 3. CsvGroupToUblProcessorTest

```java
@ExtendWith(MockitoExtension.class)
class CsvGroupToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvGroupToUblProcessor processor;

  SelfBillingRegistry registry = new SelfBillingRegistry();

  @BeforeEach
  void injectRegistry() throws Exception {
    Field f = CsvGroupToUblProcessor.class.getDeclaredField("selfBillingRegistry");
    f.setAccessible(true);
    f.set(processor, registry);
  }

  @Test
  void code380_mapsInvoice_notSelfBilling() throws Exception {
    CsvInvoiceDto dto = new CsvInvoiceDto(); dto.setInvoiceTypeCode("380");
    CsvInvoiceGroup group = new CsvInvoiceGroup("INV-1", List.of(dto));

    InvoiceType inv = new InvoiceType();
    when(mapper.toInvoiceTypeGroup(group)).thenReturn(inv);

    Object out = processor.process(group);

    assertSame(inv, out);
    assertFalse(registry.isSelfBilling(inv));
  }

  @Test
  void code381_mapsCreditNote_notSelfBilling() throws Exception {
    CsvInvoiceDto dto = new CsvInvoiceDto(); dto.setInvoiceTypeCode("381");
    CsvInvoiceGroup group = new CsvInvoiceGroup("CN-1", List.of(dto));

    CreditNoteType cn = new CreditNoteType();
    when(mapper.toCreditNoteTypeGroup(group)).thenReturn(cn);

    Object out = processor.process(group);

    assertSame(cn, out);
    assertFalse(registry.isSelfBilling(cn));
  }

  @Test
  void code389_invoice_selfBilling() throws Exception {
    CsvInvoiceDto dto = new CsvInvoiceDto(); dto.setInvoiceTypeCode("389");
    CsvInvoiceGroup group = new CsvInvoiceGroup("INV-SB", List.of(dto));

    InvoiceType inv = new InvoiceType();
    when(mapper.toInvoiceTypeGroup(group)).thenReturn(inv);

    Object out = processor.process(group);

    assertSame(inv, out);
    assertTrue(registry.isSelfBilling(inv));
  }

  @Test
  void code261_creditNote_selfBilling() throws Exception {
    CsvInvoiceDto dto = new CsvInvoiceDto(); dto.setInvoiceTypeCode("261");
    CsvInvoiceGroup group = new CsvInvoiceGroup("CN-SB", List.of(dto));

    CreditNoteType cn = new CreditNoteType();
    when(mapper.toCreditNoteTypeGroup(group)).thenReturn(cn);

    Object out = processor.process(group);

    assertSame(cn, out);
    assertTrue(registry.isSelfBilling(cn));
  }
}
```

---

‚úÖ These tests cover:

* **Reader**: properly groups rows by `invoiceId`.
* **Mapper**: group methods produce one Invoice/CreditNote with multiple lines.
* **Processor**: routes to correct mapper and sets self-billing flag.

---

üëâ Do you want me to also add a **writer test** that proves a self-billing invoice/credit note actually lands under the `sb/` folder (instead of `miles/finance`)?



gpg --import my-public.asc
gpg --import my-private.asc

# Verify
gpg --list-keys
gpg --list-secret-keys

# Encrypt for recipient (public key required)
gpg --output secret.txt.pgp --encrypt --recipient recipient@example.com secret.txt
# Decrypt back into plaintext
gpg --output secret.txt --decrypt secret.txt.pgp




Exactly üëç ‚Äî you‚Äôve already done the hard part once: your CsvInvoiceMapper maps those 78+ flat CSV columns into all the header-level fields of a InvoiceType (or CreditNoteType): supplier, customer, amounts, tax totals, references, etc.

When you move to grouping, the good news is:
	‚Ä¢	Header-level fields (those 78 columns that are per-invoice) still map once, using any of the rows in the group (they all have the same invoiceId).
	‚Ä¢	Line-level fields (quantity, description, price, etc.) need to be mapped for each row, and accumulated into the invoice‚Äôs InvoiceLine or CreditNoteLine.

‚∏ª

How to reuse your existing mapper with 78+ columns
	1.	Split responsibilities:
	‚Ä¢	Keep a method that maps a single CsvInvoiceDto into all header fields of InvoiceType.
	‚Ä¢	Keep/reuse your existing line mapper (CsvInvoiceDto ‚Üí InvoiceLineType).
	2.	Create a new group-level mapping:
	‚Ä¢	Take the CsvInvoiceGroup (rows with the same invoiceId).
	‚Ä¢	Use the first row (or any, since headers are duplicated) to fill in the header fields.
	‚Ä¢	Collect all rows ‚Üí InvoiceLineType list.

‚∏ª

Mapper sketch

@Mapper(componentModel = "spring", builder = @Builder(disableBuilder = true))
public interface CsvInvoiceMapper {

    // --- 1) Existing row ‚Üí header mapping (78+ columns used here)
    @Mapping(target = "ID", expression = "java(toID(dto.getInvoiceNumber()))")
    @Mapping(target = "AccountingSupplierParty", expression = "java(toSupplier(dto))")
    @Mapping(target = "AccountingCustomerParty", expression = "java(toCustomer(dto))")
    @Mapping(target = "TaxTotal", expression = "java(toTaxTotal(dto))")
    @Mapping(target = "LegalMonetaryTotal", expression = "java(toTotals(dto))")
    // ... and the rest of your 78 column mappings
    InvoiceType toInvoiceHeader(CsvInvoiceDto dto);

    // --- 2) Row ‚Üí line (just line-level columns)
    default InvoiceLineType toInvoiceLine(CsvInvoiceDto dto) {
        InvoiceLineType line = new InvoiceLineType();
        // map lineId, quantity, price, description, tax per line, etc.
        return line;
    }

    // --- 3) Group ‚Üí InvoiceType
    default InvoiceType toInvoiceType(CsvInvoiceGroup group) {
        // use first row for header fields
        CsvInvoiceDto first = group.getRows().get(0);
        InvoiceType invoice = toInvoiceHeader(first);

        // collect all lines
        List<InvoiceLineType> lines = new ArrayList<>();
        for (CsvInvoiceDto row : group.getRows()) {
            lines.add(toInvoiceLine(row));
        }
        invoice.getInvoiceLine().addAll(lines);

        return invoice;
    }

    // helper for ID
    default IDType toID(String value) {
        IDType id = new IDType();
        id.setValue(value);
        return id;
    }
}


‚∏ª

Credit notes (same principle)

default CreditNoteType toCreditNoteType(CsvInvoiceGroup group) {
    CsvInvoiceDto first = group.getRows().get(0);
    CreditNoteType credit = toCreditNoteHeader(first);

    List<CreditNoteLineType> lines = new ArrayList<>();
    for (CsvInvoiceDto row : group.getRows()) {
        lines.add(toCreditNoteLine(row));
    }
    credit.getCreditNoteLine().addAll(lines);

    return credit;
}


‚∏ª

‚úÖ Why this works
	‚Ä¢	You don‚Äôt duplicate 78 mappings: you still map a single row to headers.
	‚Ä¢	You simply change the entry point: instead of mapping a row, you map a group, and delegate to the existing header and line mappers.
	‚Ä¢	All the per-invoice fields (currency, totals, parties, etc.) come from the first row, so they‚Äôre consistent.
	‚Ä¢	All the per-line fields (price, qty, item) come from every row.

‚∏ª

üëâ Do you want me to draft the exact update to your current CsvInvoiceMapper so it has both the ‚Äúrow ‚Üí header‚Äù mapping (with all 78 fields) and the ‚Äúgroup ‚Üí invoice‚Äù wrapper, so you can drop it straight in without rewriting those 78 lines?









That‚Äôs a great detail üëç ‚Äî your current `CsvInvoiceReader` is already doing the **low-level CSV parsing** (`DelimitedLineTokenizer`, `SmartCsvInvoiceFieldSetMapper`, etc.). You don‚Äôt need to throw that away.

üëâ The trick is: keep your existing `CsvInvoiceReader` *as-is* (so you still get 1 `CsvInvoiceDto` per row), and **wrap it** in a ‚Äúgrouping reader‚Äù that combines consecutive rows with the same `invoiceId`.

---

## How it looks

```
CsvInvoiceReader (your class)
        ‚Üì  (1 CsvInvoiceDto per row)
GroupingCsvReader (new wrapper)
        ‚Üì  (CsvInvoiceGroup per invoiceId)
Processor (CsvInvoiceGroup ‚Üí InvoiceType with many lines)
        ‚Üì
XML Writer
```

---

## 1. Grouping wrapper around your reader

```java
@Component
@StepScope
public class GroupingCsvReader implements ItemReader<CsvInvoiceGroup>, ResourceAwareItemReaderItemStream<CsvInvoiceGroup> {

    private final CsvInvoiceReader delegate; // your existing reader
    private CsvInvoiceDto buffer;
    private Resource resource;

    public GroupingCsvReader(CsvInvoiceReader delegate) {
        this.delegate = delegate;
    }

    @Override
    public void setResource(Resource resource) {
        this.resource = resource;
        delegate.setResource(resource); // forward to your current reader
    }

    @Override
    public CsvInvoiceGroup read() throws Exception {
        List<CsvInvoiceDto> group = new ArrayList<>();
        CsvInvoiceDto first = (buffer != null) ? buffer : delegate.read();
        buffer = null;
        if (first == null) return null;

        String invoiceId = first.getInvoiceNumber();
        group.add(first);

        CsvInvoiceDto next;
        while ((next = delegate.read()) != null) {
            if (!invoiceId.equals(next.getInvoiceNumber())) {
                buffer = next; // save for next call
                break;
            }
            group.add(next);
        }

        return new CsvInvoiceGroup(invoiceId, group);
    }

    @Override
    public void open(ExecutionContext executionContext) throws ItemStreamException {
        delegate.open(executionContext);
    }

    @Override
    public void update(ExecutionContext executionContext) throws ItemStreamException {
        delegate.update(executionContext);
    }

    @Override
    public void close() throws ItemStreamException {
        delegate.close();
    }
}
```

---

## 2. CsvInvoiceGroup DTO

```java
@Data
@AllArgsConstructor
public class CsvInvoiceGroup {
    private String invoiceId;
    private List<CsvInvoiceDto> rows;
}
```

---

## 3. Processor: group ‚Üí InvoiceType

```java
@Component
@RequiredArgsConstructor
public class CsvGroupToInvoiceProcessor implements ItemProcessor<CsvInvoiceGroup, InvoiceType> {

    private final CsvInvoiceMapper mapper;

    @Override
    public InvoiceType process(CsvInvoiceGroup group) {
        return mapper.toInvoiceType(group);
    }
}
```

---

## 4. Mapper update

```java
@Mapper(componentModel = "spring")
public interface CsvInvoiceMapper {

    @Mapping(target = "ID", expression = "java(toID(group.getInvoiceId()))")
    @Mapping(target = "invoiceLine", expression = "java(toInvoiceLines(group.getRows()))")
    InvoiceType toInvoiceType(CsvInvoiceGroup group);

    default List<InvoiceLineType> toInvoiceLines(List<CsvInvoiceDto> rows) {
        List<InvoiceLineType> lines = new ArrayList<>();
        for (CsvInvoiceDto row : rows) {
            InvoiceLineType line = new InvoiceLineType();
            // map row ‚Üí line fields here
            lines.add(line);
        }
        return lines;
    }

    default IDType toID(String id) {
        IDType t = new IDType();
        t.setValue(id);
        return t;
    }
}
```

---

## 5. Step wiring

Instead of wiring your old `CsvInvoiceReader` directly:

```java
@Bean
public Step csvToXmlStep(GroupingCsvReader reader,
                         CsvGroupToInvoiceProcessor processor,
                         XMLInvoiceWriter writer) {
    return stepBuilderFactory.get("csvToXmlStep")
        .<CsvInvoiceGroup, InvoiceType>chunk(50)
        .reader(reader)
        .processor(processor)
        .writer(writer)
        .build();
}
```

---

‚úÖ This way you don‚Äôt lose your tokenizer/line-mapper logic ‚Äî your `CsvInvoiceReader` still produces `CsvInvoiceDto` per row.
‚úÖ The wrapper groups them into invoices before mapping.
‚úÖ One invoice ID = one XML with multiple `<InvoiceLine>` entries.

---

Do you want me to also show the **CreditNote variant** (same grouping, but `CreditNoteLineType` instead of `InvoiceLineType`), since you‚Äôve already got `InvoiceTypeCode` deciding between the two?
