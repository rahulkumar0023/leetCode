To see what the backend (Spring Boot) receives from Keycloak, you can log and inspect the JWT token and its claims in the backend. Here's how you can do this step by step:

---

### **1. Log Incoming JWT Token**

Add a custom filter or directly log the `Authorization` header and the JWT token sent to your backend.

#### **Custom Logging Filter**

Create a `OncePerRequestFilter` to log the JWT token and its claims:

```java
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Base64;

public class JwtLoggingFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        // Get the Authorization header
        String authorizationHeader = request.getHeader("Authorization");

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            // Extract the token from the header
            String jwtToken = authorizationHeader.substring(7);
            System.out.println("JWT Token: " + jwtToken);

            // Decode the JWT token to inspect its contents (Header and Payload)
            String[] tokenParts = jwtToken.split("\\.");
            if (tokenParts.length == 3) {
                String header = new String(Base64.getDecoder().decode(tokenParts[0]));
                String payload = new String(Base64.getDecoder().decode(tokenParts[1]));
                System.out.println("JWT Header: " + header);
                System.out.println("JWT Payload: " + payload);
            } else {
                System.out.println("Invalid JWT format.");
            }
        } else {
            System.out.println("No JWT token found in the request.");
        }

        // Continue the filter chain
        filterChain.doFilter(request, response);
    }
}
```

#### **Register the Filter**

Update your `SecurityConfig` to add this filter:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/public/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .oauth2ResourceServer().jwt();

        // Add custom logging filter
        http.addFilterBefore(new JwtLoggingFilter(), org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

---

### **2. Decode the JWT Claims**

The `JwtLoggingFilter` logs the token's **header** and **payload**, but Spring Security can automatically decode and map the claims into a `Jwt` object for you.

#### Use `Jwt` Object in Controller

You can directly inject the decoded `Jwt` object into a controller method:

```java
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class JwtController {

    @GetMapping("/secured")
    public String securedEndpoint(Jwt jwt) {
        // Log the claims received in the JWT
        System.out.println("JWT Claims: " + jwt.getClaims());
        System.out.println("Subject: " + jwt.getSubject());
        System.out.println("Issuer: " + jwt.getIssuer());
        System.out.println("Roles: " + jwt.getClaim("realm_access"));
        return "Secured endpoint accessed!";
    }
}
```

This logs all claims in the JWT (e.g., `iss`, `sub`, `aud`, `exp`, roles, etc.) and allows you to process them.

---

### **3. Enable Debug Logs for Spring Security**

To see how Spring Security processes the token, enable debug logging by adding the following to `application.yaml`:

```yaml
logging:
  level:
    org.springframework.security: DEBUG
    org.springframework.security.oauth2: DEBUG
```

This will log detailed information about the incoming token, including validation and mapping.

---

### **4. Test the Endpoint**

1. **Get a JWT Token from Keycloak:**

Use the following command to get a token from Keycloak's token endpoint:

```bash
curl --location --request POST 'http://localhost:8180/realms/my-realm/protocol/openid-connect/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=password' \
--data-urlencode 'client_id=my-client' \
--data-urlencode 'username=<your-username>' \
--data-urlencode 'password=<your-password>'
```

The response will include a JWT token:

```json
{
  "access_token": "<JWT-TOKEN>",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "token_type": "Bearer",
  "scope": "openid email profile",
  ...
}
```

2. **Send a Request to the Backend:**

Use the token to call the secured endpoint:

```bash
curl --location --request GET 'http://localhost:8080/api/secured' \
--header 'Authorization: Bearer <JWT-TOKEN>'
```

3. **Inspect the Logs:**

You’ll see the decoded JWT token in the logs:
- **Header**: Contains metadata such as the signing algorithm.
- **Payload**: Contains claims like `sub` (subject), `roles`, `iss` (issuer), `aud` (audience), etc.

---

### **Example Logs**

Here’s what the backend might log for a valid JWT:

#### Raw Token
```
JWT Token: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMSIsInJvbGVzIjpbIlVTRVIiLCJBRE1JTiJdLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgxODAvcmVhbG1zL215LXJlYWxtIiwiZXhwIjoxNjY1MjYzMjAwLCJhdWQiOiJteS1jbGllbnQifQ.Q1u9H...
```

#### Decoded Header
```json
{
  "alg": "RS256",
  "typ": "JWT"
}
```

#### Decoded Payload
```json
{
  "sub": "user1",
  "roles": ["USER", "ADMIN"],
  "iss": "http://localhost:8180/realms/my-realm",
  "exp": 1665263200,
  "aud": "my-client"
}
```

#### Claims in Logs
```
JWT Claims: {sub=user1, roles=[USER, ADMIN], iss=http://localhost:8180/realms/my-realm, exp=1665263200, aud=my-client}
Subject: user1
Issuer: http://localhost:8180/realms/my-realm
Roles: {roles=[USER, ADMIN]}
```

---

### **5. Common Issues**

1. **Missing Authorization Header**:
   Ensure that the frontend (or client) sends the `Authorization: Bearer <JWT>` header.

2. **Invalid Token**:
   Check Keycloak's configuration to ensure the token is valid. Verify the `iss` and `aud` claims match the backend's configuration.

3. **Expired Token**:
   The token's `exp` claim might have passed. Obtain a new token from Keycloak.

---

With this setup, you can log and inspect the JWT being sent from Keycloak to your Spring Boot backend. Let me know if you need help debugging specific issues!
