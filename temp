Yes üíØ ‚Äî that‚Äôs exactly what you want:
‚úÖ record only the keys you touched (fetched/uploaded),
‚úÖ then in `CosProcessedCleanupListener` delete *only* those keys.

Here‚Äôs a **step-by-step implementation** using a small **helper interface** that both tasklets + listener can reuse.

---

## Step 1 ‚Äì Create a shared helper interface for the ExecutionContext

This gives you reusable default methods to add/get keys from the **job** `ExecutionContext`.

```java
package com.yourcompany.batch.cos;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.item.ExecutionContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public interface CosProcessedContextSupport {

    String PROCESSED_COS_KEYS = "processedCosKeys";

    @SuppressWarnings("unchecked")
    default void addProcessedKey(StepExecution stepExecution, String key) {
        JobExecution jobExecution = stepExecution.getJobExecution();
        ExecutionContext jobContext = jobExecution.getExecutionContext();

        List<String> keys = (List<String>) jobContext.get(PROCESSED_COS_KEYS);
        if (keys == null) {
            keys = new ArrayList<>();
        }

        keys.add(key);

        // ‚≠ê IMPORTANT: re-put so Spring Batch marks context as dirty
        jobContext.put(PROCESSED_COS_KEYS, keys);
    }

    @SuppressWarnings("unchecked")
    default List<String> getProcessedKeys(JobExecution jobExecution) {
        ExecutionContext jobContext = jobExecution.getExecutionContext();
        List<String> keys = (List<String>) jobContext.get(PROCESSED_COS_KEYS);
        if (keys == null) {
            return Collections.emptyList();
        }
        return keys;
    }
}
```

You‚Äôll use `addProcessedKey(...)` in **fetch** + **upload** tasklets, and `getProcessedKeys(...)` in the cleanup listener.

---

## Step 2 ‚Äì Fetch tasklet: record fetched/moved encrypted files

Assume you have something like:

```java
@Component
public class FetchEncryptedFilesTasklet implements Tasklet, CosProcessedContextSupport {

    private final CosService cosService;

    public FetchEncryptedFilesTasklet(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution,
                                ChunkContext chunkContext) throws Exception {

        StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();

        // Example: fetch and move to /processed
        List<String> incomingKeys = cosService.listIncomingEncryptedFiles(); 
        for (String key : incomingKeys) {
            // e.g. key = "incoming/myfile1.csv.zip.pgp"
            String processedKey = cosService.moveToProcessed(key); 
            // e.g. processedKey = "processed/incoming/myfile1.csv.zip.pgp"

            // üîπ Record this processed COS key in the job context
            addProcessedKey(stepExecution, processedKey);
        }

        return RepeatStatus.FINISHED;
    }
}
```

So now every encrypted file moved into `/processed/...` from this tasklet will be remembered.

---

## Step 3 ‚Äì Upload tasklet: also register outgoing files

Same pattern for outgoing/upload step.

```java
@Component
public class UploadFilesToCosTasklet implements Tasklet, CosProcessedContextSupport {

    private final CosService cosService;

    public UploadFilesToCosTasklet(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution,
                                ChunkContext chunkContext) throws Exception {

        StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();

        // Example: upload generated XML/zip/pgp to outgoing/processed
        List<File> filesToUpload = getFilesFromLocalDir(); // your logic

        for (File file : filesToUpload) {
            String processedKey = cosService.uploadToProcessed(file);
            // e.g. "processed/outgoing/invoice_123.xml.zip.pgp"

            // üîπ Record processed key
            addProcessedKey(stepExecution, processedKey);
        }

        return RepeatStatus.FINISHED;
    }
}
```

Now both **incoming** and **outgoing** processed objects are tracked in the **same** list in the job `ExecutionContext`.

---

## Step 4 ‚Äì Implement `CosProcessedCleanupListener` that deletes only recorded keys

This listener runs *after the job* and deletes only the objects that were registered.

```java
package com.yourcompany.batch.cos;

import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class CosProcessedCleanupListener implements JobExecutionListener, CosProcessedContextSupport {

    private final CosService cosService;

    public CosProcessedCleanupListener(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // nothing
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        BatchStatus status = jobExecution.getStatus();

        // ‚ùå If job failed, do NOT clean processed
        if (status != BatchStatus.COMPLETED) {
            // keep all processed files for investigation
            return;
        }

        // ‚úÖ Only on COMPLETED, get recorded keys from job context
        List<String> processedKeys = getProcessedKeys(jobExecution);

        if (processedKeys.isEmpty()) {
            // This is the ‚Äúno file in COS‚Äù case --> nothing to delete, directory stays
            return;
        }

        for (String key : processedKeys) {
            try {
                cosService.deleteObject(key);  // only delete these keys
            } catch (Exception e) {
                // You can ignore "not found" errors if desired
                // or just log and continue
            }
        }
    }
}
```

**Behavior now:**

* **Job COMPLETED + some files processed**
  ‚Üí only those recorded keys under `/processed/...` are deleted.

* **Job FAILED / STOPPED**
  ‚Üí cleanup is skipped; `/processed` and all keys stay.

* **Job COMPLETED + no files in bucket** (your edge case)
  ‚Üí `processedKeys` is empty ‚Üí `afterJob` deletes nothing; `/processed` directory is preserved.

So you no longer rely on deleting ‚Äúthe entire `/processed` directory‚Äù, only the *objects* you recorded.

---

## Step 5 ‚Äì Wire the listener into the job

In your `Job` config:

```java
@Bean
public Job myCosJob(JobRepository jobRepository,
                    Step fetchStep,
                    Step uploadStep,
                    CosProcessedCleanupListener cosProcessedCleanupListener) {

    return new JobBuilder("myCosJob", jobRepository)
            .listener(cosProcessedCleanupListener)
            .start(fetchStep)
            .next(uploadStep)
            // ... other steps ...
            .build();
}
```

And make sure the steps use your tasklets that implement `CosProcessedContextSupport`.

---

If you want, you can paste your actual `CosService` and step definitions, and I can plug these pieces directly into your existing code with the exact method names you‚Äôre using.
