private void unzipFile(File zipFile, Path targetDir) throws IOException {
    // Validate zipFile input
    if (!zipFile.exists() || !zipFile.isFile() || !zipFile.canRead()) {
        throw new IOException("Invalid zip file: " + zipFile);
    }

    // Ensure target directory exists
    Files.createDirectories(targetDir);
    File targetDirFile = targetDir.toFile();
    String canonicalTarget = targetDirFile.getCanonicalPath();

    log.info("Unzipping: {}", zipFile.getCanonicalPath());
    log.info("Target directory: {}", canonicalTarget);

    final int    THRESHOLD_ENTRIES   = 10_000;
    final long   THRESHOLD_SIZE      = 1_000_000_000L;
    final double THRESHOLD_RATIO     = 10.0;

    int  entryCount        = 0;
    long totalUncompressed = 0;

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
        ZipEntry entry;
        byte[] buffer = new byte[2048];

        while ((entry = zis.getNextEntry()) != null) {
            // Build a safe File path for this entry
            File outFile = buildSafeFile(targetDirFile, entry);

            if (entry.isDirectory()) {
                if (!outFile.isDirectory() && !outFile.mkdirs()) {
                    throw new IOException("Failed to create directory: " + outFile);
                }
                continue;
            }

            // Ensure parent directory exists
            File parent = outFile.getParentFile();
            if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
                throw new IOException("Failed to create directory: " + parent);
            }

            // Extract file with anti-bomb checks
            try (OutputStream os = new BufferedOutputStream(new FileOutputStream(outFile))) {
                int bytesRead;
                long entrySize = 0;
                long compressedSize = entry.getCompressedSize();

                while ((bytesRead = zis.read(buffer)) > 0) {
                    os.write(buffer, 0, bytesRead);
                    entrySize      += bytesRead;
                    totalUncompressed += bytesRead;

                    // Zip bomb ratio check
                    if (compressedSize > 0) {
                        double ratio = (double) entrySize / compressedSize;
                        if (ratio > THRESHOLD_RATIO) {
                            throw new IOException("Zip bomb detected (ratio > " + THRESHOLD_RATIO + ")");
                        }
                    } else if (compressedSize == -1 && entrySize > THRESHOLD_SIZE / 10) {
                        throw new IOException("Entry size suspicious (compressed size unknown)");
                    }

                    // Total size check
                    if (totalUncompressed > THRESHOLD_SIZE) {
                        throw new IOException("Archive too large (>" + THRESHOLD_SIZE + " bytes)");
                    }
                }
            }

            entryCount++;
            if (entryCount > THRESHOLD_ENTRIES) {
                throw new IOException("Too many entries in archive (" + entryCount + ")");
            }

            zis.closeEntry();
        }
    }

    log.info("âœ… Unzip completed: {} entries, {} bytes extracted", entryCount, totalUncompressed);
}

/**
 * Constructs a safe File for a ZipEntry by validating each path segment.
 * Avoids resolve() and normalize().
 */
private File buildSafeFile(File targetDir, ZipEntry entry) throws IOException {
    String name = entry.getName();
    if (name == null || name.isEmpty()) {
        throw new IOException("Invalid entry name");
    }

    // Reject dangerous characters
    if (name.indexOf('\u0000') >= 0 ||
        name.contains("..") ||
        name.startsWith("/") ||
        name.startsWith("\\") ||
        name.contains(":")) {
        throw new IOException("Invalid entry name: " + name);
    }

    // Normalize separators and trim leading slashes
    String sanitized = name.replace('\\', '/');
    while (sanitized.startsWith("/")) {
        sanitized = sanitized.substring(1);
    }

    // Validate whitelist of characters (alphanumeric, underscore, hyphen, dot, space, slash)
    if (!sanitized.matches("^[a-zA-Z0-9._\\- /]+$")) {
        throw new IOException("Illegal characters in entry name: " + name);
    }

    // Split into segments and validate each
    String[] segments = sanitized.split("/");
    File current = targetDir;

    for (String segment : segments) {
        if (segment.isEmpty()) {
            continue;
        }
        // Reject traversal or hidden segments if undesired
        if (segment.equals(".") || segment.equals("..")) {
            throw new IOException("Path traversal detected in entry name: " + name);
        }
        // Append to current path
        current = new File(current, segment);
    }

    // Final canonical check to ensure still inside targetDir
    String canonicalTarget = targetDir.getCanonicalPath();
    String canonicalOut    = current.getCanonicalPath();
    if (!canonicalOut.startsWith(canonicalTarget + File.separator) &&
        !canonicalOut.equals(canonicalTarget)) {
        throw new IOException("Entry is outside target dir: " + name);
    }

    return current;
}
