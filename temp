perfect — since your tasklet now has CosStorageService and PDPDecrypt fields, here’s a drop-in JUnit 5 test that mocks both, injects them via reflection, and fully covers the two helpers you showed (decryptFile and unzipFile) including the zip-slip guard.

Package paths/names match your screenshots; adjust if yours differ (e.g., …batch.tasklet).
Replace the imports of PDPDecrypt / CosStorageService with your actual types.

⸻

src/test/java/com/bnpp/pf/einvoice/connect/batch/tasklet/FetchDecryptUnzipTaskletTest.java

package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.cos.CosStorageService;   // <-- adjust if package differs
import com.bnpp.pf.einvoice.connect.pgp.PDPDecrypt;          // <-- adjust if package differs
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

class FetchDecryptUnzipTaskletTest {

  // ---- helpers --------------------------------------------------------------

  private FetchDecryptUnzipTasklet newTasklet(PDPDecrypt pdpDecrypt, CosStorageService cos) throws Exception {
    var t = new FetchDecryptUnzipTasklet();

    if (pdpDecrypt != null) {
      Field f = FetchDecryptUnzipTasklet.class.getDeclaredField("pdpDecrypt"); // exact field name in your class
      f.setAccessible(true);
      f.set(t, pdpDecrypt);
    }
    if (cos != null) {
      Field f = FetchDecryptUnzipTasklet.class.getDeclaredField("cosStorageService"); // exact field name
      f.setAccessible(true);
      f.set(t, cos);
    }
    return t;
  }

  private static Method privateMethod(String name, Class<?>... sig) throws Exception {
    Method m = FetchDecryptUnzipTasklet.class.getDeclaredMethod(name, sig);
    m.setAccessible(true);
    return m;
  }

  // ---- decryptFile ----------------------------------------------------------

  @Test
  void decryptFile_usesPdpDecrypt_andStripsPgpSuffix(@TempDir Path tmp) throws Exception {
    // Given an encrypted .pgp file
    Path encrypted = tmp.resolve("batch_2025.csv.pgp");
    Files.writeString(encrypted, "ciphertext", StandardCharsets.UTF_8);

    // PDPDecrypt mock: copy bytes from in -> out
    PDPDecrypt pdp = mock(PDPDecrypt.class);
    doAnswer(inv -> {
      try (InputStream in = inv.getArgument(0); OutputStream out = inv.getArgument(1)) {
        in.transferTo(out);
      }
      return null;
    }).when(pdp).decrypt(any(InputStream.class), any(OutputStream.class));

    FetchDecryptUnzipTasklet tasklet = newTasklet(pdp, mock(CosStorageService.class));

    // When calling private decryptFile(File)
    File decrypted = (File) privateMethod("decryptFile", File.class)
        .invoke(tasklet, encrypted.toFile());

    // Then output file has .pgp removed and bytes are written
    assertThat(decrypted.getName()).isEqualTo("batch_2025.csv");
    assertThat(Files.readString(decrypted.toPath())).isEqualTo("ciphertext");
    verify(pdp, times(1)).decrypt(any(InputStream.class), any(OutputStream.class));
  }

  // ---- unzipFile ------------------------------------------------------------

  @Test
  void unzipFile_extractsDirsAndFiles(@TempDir Path tmp) throws Exception {
    // Create a zip with a dir entry and a nested file
    Path zip = tmp.resolve("payload.zip");
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
      zos.putNextEntry(new ZipEntry("dir/"));
      zos.closeEntry();
      zos.putNextEntry(new ZipEntry("dir/sub/data.txt"));
      zos.write("hello".getBytes(StandardCharsets.UTF_8));
      zos.closeEntry();
    }

    FetchDecryptUnzipTasklet tasklet = newTasklet(mock(PDPDecrypt.class), mock(CosStorageService.class));
    Path target = tmp.resolve("unzipped");

    privateMethod("unzipFile", File.class, Path.class).invoke(tasklet, zip.toFile(), target);

    assertThat(Files.isDirectory(target.resolve("dir/sub"))).isTrue();
    assertThat(Files.readString(target.resolve("dir/sub/data.txt"))).isEqualTo("hello");
  }

  @Test
  void unzipFile_blocksZipSlip(@TempDir Path tmp) throws Exception {
    // Zip with a malicious entry ../evil.txt
    Path zip = tmp.resolve("slip.zip");
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
      zos.putNextEntry(new ZipEntry("../evil.txt"));
      zos.write("bad".getBytes(StandardCharsets.UTF_8));
      zos.closeEntry();
    }

    FetchDecryptUnzipTasklet tasklet = newTasklet(mock(PDPDecrypt.class), mock(CosStorageService.class));
    Path target = tmp.resolve("unzipped");

    assertThatThrownBy(() -> privateMethod("unzipFile", File.class, Path.class)
        .invoke(tasklet, zip.toFile(), target))
        .hasCauseInstanceOf(IOException.class)  // thrown inside unzipFile
        .hasMessageContaining("InvocationTargetException"); // reflection wrapper
  }

  @Test
  void unzipFile_createsTargetDirectory_whenMissing(@TempDir Path tmp) throws Exception {
    // Minimal zip with one file at root
    Path zip = tmp.resolve("one.zip");
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
      zos.putNextEntry(new ZipEntry("a.txt"));
      zos.write("x".getBytes(StandardCharsets.UTF_8));
      zos.closeEntry();
    }

    FetchDecryptUnzipTasklet tasklet = newTasklet(mock(PDPDecrypt.class), mock(CosStorageService.class));
    Path target = tmp.resolve("brandNewDir"); // doesn't exist yet

    privateMethod("unzipFile", File.class, Path.class).invoke(tasklet, zip.toFile(), target);

    assertThat(Files.exists(target)).isTrue();
    assertThat(Files.readString(target.resolve("a.txt"))).isEqualTo("x");
  }
}

Notes
	•	Injection: we set both pdpDecrypt and cosStorageService via reflection so the tasklet is “fully wired” without Spring. If your field names differ, change them in newTasklet(...).
	•	PDPDecrypt: the mock implements decrypt(InputStream, OutputStream); if your method signature differs (e.g., additional params), tweak the doAnswer accordingly.
	•	CosStorageService: not used in these private helpers, but we still inject a mock so construction mirrors production.
	•	We invoke the private methods with reflection to keep tests fast and isolated. If you prefer, you can expose package-private helpers instead and drop reflection.

These four tests cover:
	•	decryption happy path (+ .pgp suffix removal)
	•	unzip happy path (dir & nested file)
	•	zip-slip rejection branch
	•	creation of a missing target directory

Add them, run your suite, and this class should flip from near-zero to solid green. If you want, we can also add a negative test where PDPDecrypt.decrypt throws (to cover your catch/log branch if present in the caller).
