StepExecution se = new StepExecution("fetchDecryptUnzip", new JobExecution(123L));
tasklet.beforeStep(se); // <-- IMPORTANT

StepContribution c = new StepContribution(se);
ChunkContext ctx = new ChunkContext(new StepContext(se));
RepeatStatus rs = tasklet.execute(c, ctx);




awesome—let’s parameterize the unzip base directory with @Value and make both prod + tests happy.

1) Update the tasklet (inject + use the base dir)

// imports
import org.springframework.beans.factory.annotation.Value;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.Files;
import java.util.Locale;

// ...
@Component
@Slf4j
public class FetchDecryptUnzipTasklet implements Tasklet, StepExecutionListener {

  @Value("${einvoice.unzip.base-dir:#{systemProperties['java.io.tmpdir']}/unzipped}")
  private String unzipBaseDir;   // e.g. /tmp/unzipped by default

  // ...

  @Override
  public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {
    log.info("FetchDecryptUnzipTasklet started");
    try {
      // ensure base + subdirs exist up-front
      Path base  = Paths.get(unzipBaseDir);
      Path csvDir = base.resolve("csv");
      Path xmlDir = base.resolve("xml");
      Files.createDirectories(csvDir);
      Files.createDirectories(xmlDir);

      var stepExecution = chunkContext.getStepContext().getStepExecution();

      List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles();
      if (encryptedFiles == null || encryptedFiles.isEmpty()) {
        return RepeatStatus.FINISHED;
      }

      for (File encrypted : encryptedFiles) {
        log.info("Encrypted file name {} and job type : {}", encrypted.getName(), jobType);
        String name = encrypted.getName().toLowerCase(Locale.ROOT);

        if ("csv".equals(jobType) && name.contains("_csv")) {
          stepExecution.getJobExecution().getExecutionContext().put("hasCsv", Boolean.TRUE);
          File decryptedZip = decryptFile(encrypted);
          unzipFile(decryptedZip, csvDir);
        } else if ("xml".equals(jobType) && name.contains("_xml")) {
          stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
          File decryptedZip = decryptFile(encrypted);
          unzipFile(decryptedZip, xmlDir);
        } else {
          log.info("Job type and file type is NOT a match, skipping decrypt!!");
        }
      }
    } catch (Exception e) {
      log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
      throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }
    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
  }
}

2) Configure per environment

application.yml (prod/dev)

einvoice:
  unzip:
    base-dir: /tmp/unzipped

application-test.yml (tests)

einvoice:
  unzip:
    base-dir: ${java.io.tmpdir}/unzipped

3) Minimal change in your test class

If you’re using @SpringBootTest, just add @TestPropertySource (or rely on application-test.yml):

@SpringBootTest
@TestPropertySource(properties = {
  "einvoice.unzip.base-dir=${java.io.tmpdir}/unzipped"
})
class FetchDecryptUnzipTaskletExecuteTest {
  // ... your existing tests
}

If you’re constructing the tasklet manually (no Spring context), inject the field in @BeforeEach:

@TempDir Path tmp;

@BeforeEach
void setup() {
  tasklet = new FetchDecryptUnzipTasklet();
  ReflectionTestUtils.setField(tasklet, "pgpDecrypt", pgpDecrypt);
  ReflectionTestUtils.setField(tasklet, "cosStorageService", cos);
  ReflectionTestUtils.setField(tasklet, "unzipBaseDir", tmp.resolve("unzipped").toString()); // << inject base dir
}

Then, when asserting, use that base dir:

Path base   = tmp.resolve("unzipped");
Path csvDir = base.resolve("csv");
Path xmlDir = base.resolve("xml");

assertThat(Files.list(csvDir).anyMatch(p -> p.toString().endsWith(".csv"))).isTrue();

4) Why this fixes NoSuchFileException
	•	The tasklet always creates base/csv and base/xml before any code (or tests) lists them.
	•	Tests don’t depend on /tmp; they use the JUnit-provided temp folder.

That’s it—flip the property per env, and the exception goes away without hardcoding paths.
