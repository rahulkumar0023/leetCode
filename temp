Perfect üëç now you‚Äôve got your `/processed` directory populated with the actual files you moved in there (inputs after fetch, outputs after upload).

To delete them only **if the batch job completed successfully**, the cleanest way is to use a **JobExecutionListener** that fires after the job ends:

---

## ‚úÖ Listener-based cleanup

```java
@Component
@RequiredArgsConstructor
public class CosProcessedCleanupListener implements JobExecutionListener {

    private final CosStorageService cos;

    @Value("${cos.bucket}")
    private String bucket;

    @Value("${cos.processed-prefix:processed/}")
    private String processedPrefix;

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            // list all objects under processed/ and delete
            List<String> keys = cos.listKeys(bucket, processedPrefix);
            keys.forEach(k -> cos.deleteObject(bucket, k));
        } else {
            // optional: leave processed/ intact for debugging
            log.warn("Job failed, keeping files in {}/{}", bucket, processedPrefix);
        }
    }
}
```

---

## ‚úÖ Service methods in your `CosStorageService`

```java
public List<String> listKeys(String bucket, String prefix) {
    List<String> keys = new ArrayList<>();
    ObjectListing listing = s3Client.listObjects(bucket, prefix);
    while (true) {
        for (S3ObjectSummary s : listing.getObjectSummaries()) {
            keys.add(s.getKey());
        }
        if (listing.isTruncated()) {
            listing = s3Client.listNextBatchOfObjects(listing);
        } else break;
    }
    return keys;
}

public void deleteObject(String bucket, String key) {
    s3Client.deleteObject(bucket, key);
}
```

---

## ‚úÖ Wiring it into your job

In your job config:

```java
@Bean
public Job invoiceJob(JobRepository repo, PlatformTransactionManager tx,
                      Step fetchStep, Step processStep, Step uploadStep,
                      CosProcessedCleanupListener cleanupListener) {
    return new JobBuilder("invoiceJob", repo)
        .listener(cleanupListener)  // attach listener here
        .start(fetchStep)
        .next(processStep)
        .next(uploadStep)
        .build();
}
```

---

### üîë Advantages

* Deletes only if the job `COMPLETED`.
* Leaves files if the job `FAILED` (so you can debug).
* No need to pass filenames around in execution context ‚Äî it just wipes the whole `processed/` prefix when successful.

---

üëâ Do you want me to adapt this so it **only deletes the specific keys your tasklets recorded in ExecutionContext** (instead of scanning all of `processed/`)? That‚Äôs safer if multiple jobs run in parallel.




You‚Äôre right ‚Äî those assertions only pass if your classes implement **value-based equality**.
Right now `SupplierEntity` and `CosConfig` only have `@Getter/@Setter`, so they inherit `Object.equals/hashCode` (identity). Two different instances ‚Üí **not equal**, and hash codes usually differ.

Below are two ways forward. I‚Äôll default to **fixing the tests** to match current code (identity semantics). If you want value-based equality instead, I‚Äôve added the exact Lombok changes + matching tests too.

---

# A) Keep current code (identity equality) ‚Äî ‚úÖ revised tests

## `SupplierEntityTest.java`

```java
package com.bnpp.pf.einvoice.connect.batch.entity;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class SupplierEntityTest {

    @Test
    void gettersAndSettersWork() {
        SupplierEntity s = new SupplierEntity();
        s.setId(1L);
        s.setEnterpriseNumber("ENT-123");
        s.setCompanyName("Alpha Ltd");

        assertThat(s.getId()).isEqualTo(1L);
        assertThat(s.getEnterpriseNumber()).isEqualTo("ENT-123");
        assertThat(s.getCompanyName()).isEqualTo("Alpha Ltd");
    }

    @Test
    void equalsIsIdentity_basedOnObjectImplementation() {
        SupplierEntity s1 = new SupplierEntity();
        s1.setEnterpriseNumber("ENT-123");

        SupplierEntity s2 = new SupplierEntity();
        s2.setEnterpriseNumber("ENT-123");

        // identity semantics
        assertThat(s1).isNotEqualTo(s2);
        assertThat(s1).isEqualTo(s1);
        assertThat(s1).isNotEqualTo(null);
    }

    @Test
    void toStringContainsFields() {
        SupplierEntity s = new SupplierEntity();
        s.setEnterpriseNumber("E-5");
        s.setCompanyName("Zeta Ltd");
        assertThat(s.toString()).contains("E-5").contains("Zeta Ltd");
    }
}
```

## `CosConfigTest.java`

```java
package com.bnpp.pf.einvoice.connect.cos.config;

import org.junit.jupiter.api.Test;
import org.springframework.test.util.ReflectionTestUtils;

import static org.assertj.core.api.Assertions.assertThat;

class CosConfigTest {

    @Test
    void gettersAndSettersWork() {
        CosConfig c = new CosConfig();
        c.setInstance("dev-instance");
        c.setTimeOut(30);
        assertThat(c.getInstance()).isEqualTo("dev-instance");
        assertThat(c.getTimeOut()).isEqualTo(30);
    }

    @Test
    void complexFieldsViaReflection() {
        CosConfig c = new CosConfig();
        Object bucket = new Object(); // replace with real Bucket if available
        Object iam = new Object();    // replace with real Iam if available
        ReflectionTestUtils.setField(c, "bucket", bucket);
        ReflectionTestUtils.setField(c, "iam", iam);
        assertThat(c.getBucket()).isSameAs(bucket);
        assertThat(c.getIam()).isSameAs(iam);
    }

    @Test
    void equalsIsIdentity_andToStringHasUsefulInfo() {
        CosConfig c1 = new CosConfig();
        c1.setInstance("A"); c1.setTimeOut(5);

        CosConfig c2 = new CosConfig();
        c2.setInstance("A"); c2.setTimeOut(5);

        // object identity semantics
        assertThat(c1).isNotEqualTo(c2);
        assertThat(c1).isEqualTo(c1);
        assertThat(c1.toString()).contains("A");
    }
}
```

These tests won‚Äôt assert hash equality/inequality (since `Object.hashCode()` is identity-based and not something we should rely on deterministically across JVMs). They still give you coverage for the class behavior you actually have.

---

# B) If you **want value-based equality** (optional) ‚Äî change Lombok + tests

## Production changes

### For JPA entities (recommended pattern)

Use a stable, unique business key (you already have `enterprise_number UNIQUE`), not the generated `id`:

```java
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "suppliers")
@Getter @Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class SupplierEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @EqualsAndHashCode.Include
    @Column(name = "enterprise_number", nullable = false, unique = true)
    private String enterpriseNumber;

    @Column(name = "company_name")
    private String companyName;
}
```

### For `CosConfig`

If you want simple value equality over its fields:

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "cos")
@Data // generates getters, setters, equals, hashCode, toString
public class CosConfig {
    private String instance;
    private Bucket bucket;
    private Iam iam;
    private int timeOut;
}
```

## Matching tests (when value-based equality is enabled)

```java
// SupplierEntity equality by enterpriseNumber
@Test
void supplierEqualityByBusinessKey() {
    SupplierEntity a = new SupplierEntity(); a.setEnterpriseNumber("ENT-123");
    SupplierEntity b = new SupplierEntity(); b.setEnterpriseNumber("ENT-123");
    assertThat(a).isEqualTo(b);
    assertThat(a.hashCode()).isEqualTo(b.hashCode());
}

// CosConfig value-based equality
@Test
void cosConfigValueEquality() {
    CosConfig c1 = new CosConfig(); c1.setInstance("A"); c1.setTimeOut(5);
    CosConfig c2 = new CosConfig(); c2.setInstance("A"); c2.setTimeOut(5);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
}
```

---

## Which should you pick?

* If you don‚Äôt want to modify production code right now, **use option A** (updated tests).
* If equality by content is desired (often useful for DTO/configs; for JPA be careful), **use option B**, with the JPA-friendly `@EqualsAndHashCode` approach on `SupplierEntity`.

If you tell me which route you prefer, I can adjust the rest of your suite in the same style.

```

These tests won‚Äôt assert hash equality/inequality (since `Object.hashCode()` is identity-based and not something we should rely on deterministically across JVMs). They still give you coverage for the class behavior you actually have.

---

# B) If you **want value-based equality** (optional) ‚Äî change Lombok + tests

## Production changes

### For JPA entities (recommended pattern)

Use a stable, unique business key (you already have `enterprise_number UNIQUE`), not the generated `id`:

```java
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "suppliers")
@Getter @Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class SupplierEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @EqualsAndHashCode.Include
    @Column(name = "enterprise_number", nullable = false, unique = true)
    private String enterpriseNumber;

    @Column(name = "company_name")
    private String companyName;
}
```

### For `CosConfig`

If you want simple value equality over its fields:

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "cos")
@Data // generates getters, setters, equals, hashCode, toString
public class CosConfig {
    private String instance;
    private Bucket bucket;
    private Iam iam;
    private int timeOut;
}
```

## Matching tests (when value-based equality is enabled)

```java
// SupplierEntity equality by enterpriseNumber
@Test
void supplierEqualityByBusinessKey() {
    SupplierEntity a = new SupplierEntity(); a.setEnterpriseNumber("ENT-123");
    SupplierEntity b = new SupplierEntity(); b.setEnterpriseNumber("ENT-123");
    assertThat(a).isEqualTo(b);
    assertThat(a.hashCode()).isEqualTo(b.hashCode());
}

// CosConfig value-based equality
@Test
void cosConfigValueEquality() {
    CosConfig c1 = new CosConfig(); c1.setInstance("A"); c1.setTimeOut(5);
    CosConfig c2 = new CosConfig(); c2.setInstance("A"); c2.setTimeOut(5);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
}
```

---

## Which should you pick?

* If you don‚Äôt want to modify production code right now, **use option A** (updated tests).
* If equality by content is desired (often useful for DTO/configs; for JPA be careful), **use option B**, with the JPA-friendly `@EqualsAndHashCode` approach on `SupplierEntity`.

If you tell me which route you prefer, I can adjust the rest of your suite in the same style.

```

---

### ‚úÖ What this covers

* **SupplierEntity**: all Lombok-generated getters/setters, `equals`, `hashCode`, `toString`.
* **CosConfig**: getters/setters, reflection injection for `bucket` + `iam`, equality/hashCode/toString.

---

üëâ Do you also want me to add **negative tests** (e.g. `equals` with different values, `null` checks) to hit more branches in Lombok-generated methods?
