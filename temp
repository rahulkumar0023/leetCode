You’re spot on: CreditNoteType isn’t a drop-in for InvoiceType. A few property names differ (most notably creditNoteLine vs invoiceLine), and if your MapStruct mappings/ helpers all return Invoice* aggregates (e.g., InvoiceLineType), MapStruct will quietly skip them for CreditNoteType. That’s why your credit note XML ends up almost empty (even ID if you accidentally targeted the wrong path).

Here’s a clean way to fix it.

What to change
	1.	Have two top-level mapping methods: one to InvoiceType, one to CreditNoteType.
	2.	Share helpers that return common UBL CAC/CBC types (ID, Party, TaxTotal, LegalMonetaryTotal, etc.).
	3.	Provide two separate line mappers:
	•	List<InvoiceLineType> for invoices
	•	List<CreditNoteLineType> for credit notes
(Their element types differ, so MapStruct can’t reuse one.)
	4.	Make sure targets use the correct property names for each root:
	•	InvoiceType.invoiceLine
	•	CreditNoteType.creditNoteLine

Reference MapStruct mapper (trimmed but working)

Adjust names/DTO fields to yours; pay attention to the targets on each method.

@Mapper(
    componentModel = "spring",
    builder = @Builder(disableBuilder = true),
    nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS
)
public interface CsvInvoiceMapper {

  // ---- Invoice ----
  @Mappings({
      @Mapping(target = "ID", source = "invoiceNumber", qualifiedByName = "toID"),
      @Mapping(target = "DocumentCurrencyCode", source = "currency", qualifiedByName = "toCurrencyCode"),
      @Mapping(target = "AccountingSupplierParty", source = ".", qualifiedByName = "toSupplierParty"),
      @Mapping(target = "AccountingCustomerParty", source = ".", qualifiedByName = "toCustomerParty"),
      @Mapping(target = "LegalMonetaryTotal", source = ".", qualifiedByName = "toLegalMonetaryTotal"),
      @Mapping(target = "TaxTotal", source = ".", qualifiedByName = "toTaxTotals"),
      @Mapping(target = "ContractDocumentReference", source = ".", qualifiedByName = "toContractRefs"),
      @Mapping(target = "InvoiceLine", source = "lines", qualifiedByName = "toInvoiceLines")
  })
  oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType toInvoiceType(CsvInvoiceDto dto);

  // ---- Credit Note ----
  @Mappings({
      @Mapping(target = "ID", source = "invoiceNumber", qualifiedByName = "toID"),
      @Mapping(target = "DocumentCurrencyCode", source = "currency", qualifiedByName = "toCurrencyCode"),
      @Mapping(target = "AccountingSupplierParty", source = ".", qualifiedByName = "toSupplierParty"),
      @Mapping(target = "AccountingCustomerParty", source = ".", qualifiedByName = "toCustomerParty"),
      @Mapping(target = "LegalMonetaryTotal", source = ".", qualifiedByName = "toLegalMonetaryTotal"),
      @Mapping(target = "TaxTotal", source = ".", qualifiedByName = "toTaxTotals"),
      @Mapping(target = "ContractDocumentReference", source = ".", qualifiedByName = "toContractRefs"),
      // IMPORTANT: property name differs on CreditNote
      @Mapping(target = "CreditNoteLine", source = "lines", qualifiedByName = "toCreditNoteLines")
  })
  oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType toCreditNoteType(CsvInvoiceDto dto);

  // ===== Shared CBC helpers =====

  @Named("toID")
  default oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType toID(String value) {
    if (value == null || value.isBlank()) return null;
    var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
    id.setValue(value);
    return id;
  }

  @Named("toCurrencyCode")
  default oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.DocumentCurrencyCodeType toCurrencyCode(String code) {
    if (code == null || code.isBlank()) return null;
    var c = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.DocumentCurrencyCodeType();
    c.setValue(code);
    return c;
  }

  // ===== Shared CAC helpers =====

  @Named("toSupplierParty")
  default oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.AccountingSupplierPartyType toSupplierParty(CsvInvoiceDto dto) {
    // build Party with PartyTaxScheme.CompanyID etc.
    var asp = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.AccountingSupplierPartyType();
    var party = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.PartyType();
    // ... fill party from dto (enterprise number, names, addresses, contacts)
    asp.setParty(party);
    return asp;
  }

  @Named("toCustomerParty")
  default oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.AccountingCustomerPartyType toCustomerParty(CsvInvoiceDto dto) {
    var acp = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.AccountingCustomerPartyType();
    var party = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.PartyType();
    // ... fill party from dto
    acp.setParty(party);
    return acp;
  }

  @Named("toLegalMonetaryTotal")
  default oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.LegalMonetaryTotalType toLegalMonetaryTotal(CsvInvoiceDto dto) {
    var t = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.LegalMonetaryTotalType();
    // ... set PayableAmount, LineExtensionAmount, etc.
    return t;
  }

  @Named("toTaxTotals")
  default java.util.List<oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.TaxTotalType> toTaxTotals(CsvInvoiceDto dto) {
    var tax = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.TaxTotalType();
    // ... set TaxAmount and subtotals
    return java.util.List.of(tax);
  }

  @Named("toContractRefs")
  default java.util.List<oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.DocumentReferenceType> toContractRefs(CsvInvoiceDto dto) {
    if (dto.getContractDocumentReferenceId() == null) return java.util.List.of();
    var dr = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.DocumentReferenceType();
    var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
    id.setValue(dto.getContractDocumentReferenceId());
    dr.setID(id);
    return java.util.List.of(dr);
  }

  // ===== Lines: two separate helpers =====

  @Named("toInvoiceLines")
  default java.util.List<oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.InvoiceLineType>
  toInvoiceLines(java.util.List<CsvInvoiceDto.Line> lines) {
    if (lines == null || lines.isEmpty()) return java.util.List.of();
    var out = new java.util.ArrayList<oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.InvoiceLineType>();
    for (var l : lines) {
      var il = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.InvoiceLineType();
      // ... set line ID, InvoicedQuantity, LineExtensionAmount, Item, Price, etc.
      out.add(il);
    }
    return out;
  }

  @Named("toCreditNoteLines")
  default java.util.List<oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.CreditNoteLineType>
  toCreditNoteLines(java.util.List<CsvInvoiceDto.Line> lines) {
    if (lines == null || lines.isEmpty()) return java.util.List.of();
    var out = new java.util.ArrayList<oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.CreditNoteLineType>();
    for (var l : lines) {
      var cl = new oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.CreditNoteLineType();
      // ... set line ID, CreditedQuantity, LineExtensionAmount, Item, Price, etc.
      out.add(cl);
    }
    return out;
  }
}

Subtle but critical: CreditNoteLineType uses CreditedQuantity (vs InvoicedQuantity). Make sure to set the right field in each line helper.

Quick JUnit tests (mapper level)

These prove ID and lines are present for both types. Replace field access with your actual DTO fields.

@ExtendWith(MockitoExtension.class)
class CsvInvoiceMapperCreditNoteTest {

  // If you use MapStruct with componentModel="spring", you can instantiate the impl directly in tests:
  private final CsvInvoiceMapper mapper = new CsvInvoiceMapperImpl();

  @Test
  void mapsInvoice_ok() {
    CsvInvoiceDto dto = sampleDto("INV-1", "EUR", "380");
    var inv = mapper.toInvoiceType(dto);

    assertNotNull(inv.getID());
    assertEquals("INV-1", inv.getID().getValue());
    assertEquals("EUR", inv.getDocumentCurrencyCode().getValue());
    assertNotNull(inv.getInvoiceLine());
    assertFalse(inv.getInvoiceLine().isEmpty());
  }

  @Test
  void mapsCreditNote_ok() {
    CsvInvoiceDto dto = sampleDto("CN-1", "EUR", "381");
    var cn = mapper.toCreditNoteType(dto);

    assertNotNull(cn.getID());
    assertEquals("CN-1", cn.getID().getValue());
    assertEquals("EUR", cn.getDocumentCurrencyCode().getValue());
    assertNotNull(cn.getCreditNoteLine());        // different collection name
    assertFalse(cn.getCreditNoteLine().isEmpty());
  }

  private CsvInvoiceDto sampleDto(String id, String ccy, String type) {
    CsvInvoiceDto d = new CsvInvoiceDto();
    d.setInvoiceNumber(id);
    d.setDocumentCurrencyCode(ccy);
    d.setInvoiceTypeCode(type);
    // add one line
    var line = new CsvInvoiceDto.Line();
    line.setQuantity("1");
    line.setPrice("10.00");
    d.setLines(java.util.List.of(line));
    d.setContractDocumentReferenceId("12-ABC");
    return d;
  }
}

Common gotchas checklist
	•	✅ Property names: CreditNoteType.creditNoteLine vs InvoiceType.invoiceLine.
	•	✅ Line element names: CreditedQuantity vs InvoicedQuantity.
	•	✅ Helpers’ return types: Don’t reuse InvoiceLineType helpers for credit notes.
	•	✅ Marshaller context: include both root types in your JAXBContext.
	•	✅ Null checks: MapStruct with nullValueCheckStrategy = ALWAYS avoids NPEs in generated code.

If you wire the above, your toCreditNoteType(...) will produce a fully populated credit note XML with all children present, and your existing bucket resolver + classifier writer will work unchanged.

Perfect — understood 👌
If your boss is presenting this to management, the text should be:
	•	Concise (no long paragraphs)
	•	Step-based (clear actions, easy to follow)
	•	Outcome-oriented (shows results + value of your work)

Here’s a polished playbook version of your flow, ready to present:

⸻

Dev Connectivity & Access Playbook

⸻

0. How Requests Start
	•	Dev raises issue (email, dev community, or call).
	•	We categorize request into one of five buckets:
	1.	Firewall / Connectivity
	2.	Database Access (SQL/Oracle)
	3.	API Connectivity
	4.	SFTP / WinSCP
	5.	Other Tooling (Liberty, IntelliJ, AS400, etc.)

⸻

1. Firewall / Connectivity
	1.	Check if request is for Dev/Test → firewall request is enough.
	2.	If other servers → validate CyberArk ticket.
	3.	Raise firewall request in tracker → share with infra.
	4.	Infra implements → we validate.
	5.	Dev tests → if OK → close request.
	6.	If not working → escalate for further troubleshooting.

⸻

2. Database Access (SQL/Oracle)
	1.	Confirm DB must go via CyberArk.
	2.	Infra configures DB connection in CyberArk.
	3.	Raise user onboarding request.
	4.	User validates connection.
	5.	If OK → close request.
	6.	Future onboarding → handled via ServiceNow.

⸻

3. API Connectivity (Postman/Bruno)
	1.	Initially checked via firewall → later found APIs behind proxies.
	2.	Worked with infra to confirm setup.
	3.	Dev must configure:
	•	Proxy settings in Postman/Bruno.
	•	Certificates in Postman.
	•	Proxy setup on Mac.
	4.	We guide devs (calls + docs).
	5.	If API works via proxy → close request.

⸻

4. SFTP / WinSCP
	1.	Onboard user to CyberArk.
	2.	Test login + file access (early phase: we acted as test users, reported permission gaps).
	3.	Infra adjusts permissions.
	4.	Verify file access + WinSCP directory mapping.
	5.	Provide docs:
	•	CyberArk access from Mac.
	•	WinSCP upload/download steps.
	6.	Dev validates → close request.

⸻

5. Other Tooling / Environment
	1.	Devs often lack time to configure tools.
	2.	We test, configure, and create step-by-step guides.
	•	IntelliJ Ultimate → added to self-service (with infra + Mac support).
	•	AS400 Access → TN5250 client added.
	•	Liberty Server → configured locally, docs created.
	3.	Share setup guides with devs.
	4.	Provide initial support calls if needed.
	5.	Once confirmed → close request.

⸻

6. Closure & Knowledge Sharing
	•	Every resolved issue = documented steps.
	•	Built a library of guides (Postman, CyberArk, WinSCP, Liberty, AS400, IntelliJ).
	•	Developers can now self-serve for repeat issues.

⸻

👉 This format shows management:
	•	Clear flows
	•	Your coordination role with infra + devs
	•	Deliverables produced (docs, configs, tools)
	•	Ongoing value (knowledge base for devs)

⸻

Would you like me to also make a 1-page executive summary version (super high-level, for slides), or keep it only as this playbook-style text?


————


Got it ✅
Here’s a complete step-based flow that captures how requests start, how you categorize, what you/your team do, how it progresses, and how it closes. I’ve kept it structured but detailed so it reflects your actual work:

⸻

Step-Based Flow for Handling Dev Requests

⸻

0. Entry Point – Issue Reported
	•	A developer reports an issue (via email, dev community, or call).
	•	We log the request and start by categorizing the type of issue:
	•	Firewall / Connectivity (MQ, Kafka, server-to-server)
	•	Database Access (SQL Server, Oracle)
	•	API Connectivity (Postman/Bruno, proxy settings)
	•	SFTP / WinSCP (server login, file transfer)
	•	Other Tooling / Environment (Liberty, IntelliJ Ultimate, AS400 console, etc.)

⸻

1. Firewall / Connectivity Requests
	1.	Identify if the request is for Dev/Test environment.
	•	If yes → opening a firewall rule is usually enough.
	•	If not → confirm valid CyberArk onboarding and ticket.
	2.	Create a firewall request in the request tracker.
	3.	Share request details with infra team.
	4.	Infra team implements the firewall and notifies us.
	5.	We validate the connection from our side.
	6.	If firewall is okay, we ask the developer to test.
	7.	If dev confirms it works → close request.
	8.	If not → continue debugging, check logs, troubleshoot further.

⸻

2. Database Access (SQL Server, Oracle)
	1.	Dev requests DB connection.
	2.	We ensure DB connection must go through CyberArk.
	3.	Early phase: we worked with infra team to clarify setup requirements.
	4.	Infra configures DB connection in CyberArk based on info shared.
	5.	Once config is ready → raise user onboarding request.
	6.	After onboarding → requestor is asked to validate DB connection.
	7.	If connection works → close request.
	8.	New onboarding requests must now go via ServiceNow (regular process).

⸻

3. API Connectivity (Postman/Bruno)
	1.	Initially we requested firewall openings, but later found APIs are behind proxies.
	2.	Worked with Inna + infra team to troubleshoot and confirm proxy setup.
	3.	Developers need to:
	•	Adapt proxy settings in Postman or Bruno.
	•	Add certificates in Postman.
	•	Configure Postman proxy on Mac (we created docs for this).
	4.	We often walk devs through initial setups on calls.
	5.	Once proxy configuration is correct → developer validates API call.
	6.	If successful → close request.
	7.	If not → more troubleshooting to see in which scenarios proxy works.

⸻

4. SFTP / WinSCP (Server & File Access)
	1.	Dev needs server or file access.
	2.	First step → onboarding user to CyberArk.
	3.	Early phase: we acted as test users to identify issues (e.g., able to log in but couldn’t see files due to missing permissions).
	4.	Reported issues back to infra for corrections.
	5.	Once CyberArk setup works:
	•	Dev can log in to server.
	•	File access permissions are verified.
	•	WinSCP local directory mapping is tested (upload/download).
	6.	We created documentation for:
	•	Accessing CyberArk from Mac.
	•	Steps to use WinSCP for file transfers.
	7.	After developer validates access → close request.

⸻

5. Other Tooling / Environment Requests
	1.	Devs sometimes lack time to configure local tools (e.g., Liberty server).
	•	We experiment, configure, and document step-by-step setup guides.
	2.	Example achievements:
	•	IntelliJ Ultimate was not in self-service → we raised it with infra + Mac support → package added.
	•	AS400 Access: TN5250 client was missing → we got it added, now accessible from Mac.
	•	Liberty server: we tested locally and created working setup steps for devs.
	3.	Once tools are ready:
	•	We share documentation and guides with devs.
	•	Support devs in initial calls if needed.
	•	Requests are closed once dev confirms setup works.

⸻

6. Closure & Knowledge Sharing
	•	After any category request is completed:
	•	Developer validates → request closed.
	•	Steps/findings are documented (Mac setup guides, Postman configs, WinSCP usage, Liberty setup, etc.).
	•	Shared with devs for self-service in future.
	•	Over time, created a library of troubleshooting docs and how-to guides.

⸻

✅ This is your work summarized as a structured step-based flow:
	•	Categorize issues
	•	Drive the technical + coordination steps with infra
	•	Validate and troubleshoot
	•	Close requests
	•	Document for future reuse

⸻

Would you like me to now restructure this into a concise “playbook” format (like numbered flows per category, shorter wording) so it reads more like an official process guide rather than a detailed report?

Absolutely—here are focused, drop-in **JUnit 5** test classes to cover:

1. the **processor** (CSV → `InvoiceType` or `CreditNoteType`)
2. the **classifier writer** (routes to your two writers)
3. an **end-to-end step test** (reader → processor → classifier writer) proving items are routed correctly

Assumptions:

* Package names for UBL classes are the standard ones (adjust if yours differ).
* You have `spring-boot-starter-test`, `spring-batch-test`, and `mockito` on the classpath.

---

# 1) Processor test

```java
package com.alphacredit.batch.processing;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvToUblProcessor processor;

  @Test
  void returnsCreditNote_whenTypeCode381() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381");
    var cn = new CreditNoteType();
    when(mapper.toCreditNoteType(dto)).thenReturn(cn);

    Object out = processor.process(dto);

    assertTrue(out instanceof CreditNoteType);
    verify(mapper).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void returnsInvoice_otherwise() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380");
    var inv = new InvoiceType();
    when(mapper.toInvoiceType(dto)).thenReturn(inv);

    Object out = processor.process(dto);

    assertTrue(out instanceof InvoiceType);
    verify(mapper).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }
}
```

---

# 2) Classifier writer test

This verifies that objects are dispatched to the correct writer.

```java
package com.alphacredit.batch.writer;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UblClassifierWriterTest {

  @SuppressWarnings("unchecked")
  @Test
  void routesToCorrectDelegate() throws Exception {
    // Arrange: two concrete writers
    ItemWriter<InvoiceType> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<CreditNoteType> creditWriter = mock(ItemWriter.class);

    // Build the classifier writer just like in your WriterConfig
    ClassifierCompositeItemWriter<Object> classifier = new ClassifierCompositeItemWriter<>();
    classifier.setClassifier(item -> {
      if (item instanceof InvoiceType) return (ItemWriter<Object>)(ItemWriter<?>)invoiceWriter;
      if (item instanceof CreditNoteType) return (ItemWriter<Object>)(ItemWriter<?>)creditWriter;
      throw new IllegalArgumentException("Unsupported: " + item.getClass());
    });

    // Input batch: 2 invoices + 1 credit note
    var inv1 = new InvoiceType();
    var inv2 = new InvoiceType();
    var cn1  = new CreditNoteType();

    // Act
    classifier.write(List.of(inv1, cn1, inv2));

    // Assert: each delegate got only the items of its type
    ArgumentCaptor<List<InvoiceType>> invCap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(2)).write(invCap.capture());
    // Because ClassifierCompositeItemWriter calls delegate per-item, we expect multiple single-item lists
    assertEquals(2, invCap.getAllValues().size());
    assertTrue(invCap.getAllValues().stream().allMatch(l -> l.size() == 1 && l.get(0) instanceof InvoiceType));

    ArgumentCaptor<List<CreditNoteType>> cnCap = ArgumentCaptor.forClass(List.class);
    verify(creditWriter, times(1)).write(cnCap.capture());
    assertEquals(1, cnCap.getAllValues().size());
    assertEquals(1, cnCap.getValue().size());
    assertTrue(cnCap.getValue().get(0) instanceof CreditNoteType);

    verifyNoMoreInteractions(invoiceWriter, creditWriter);
  }
}
```

---

# 3) End-to-end step test (Spring Batch)

This spins up a minimal Spring context and proves that:

* the **processor** converts based on `InvoiceTypeCode`
* the **classifier** routes to the right writer
* both writers get called the expected number of times

We’ll use **stub writers** that just record what they saw.

```java
package com.alphacredit.batch.step;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.*;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.*;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CsvToXmlStepTest.Config.class)
class CsvToXmlStepTest {

  @Autowired JobLauncher launcher;
  @Autowired Job job;
  @Autowired Config.RecordingInvoiceWriter invWriter;
  @Autowired Config.RecordingCreditWriter cnWriter;

  @Test
  void routesInvoicesAndCreditNotes() throws Exception {
    JobExecution exec = launcher.run(job, new JobParameters());
    assertEquals(BatchStatus.COMPLETED, exec.getStatus());

    // We fed 2 invoices + 1 creditnote (see reader below)
    assertEquals(2, invWriter.items.size());
    assertEquals(1, cnWriter.items.size());
  }

  // ---- Test configuration ----
  @Configuration
  @EnableBatchProcessing
  static class Config {

    // Simple reader that returns 3 DTOs: 2 invoices (380) + 1 credit (381)
    @Bean
    ItemReader<CsvInvoiceDto> reader() {
      List<CsvInvoiceDto> list = new ArrayList<>();
      list.add(dto("INV-1", "380"));
      list.add(dto("INV-2", "380"));
      list.add(dto("CN-1",  "381"));
      return new ListItemReader<>(list);
    }

    private static CsvInvoiceDto dto(String id, String typeCode) {
      CsvInvoiceDto d = new CsvInvoiceDto();
      d.setInvoiceNumber(id);
      d.setInvoiceTypeCode(typeCode);
      return d;
    }

    // Mapper stub that makes minimal UBL objects
    @Bean
    CsvInvoiceMapper mapper() {
      return new CsvInvoiceMapper() {
        @Override public InvoiceType toInvoiceType(CsvInvoiceDto src) {
          InvoiceType inv = new InvoiceType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          inv.setID(id);
          return inv;
        }
        @Override public CreditNoteType toCreditNoteType(CsvInvoiceDto src) {
          CreditNoteType cn = new CreditNoteType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          cn.setID(id);
          return cn;
        }
      };
    }

    @Bean CsvToUblProcessor processor(CsvInvoiceMapper mapper) { return new CsvToUblProcessor(mapper); }

    // Recording writers (stand-ins for your XMLInvoiceWriter / XMLCreditNoteWriter)
    @Bean RecordingInvoiceWriter invoiceWriter() { return new RecordingInvoiceWriter(); }
    @Bean RecordingCreditWriter creditWriter()   { return new RecordingCreditWriter(); }

    @Bean
    @SuppressWarnings("unchecked")
    ClassifierCompositeItemWriter<Object> classifierWriter(RecordingInvoiceWriter inv, RecordingCreditWriter cn) {
      ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();
      cw.setClassifier(item -> {
        if (item instanceof InvoiceType)     return (ItemWriter<Object>)(ItemWriter<?>) inv;
        if (item instanceof CreditNoteType)  return (ItemWriter<Object>)(ItemWriter<?>) cn;
        throw new IllegalArgumentException("Unsupported: " + item);
      });
      return cw;
    }

    @Bean
    Job job(JobRepository repo, PlatformTransactionManager tx,
            ItemReader<CsvInvoiceDto> reader,
            CsvToUblProcessor processor,
            ClassifierCompositeItemWriter<Object> writer) {
      Step step = new StepBuilder("csvToXmlStep", repo)
          .<CsvInvoiceDto, Object>chunk(10, tx)
          .reader(reader)
          .processor(processor)
          .writer(writer)
          .build();
      return new JobBuilder("testJob", repo).start(step).build();
    }

    // --- recording writers
    static class RecordingInvoiceWriter implements ItemWriter<InvoiceType> {
      final List<InvoiceType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends InvoiceType> items) { this.items.addAll(items); }
    }
    static class RecordingCreditWriter implements ItemWriter<CreditNoteType> {
      final List<CreditNoteType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends CreditNoteType> items) { this.items.addAll(items); }
    }
  }
}
```

---

## What these tests give you

* ✅ **Processor logic**: confidently flips to `CreditNoteType` when `InvoiceTypeCode == 381`.
* ✅ **Routing**: classifier sends each object to the correct concrete writer.
* ✅ **Step integration**: with a real Batch step, confirms two invoices + one credit note end up in the expected writers.

If you want, I can also add quick tests for your `BucketResolver` on both `InvoiceType` and `CreditNoteType` using your latest implementation, but since you already validated that earlier, these three should cover your CSV→polymorphic UBL flow end-to-end.


Absolutely—here are focused, drop-in **JUnit 5** test classes to cover:

1. the **processor** (CSV → `InvoiceType` or `CreditNoteType`)
2. the **classifier writer** (routes to your two writers)
3. an **end-to-end step test** (reader → processor → classifier writer) proving items are routed correctly

Assumptions:

* Package names for UBL classes are the standard ones (adjust if yours differ).
* You have `spring-boot-starter-test`, `spring-batch-test`, and `mockito` on the classpath.

---

# 1) Processor test

```java
package com.alphacredit.batch.processing;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvToUblProcessor processor;

  @Test
  void returnsCreditNote_whenTypeCode381() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381");
    var cn = new CreditNoteType();
    when(mapper.toCreditNoteType(dto)).thenReturn(cn);

    Object out = processor.process(dto);

    assertTrue(out instanceof CreditNoteType);
    verify(mapper).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void returnsInvoice_otherwise() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380");
    var inv = new InvoiceType();
    when(mapper.toInvoiceType(dto)).thenReturn(inv);

    Object out = processor.process(dto);

    assertTrue(out instanceof InvoiceType);
    verify(mapper).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }
}
```

---

# 2) Classifier writer test

This verifies that objects are dispatched to the correct writer.

```java
package com.alphacredit.batch.writer;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UblClassifierWriterTest {

  @SuppressWarnings("unchecked")
  @Test
  void routesToCorrectDelegate() throws Exception {
    // Arrange: two concrete writers
    ItemWriter<InvoiceType> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<CreditNoteType> creditWriter = mock(ItemWriter.class);

    // Build the classifier writer just like in your WriterConfig
    ClassifierCompositeItemWriter<Object> classifier = new ClassifierCompositeItemWriter<>();
    classifier.setClassifier(item -> {
      if (item instanceof InvoiceType) return (ItemWriter<Object>)(ItemWriter<?>)invoiceWriter;
      if (item instanceof CreditNoteType) return (ItemWriter<Object>)(ItemWriter<?>)creditWriter;
      throw new IllegalArgumentException("Unsupported: " + item.getClass());
    });

    // Input batch: 2 invoices + 1 credit note
    var inv1 = new InvoiceType();
    var inv2 = new InvoiceType();
    var cn1  = new CreditNoteType();

    // Act
    classifier.write(List.of(inv1, cn1, inv2));

    // Assert: each delegate got only the items of its type
    ArgumentCaptor<List<InvoiceType>> invCap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(2)).write(invCap.capture());
    // Because ClassifierCompositeItemWriter calls delegate per-item, we expect multiple single-item lists
    assertEquals(2, invCap.getAllValues().size());
    assertTrue(invCap.getAllValues().stream().allMatch(l -> l.size() == 1 && l.get(0) instanceof InvoiceType));

    ArgumentCaptor<List<CreditNoteType>> cnCap = ArgumentCaptor.forClass(List.class);
    verify(creditWriter, times(1)).write(cnCap.capture());
    assertEquals(1, cnCap.getAllValues().size());
    assertEquals(1, cnCap.getValue().size());
    assertTrue(cnCap.getValue().get(0) instanceof CreditNoteType);

    verifyNoMoreInteractions(invoiceWriter, creditWriter);
  }
}
```

---

# 3) End-to-end step test (Spring Batch)

This spins up a minimal Spring context and proves that:

* the **processor** converts based on `InvoiceTypeCode`
* the **classifier** routes to the right writer
* both writers get called the expected number of times

We’ll use **stub writers** that just record what they saw.

```java
package com.alphacredit.batch.step;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.*;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.*;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CsvToXmlStepTest.Config.class)
class CsvToXmlStepTest {

  @Autowired JobLauncher launcher;
  @Autowired Job job;
  @Autowired Config.RecordingInvoiceWriter invWriter;
  @Autowired Config.RecordingCreditWriter cnWriter;

  @Test
  void routesInvoicesAndCreditNotes() throws Exception {
    JobExecution exec = launcher.run(job, new JobParameters());
    assertEquals(BatchStatus.COMPLETED, exec.getStatus());

    // We fed 2 invoices + 1 creditnote (see reader below)
    assertEquals(2, invWriter.items.size());
    assertEquals(1, cnWriter.items.size());
  }

  // ---- Test configuration ----
  @Configuration
  @EnableBatchProcessing
  static class Config {

    // Simple reader that returns 3 DTOs: 2 invoices (380) + 1 credit (381)
    @Bean
    ItemReader<CsvInvoiceDto> reader() {
      List<CsvInvoiceDto> list = new ArrayList<>();
      list.add(dto("INV-1", "380"));
      list.add(dto("INV-2", "380"));
      list.add(dto("CN-1",  "381"));
      return new ListItemReader<>(list);
    }

    private static CsvInvoiceDto dto(String id, String typeCode) {
      CsvInvoiceDto d = new CsvInvoiceDto();
      d.setInvoiceNumber(id);
      d.setInvoiceTypeCode(typeCode);
      return d;
    }

    // Mapper stub that makes minimal UBL objects
    @Bean
    CsvInvoiceMapper mapper() {
      return new CsvInvoiceMapper() {
        @Override public InvoiceType toInvoiceType(CsvInvoiceDto src) {
          InvoiceType inv = new InvoiceType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          inv.setID(id);
          return inv;
        }
        @Override public CreditNoteType toCreditNoteType(CsvInvoiceDto src) {
          CreditNoteType cn = new CreditNoteType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          cn.setID(id);
          return cn;
        }
      };
    }

    @Bean CsvToUblProcessor processor(CsvInvoiceMapper mapper) { return new CsvToUblProcessor(mapper); }

    // Recording writers (stand-ins for your XMLInvoiceWriter / XMLCreditNoteWriter)
    @Bean RecordingInvoiceWriter invoiceWriter() { return new RecordingInvoiceWriter(); }
    @Bean RecordingCreditWriter creditWriter()   { return new RecordingCreditWriter(); }

    @Bean
    @SuppressWarnings("unchecked")
    ClassifierCompositeItemWriter<Object> classifierWriter(RecordingInvoiceWriter inv, RecordingCreditWriter cn) {
      ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();
      cw.setClassifier(item -> {
        if (item instanceof InvoiceType)     return (ItemWriter<Object>)(ItemWriter<?>) inv;
        if (item instanceof CreditNoteType)  return (ItemWriter<Object>)(ItemWriter<?>) cn;
        throw new IllegalArgumentException("Unsupported: " + item);
      });
      return cw;
    }

    @Bean
    Job job(JobRepository repo, PlatformTransactionManager tx,
            ItemReader<CsvInvoiceDto> reader,
            CsvToUblProcessor processor,
            ClassifierCompositeItemWriter<Object> writer) {
      Step step = new StepBuilder("csvToXmlStep", repo)
          .<CsvInvoiceDto, Object>chunk(10, tx)
          .reader(reader)
          .processor(processor)
          .writer(writer)
          .build();
      return new JobBuilder("testJob", repo).start(step).build();
    }

    // --- recording writers
    static class RecordingInvoiceWriter implements ItemWriter<InvoiceType> {
      final List<InvoiceType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends InvoiceType> items) { this.items.addAll(items); }
    }
    static class RecordingCreditWriter implements ItemWriter<CreditNoteType> {
      final List<CreditNoteType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends CreditNoteType> items) { this.items.addAll(items); }
    }
  }
}
```

---

## What these tests give you

* ✅ **Processor logic**: confidently flips to `CreditNoteType` when `InvoiceTypeCode == 381`.
* ✅ **Routing**: classifier sends each object to the correct concrete writer.
* ✅ **Step integration**: with a real Batch step, confirms two invoices + one credit note end up in the expected writers.

If you want, I can also add quick tests for your `BucketResolver` on both `InvoiceType` and `CreditNoteType` using your latest implementation, but since you already validated that earlier, these three should cover your CSV→polymorphic UBL flow end-to-end.
