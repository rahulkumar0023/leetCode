Sure! Below is the full **step-by-step implementation** to read `.zip.pgp` files from a COS bucket, decrypt and unzip them, and process the resulting CSV files using **Spring Batch**. This includes all the key components with minimal changes for clarity.

---

### **Step 1: Fetch `.zip.pgp` Files from COS Bucket**

Create a service to fetch files from the COS bucket using the AWS S3 SDK. Each file is returned as a Spring `Resource`.

```java
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.services.s3.model.S3ObjectSummary;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;

import java.util.ArrayList;
import java.util.List;

public class CosService {

    private final AmazonS3 s3Client = AmazonS3ClientBuilder.defaultClient();

    public Resource[] fetchEncryptedFiles(String bucketName, String prefix) {
        List<Resource> resources = new ArrayList<>();

        // List files in the COS bucket
        List<S3ObjectSummary> summaries = s3Client.listObjects(bucketName, prefix).getObjectSummaries();
        for (S3ObjectSummary summary : summaries) {
            S3Object s3Object = s3Client.getObject(bucketName, summary.getKey());
            resources.add(new InputStreamResource(s3Object.getObjectContent()));
        }

        return resources.toArray(new Resource[0]);
    }
}
```

---

### **Step 2: Decrypt `.pgp` Files**

Use the `Decryptor` utility to decrypt `.pgp` files. The decrypted data is returned as a `Resource`.

```java
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

public class DecryptionUtil {

    private final Decryptor decryptor;

    public DecryptionUtil(Decryptor decryptor) {
        this.decryptor = decryptor;
    }

    public Resource decryptResource(Resource encryptedResource) throws Exception {
        InputStream encryptedStream = encryptedResource.getInputStream();

        // Decrypt to a ByteArrayOutputStream
        ByteArrayOutputStream decryptedOutputStream = new ByteArrayOutputStream();
        decryptor.decrypt(encryptedStream, decryptedOutputStream);

        // Convert the decrypted output to a Resource
        return new InputStreamResource(new ByteArrayInputStream(decryptedOutputStream.toByteArray()));
    }
}
```

---

### **Step 3: Unzip `.zip` Files**

Extract the CSV files from the `.zip` files. This utility supports extracting all files in the archive.

```java
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import org.springframework.core.io.Resource;

public class UnzipUtil {

    public List<InputStream> extractCsvFromZip(Resource decryptedResource) throws Exception {
        List<InputStream> csvStreams = new ArrayList<>();
        ZipInputStream zis = new ZipInputStream(decryptedResource.getInputStream());
        ZipEntry entry;

        while ((entry = zis.getNextEntry()) != null) {
            if (!entry.isDirectory() && entry.getName().endsWith(".csv")) {
                // Store each CSV as an InputStream
                csvStreams.add(new BufferedInputStream(zis));
            }
        }
        return csvStreams;
    }
}
```

---

### **Step 4: Custom MultiResource Item Reader**

This reader handles decryption, unzipping, and processing of all CSVs dynamically.

```java
import org.springframework.batch.item.file.MultiResourceItemReader;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

public class DecryptingMultiResourceItemReader<T> extends MultiResourceItemReader<T> {

    private final DecryptionUtil decryptionUtil;
    private final UnzipUtil unzipUtil;

    public DecryptingMultiResourceItemReader(DecryptionUtil decryptionUtil, UnzipUtil unzipUtil) {
        this.decryptionUtil = decryptionUtil;
        this.unzipUtil = unzipUtil;
    }

    public void setEncryptedResources(Resource[] encryptedResources) {
        List<Resource> decryptedCsvResources = new ArrayList<>();
        for (Resource encryptedResource : encryptedResources) {
            try {
                // Decrypt the resource
                Resource decryptedResource = decryptionUtil.decryptResource(encryptedResource);

                // Extract CSV streams
                List<InputStream> csvStreams = unzipUtil.extractCsvFromZip(decryptedResource);

                // Convert each CSV stream into a Spring Resource
                for (InputStream csvStream : csvStreams) {
                    decryptedCsvResources.add(new InputStreamResource(csvStream));
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to process resource: " + encryptedResource.getDescription(), e);
            }
        }
        super.setResources(decryptedCsvResources.toArray(new Resource[0]));
    }
}
```

---

### **Step 5: Configure `FlatFileItemReader`**

Use a `FlatFileItemReader` to process the extracted CSV files.

```java
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.mapping.DefaultLineMapper;
import org.springframework.batch.item.file.transform.DelimitedLineTokenizer;

@Bean
public FlatFileItemReader<MyData> flatFileItemReader() {
    FlatFileItemReader<MyData> reader = new FlatFileItemReader<>();
    reader.setLinesToSkip(1); // Skip header row

    DefaultLineMapper<MyData> lineMapper = new DefaultLineMapper<>();
    DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer();
    tokenizer.setNames("id", "name", "value"); // CSV column names
    lineMapper.setLineTokenizer(tokenizer);
    lineMapper.setFieldSetMapper(fieldSet -> new MyData(
            fieldSet.readInt("id"),
            fieldSet.readString("name"),
            fieldSet.readDouble("value")
    ));
    reader.setLineMapper(lineMapper);

    return reader;
}
```

---

### **Step 6: Configure Spring Batch Step and Job**

Define the batch step and link it to a job.

```java
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.item.ItemWriter;

@Bean
public Step processStep(StepBuilderFactory stepBuilderFactory,
                        DecryptingMultiResourceItemReader<MyData> decryptingReader,
                        ItemWriter<MyData> itemWriter) {
    return stepBuilderFactory.get("processStep")
            .<MyData, MyData>chunk(10)
            .reader(decryptingReader)
            .writer(itemWriter)
            .build();
}

@Bean
public Job processEncryptedCsvJob(JobBuilderFactory jobBuilderFactory, Step processStep) {
    return jobBuilderFactory.get("processEncryptedCsvJob")
            .start(processStep)
            .build();
}
```

---

### **Step 7: Inject Dependencies**

Set up all dependencies in your application class or configuration class.

```java
@SpringBootApplication
public class BatchProcessingApplication {

    public static void main(String[] args) {
        SpringApplication.run(BatchProcessingApplication.class, args);
    }

    @Bean
    public CosService cosService() {
        return new CosService();
    }

    @Bean
    public Decryptor decryptor() {
        return new Decryptor(); // Your existing decryption logic
    }

    @Bean
    public DecryptionUtil decryptionUtil(Decryptor decryptor) {
        return new DecryptionUtil(decryptor);
    }

    @Bean
    public UnzipUtil unzipUtil() {
        return new UnzipUtil();
    }
}
```

---

### **Execution Flow**

1. Fetch `.zip.pgp` files from the COS bucket using `CosService`.
2. Decrypt the `.pgp` files into `.zip` files using `DecryptionUtil`.
3. Extract CSVs from `.zip` files using `UnzipUtil`.
4. Process CSV rows using `FlatFileItemReader`.
5. Run the Spring Batch job to process all the files.

---

Let me know if you need further clarifications or specific adjustments! ðŸš€



import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

public class DecryptionUtilTest {

    @Test
    void testDecryptResource() throws Exception {
        // Mock the Decryptor
        Decryptor mockDecryptor = Mockito.mock(Decryptor.class);

        // Create an instance of DecryptionUtil with the mocked Decryptor
        DecryptionUtil decryptionUtil = new DecryptionUtil(mockDecryptor);

        // Mock encrypted input and the expected decrypted content
        String encryptedContent = "EncryptedContent";
        String decryptedContent = "DecryptedContent";

        // Mock the behavior of the decryptor
        doAnswer(invocation -> {
            InputStream encryptedStream = invocation.getArgument(0);
            ByteArrayOutputStream decryptedOutputStream = invocation.getArgument(1);

            // Simulate decryption: write the expected decrypted content
            decryptedOutputStream.write(decryptedContent.getBytes(StandardCharsets.UTF_8));
            return null;
        }).when(mockDecryptor).decrypt(any(InputStream.class), any(ByteArrayOutputStream.class));

        // Create a mock encrypted resource
        Resource encryptedResource = new ByteArrayResource(encryptedContent.getBytes(StandardCharsets.UTF_8));

        // Call the decryptResource method
        Resource decryptedResource = decryptionUtil.decryptResource(encryptedResource);

        // Verify the results
        assertNotNull(decryptedResource, "Decrypted resource should not be null!");
        String actualDecryptedContent = new String(decryptedResource.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
        assertEquals(decryptedContent, actualDecryptedContent, "Decrypted content does not match!");

        // Verify that the decrypt method was called
        verify(mockDecryptor, times(1)).decrypt(any(InputStream.class), any(ByteArrayOutputStream.class));
    }
}

If your .asc file contains 3 secret key packets and each has a signature packet, the structure indicates:
	1.	One primary secret key: Used for signing or certifying.
	2.	Two secret subkeys: Likely used for encryption or authentication.
	3.	Signature packets: Used to verify the integrity and ownership of the keys.

This is typical for PGP key files, where:
	â€¢	The primary key is used for signing and generating subkeys.
	â€¢	The subkeys are used for encryption, signing, or authentication tasks.

Structure Overview

When you run gpg --list-packets private_key.asc, you might see something like this:

:public key packet:
    version 4, algo 1, created 1673900000, expires 0
    keyid: 123456789ABCDEF1
:secret key packet:
    version 4, algo 1, created 1673900000, expires 0
    keyid: 123456789ABCDEF1
:signature packet:
    version 4, type 0x13 (key revocation signature), keyid 123456789ABCDEF1
:secret subkey packet:
    version 4, algo 1, created 1673900100, expires 0
    keyid: 23456789ABCDEF12
:signature packet:
    version 4, type 0x18 (subkey binding signature), keyid 123456789ABCDEF1
:secret subkey packet:
    version 4, algo 1, created 1673900200, expires 0
    keyid: 3456789ABCDEF123
:signature packet:
    version 4, type 0x18 (subkey binding signature), keyid 123456789ABCDEF1

What This Means
	1.	Primary Secret Key:
	â€¢	Key ID: 123456789ABCDEF1
	â€¢	Role: Used for signing and certifying subkeys.
	â€¢	Paired with the :public key packet.
	2.	Subkeys:
	â€¢	Subkey 1: Key ID 23456789ABCDEF12
	â€¢	Subkey 2: Key ID 3456789ABCDEF123
	â€¢	Subkeys are usually used for encryption or authentication.
	3.	Signatures:
	â€¢	The binding signatures (type 0x18) confirm that the subkeys are tied to the primary key.
	â€¢	The key revocation signature (type 0x13) ensures the key can be revoked if compromised.

How to Handle This in Java

1. Parse the File and Identify Key Types

Use Bouncy Castle to iterate through the PGPSecretKeyRingCollection, and for each key, identify whether itâ€™s:
	â€¢	A primary key.
	â€¢	A subkey.

Code Example:

import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;

import java.io.FileInputStream;
import java.io.InputStream;

public class PGPKeyAnalyzer {

    public static void analyzeKeyFile(String privateKeyFilePath) throws Exception {
        try (InputStream keyInputStream = PGPUtil.getDecoderStream(new FileInputStream(privateKeyFilePath))) {
            // Parse the secret keyring collection
            PGPSecretKeyRingCollection secretKeyRingCollection =
                new PGPSecretKeyRingCollection(keyInputStream, new JcaKeyFingerprintCalculator());

            // Iterate through keyrings
            for (PGPSecretKeyRing secretKeyRing : secretKeyRingCollection) {
                System.out.println("Keyring ID: " + Long.toHexString(secretKeyRing.getPublicKey().getKeyID()));

                // Iterate through keys (primary and subkeys)
                for (PGPSecretKey secretKey : secretKeyRing) {
                    System.out.println("  Key ID: " + Long.toHexString(secretKey.getKeyID()));
                    System.out.println("  Is Signing Key: " + secretKey.isSigningKey());
                    System.out.println("  Key Encryption Algorithm: " + secretKey.getPublicKey().getAlgorithm());
                }
            }
        }
    }

    public static void main(String[] args) {
        try {
            analyzeKeyFile("path/to/private_key.asc");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

2. Extract the Keys

If you need to extract the private key (e.g., for decryption or signing), youâ€™ll need to:
	1.	Locate the specific subkey (used for encryption or signing).
	2.	Decrypt the private key using the passphrase.

Code to Extract Private Keys:

import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;

public class PrivateKeyExtractor {

    public static PGPPrivateKey extractPrivateKey(PGPSecretKey secretKey, String passphrase) throws Exception {
        return secretKey.extractPrivateKey(
            new JcePBESecretKeyDecryptorBuilder().setProvider("BC").build(passphrase.toCharArray())
        );
    }
}

3. Decrypt a File Using the Correct Subkey

Subkeys are often used for decryption. If your .asc file contains multiple subkeys:
	1.	Identify the correct subkey based on its usage (e.g., encryption).
	2.	Extract the private key from the subkey.
	3.	Use the private key for decryption.

Code for Decryption:

for (PGPSecretKey secretKey : secretKeyRing) {
    if (secretKey.isEncryptionKey()) {
        PGPPrivateKey privateKey = extractPrivateKey(secretKey, "your-passphrase");
        // Use privateKey for decryption
    }
}

4. Identify and Use Signatures

The signature packets can be used to:
	â€¢	Verify that a subkey is bound to the primary key.
	â€¢	Ensure the integrity and authenticity of the keys.

Bouncy Castle provides utilities to verify signatures. However, you generally donâ€™t need to handle signature packets manually unless youâ€™re performing signature verification or cryptographic analysis.

Next Steps
	1.	Verify the Correct Key for Decryption:
	â€¢	Use the isEncryptionKey() method to filter keys for decryption.
	2.	Handle Passphrases:
	â€¢	Ensure you have the correct passphrase to unlock the private key.
	3.	Test Decryption:
	â€¢	Once youâ€™ve extracted the correct private key, test it by decrypting a file or message.

Let me know if you need help implementing decryption or handling signatures! ðŸš€



The error PGPPublicKeyRing found where PGPSecretKeyRing expected occurs because the file youâ€™re attempting to load as a private key (PGPSecretKeyRingCollection) contains only public keys or is being parsed incorrectly.

This can happen due to:
	1.	Incorrect keyring type: The .asc file may contain public keys, but youâ€™re trying to load it as a secret keyring.
	2.	File format issues: The .asc file might contain a mix of public and secret keys, and you need to filter the correct key type.

Letâ€™s fix this step by step.

1. Validate the File

Before loading the key in your Java code, validate the .asc file using GPG on the terminal.

Inspect the Key File

Run:

gpg --list-packets private_key.asc

Look for:
	â€¢	:secret key packet:: Indicates the presence of a private key.
	â€¢	:public key packet:: Indicates the file contains a public key.

If you donâ€™t see :secret key packet:, the file does not contain private keys, and youâ€™ll need to export the private keys again.

2. Export the Correct Key (If Necessary)

If the file contains only public keys, you can export the private key using the following GPG command:

gpg --export-secret-keys --armor --output private_key.asc

This will generate an ASCII-armored private key file that can be used in Java.

3. Fix the Java Code

If the .asc file contains both public and private keys, you need to filter out only the private keys while parsing the file.

Updated Code to Handle Mixed Keys

Hereâ€™s the updated analyzeKeyFile method:

import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;

import java.io.FileInputStream;
import java.io.InputStream;

public class PGPKeyAnalyzer {

    public static void analyzeKeyFile(String privateKeyFilePath) throws Exception {
        try (InputStream keyInputStream = PGPUtil.getDecoderStream(new FileInputStream(privateKeyFilePath))) {
            // Load the secret keyring collection
            Object keyRingObject = new PGPObjectFactory(keyInputStream, new JcaKeyFingerprintCalculator()).nextObject();

            if (keyRingObject instanceof PGPSecretKeyRingCollection) {
                PGPSecretKeyRingCollection secretKeyRingCollection = (PGPSecretKeyRingCollection) keyRingObject;

                // Iterate through keyrings
                for (PGPSecretKeyRing secretKeyRing : secretKeyRingCollection) {
                    System.out.println("Secret Keyring ID: " + Long.toHexString(secretKeyRing.getPublicKey().getKeyID()));

                    // Iterate through keys (primary and subkeys)
                    for (PGPSecretKey secretKey : secretKeyRing) {
                        System.out.println("  Secret Key ID: " + Long.toHexString(secretKey.getKeyID()));
                        System.out.println("  Is Signing Key: " + secretKey.isSigningKey());
                    }
                }
            } else if (keyRingObject instanceof PGPPublicKeyRingCollection) {
                System.out.println("The file contains only public keys.");
            } else {
                System.out.println("Unrecognized keyring type: " + keyRingObject.getClass().getName());
            }
        }
    }

    public static void main(String[] args) {
        try {
            String privateKeyPath = "path/to/private_key.asc";
            analyzeKeyFile(privateKeyPath);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Explanation
	1.	Check Keyring Type:
	â€¢	Use PGPObjectFactory to parse the file.
	â€¢	The nextObject() method helps identify whether the file contains a PGPSecretKeyRingCollection or a PGPPublicKeyRingCollection.
	2.	Filter Secret Keys:
	â€¢	If the object is a PGPSecretKeyRingCollection, iterate through the secret keys.
	â€¢	If the object is a PGPPublicKeyRingCollection, it means the file contains only public keys.
	3.	Fallback Handling:
	â€¢	Print a message if the file contains unrecognized or unsupported keyring types.

4. Debugging Tips

If you still encounter issues, check the following:
	1.	File Content:
	â€¢	Ensure the file contains private keys (:secret key packet:) by running:

gpg --list-packets private_key.asc


	2.	Key Format:
	â€¢	Ensure the file is ASCII-armored. If not, convert it using GPG:

gpg --export-secret-keys --armor --output private_key.asc


	3.	Use Correct Keyring Type:
	â€¢	Public keys: Use PGPPublicKeyRingCollection.
	â€¢	Private keys: Use PGPSecretKeyRingCollection.
	4.	Dependencies:
	â€¢	Ensure youâ€™re using the latest version of Bouncy Castle (bcprov-jdk15on).

Let me know if this resolves your issue or if you need further assistance! ðŸš€


import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;

import java.io.FileInputStream;
import java.io.InputStream;

public class PGPKeyAnalyzer {

    public static void analyzeKeyFile(String privateKeyFilePath) throws Exception {
        try (InputStream keyInputStream = PGPUtil.getDecoderStream(new FileInputStream(privateKeyFilePath))) {
            // Load the secret keyring collection
            Object keyRingObject = new PGPObjectFactory(keyInputStream, new JcaKeyFingerprintCalculator()).nextObject();

            if (keyRingObject instanceof PGPSecretKeyRingCollection) {
                PGPSecretKeyRingCollection secretKeyRingCollection = (PGPSecretKeyRingCollection) keyRingObject;

                // Iterate through keyrings
                for (PGPSecretKeyRing secretKeyRing : secretKeyRingCollection) {
                    System.out.println("Secret Keyring ID: " + Long.toHexString(secretKeyRing.getPublicKey().getKeyID()));

                    // Iterate through keys (primary and subkeys)
                    for (PGPSecretKey secretKey : secretKeyRing) {
                        System.out.println("  Secret Key ID: " + Long.toHexString(secretKey.getKeyID()));
                        System.out.println("  Is Signing Key: " + secretKey.isSigningKey());
                    }
                }
            } else if (keyRingObject instanceof PGPPublicKeyRingCollection) {
                System.out.println("The file contains only public keys.");
            } else {
                System.out.println("Unrecognized keyring type: " + keyRingObject.getClass().getName());
            }
        }
    }

    public static void main(String[] args) {
        try {
            String privateKeyPath = "path/to/private_key.asc";
            analyzeKeyFile(privateKeyPath);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
