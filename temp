I see your code in the photo üëç ‚Äî right now your `InvoiceBucketResolver` is hard-wired to `InvoiceType` only. The duplication worry you raised earlier comes from writing the same extractors for both `InvoiceType` and `CreditNoteType`.

You can generalize it without copy-pasting by writing helper methods that work on the **common UBL aggregate types** (`List<DocumentReferenceType>`, `AccountingSupplierPartyType` ‚Üí `PartyType`). Then both `InvoiceType` and `CreditNoteType` can feed into the same resolver.

Here‚Äôs how you can refactor your current code:

```java
@Service
@RequiredArgsConstructor
public class InvoiceBucketResolver {

    private final SupplierService supplierService; // or SupplierRepository
    private static final Set<String> PREFIXES = Set.of("12","13","14","15","19");

    // ---- Public entry points ----
    public String resolveBucket(InvoiceType invoice) {
        return resolve(invoice.getContractDocumentReference(),
                       partyOf(invoice.getAccountingSupplierParty()));
    }

    public String resolveBucket(CreditNoteType creditNote) {
        return resolve(creditNote.getContractDocumentReference(),
                       partyOf(creditNote.getAccountingSupplierParty()));
    }

    // ---- Core logic ----
    private String resolve(List<DocumentReferenceType> contractRefs, PartyType party) {
        String contractId = firstId(contractRefs);
        String supplierCompanyId = firstCompanyId(party);

        boolean contractMatch = contractId != null && PREFIXES.stream().anyMatch(contractId::startsWith);
        boolean knownSupplier = supplierCompanyId != null && supplierService.isKnownSupplier(supplierCompanyId);

        // If either rule applies, go "miles"
        return (contractMatch || knownSupplier) ? "miles" : "finance";
    }

    // ---- Small helpers ----
    private PartyType partyOf(AccountingSupplierPartyType asp) {
        return asp != null ? asp.getParty() : null;
    }

    private String firstId(List<DocumentReferenceType> refs) {
        return (refs != null && !refs.isEmpty() && refs.get(0).getID() != null)
                ? refs.get(0).getID().getValue() : null;
    }

    private String firstCompanyId(PartyType party) {
        if (party == null || party.getPartyTaxScheme() == null || party.getPartyTaxScheme().isEmpty()) return null;
        PartyTaxSchemeType pts = party.getPartyTaxScheme().get(0);
        return pts.getCompanyID() != null ? pts.getCompanyID().getValue() : null;
    }
}
```

### Key changes compared to your current code

* **No duplication**: one `resolve` method that works with UBL common types.
* **Two tiny overloads**: one for `InvoiceType`, one for `CreditNoteType`.
* Helper methods (`firstId`, `firstCompanyId`) extract values safely.
* Logic stays exactly the same (`contract prefix OR known supplier ‚áí "miles"`).

---

üëâ Do you want me to also adapt your **JUnit test class** (the one I gave earlier) so it covers both `InvoiceType` and `CreditNoteType` against this new refactored resolver? That would let you drop it straight in and verify both paths.



Here‚Äôs a compact JUnit 5 test for the refactored `InvoiceBucketResolver` that supports both `InvoiceType` and `CreditNoteType`. It uses Mockito to stub `SupplierService.isKnownSupplier(...)`. Adjust package names for your generated UBL classes if they differ.

```java
package com.alphacredit.batch.service;

import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.CompanyIDType;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

/** Tests for InvoiceBucketResolver (InvoiceType + CreditNoteType). */
@ExtendWith(MockitoExtension.class)
class InvoiceBucketResolverTest {

    @Mock SupplierService supplierService;

    private InvoiceBucketResolver resolver;

    @BeforeEach
    void setUp() {
        resolver = new InvoiceBucketResolver(supplierService);
    }

    // ---------- InvoiceType ----------

    @Test
    void invoice_prefixMatch_goesMiles() {
        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("12-ABC")); // prefix rule
        inv.setAccountingSupplierParty(asp(null));                 // no supplier id

        String bucket = resolver.resolveBucket(inv);

        assertThat(bucket).isEqualTo("miles");
        verifyNoInteractions(supplierService);
    }

    @Test
    void invoice_supplierKnown_goesMiles() {
        when(supplierService.isKnownSupplier("BE0123")).thenReturn(true);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("99-NOPE")); // no prefix
        inv.setAccountingSupplierParty(asp("BE0123"));             // supplier match

        String bucket = resolver.resolveBucket(inv);

        assertThat(bucket).isEqualTo("miles");
        verify(supplierService).isKnownSupplier("BE0123");
    }

    @Test
    void invoice_noMatch_goesFinance() {
        when(supplierService.isKnownSupplier("BE999")).thenReturn(false);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("77-XYZ")); // no prefix
        inv.setAccountingSupplierParty(asp("BE999"));             // not known

        assertThat(resolver.resolveBucket(inv)).isEqualTo("finance");
        verify(supplierService).isKnownSupplier("BE999");
    }

    @Test
    void invoice_nullSafe_emptyData_goesFinance() {
        InvoiceType inv = new InvoiceType(); // no refs, no party
        assertThat(resolver.resolveBucket(inv)).isEqualTo("finance");
        verifyNoInteractions(supplierService);
    }

    // ---------- CreditNoteType ----------

    @Test
    void creditNote_prefixMatch_goesMiles() {
        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("15-HELLO"));
        cn.setAccountingSupplierParty(asp(null));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("miles");
        verifyNoInteractions(supplierService);
    }

    @Test
    void creditNote_supplierKnown_goesMiles() {
        when(supplierService.isKnownSupplier("BE777")).thenReturn(true);

        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("88-NOPE"));
        cn.setAccountingSupplierParty(asp("BE777"));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("miles");
        verify(supplierService).isKnownSupplier("BE777");
    }

    @Test
    void creditNote_noMatch_goesFinance() {
        when(supplierService.isKnownSupplier("BE000")).thenReturn(false);

        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("91-OTHER"));
        cn.setAccountingSupplierParty(asp("BE000"));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("finance");
        verify(supplierService).isKnownSupplier("BE000");
    }

    // ---------- Helpers ----------

    private static DocumentReferenceType docRef(String idValue) {
        DocumentReferenceType dr = new DocumentReferenceType();
        IDType id = new IDType();
        id.setValue(idValue);
        dr.setID(id);
        return dr;
    }

    private static AccountingSupplierPartyType asp(String companyId) {
        AccountingSupplierPartyType asp = new AccountingSupplierPartyType();
        PartyType party = new PartyType();
        if (companyId != null) {
            PartyTaxSchemeType tax = new PartyTaxSchemeType();
            CompanyIDType cid = new CompanyIDType();
            cid.setValue(companyId);
            tax.setCompanyID(cid);
            party.getPartyTaxScheme().add(tax);
        }
        asp.setParty(party);
        return asp;
    }
}
```

If you‚Äôre not using AssertJ, replace:

```java
import static org.assertj.core.api.Assertions.assertThat;
```

with JUnit assertions:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
```

and change `assertThat(x).isEqualTo("miles")` ‚Üí `assertEquals("miles", x)`.
