

Awesome üéâ ‚Äî that‚Äôs the cleanest setup:

* **One reader** that looks at the XML root and unmarshals into either `InvoiceType` or `CreditNoteType`.
* **One step**, with a `ClassifierCompositeItemWriter<Object>` to delegate to your `XMLInvoiceWriter` and `XMLCreditNoteWriter`.

---

## ‚úÖ Reader (polymorphic)

```java
@Component
@StepScope
public class UblXmlReader implements ItemReader<Object> {

    private final Iterator<Resource> files;

    public UblXmlReader(@Value("#{jobParameters['inputFiles']}") List<Resource> resources) {
        this.files = resources.iterator();
    }

    @Override
    public Object read() throws Exception {
        if (!files.hasNext()) return null;

        Resource res = files.next();

        try (InputStream in = res.getInputStream()) {
            XMLStreamReader xsr = XMLInputFactory.newFactory().createXMLStreamReader(in);
            xsr.nextTag(); // advance to root element
            String root = xsr.getLocalName();

            if ("Invoice".equals(root)) {
                JAXBContext ctx = JAXBContext.newInstance(
                        oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class);
                return ctx.createUnmarshaller().unmarshal(res.getFile(), 
                        oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class).getValue();
            } else if ("CreditNote".equals(root)) {
                JAXBContext ctx = JAXBContext.newInstance(
                        oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class);
                return ctx.createUnmarshaller().unmarshal(res.getFile(), 
                        oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class).getValue();
            } else {
                throw new IllegalArgumentException("Unsupported UBL root element: " + root);
            }
        }
    }
}
```

---

## ‚úÖ Writer (classifier)

```java
@Configuration
public class WriterConfig {

    @Bean
    @StepScope
    @SuppressWarnings("unchecked")
    public ClassifierCompositeItemWriter<Object> ublClassifierWriter(
            XMLInvoiceWriter invoiceWriter,
            XMLCreditNoteWriter creditNoteWriter) {

        ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();

        cw.setClassifier(item -> {
            if (item instanceof oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType) {
                return (ItemWriter<Object>) (ItemWriter<?>) invoiceWriter;
            } else if (item instanceof oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType) {
                return (ItemWriter<Object>) (ItemWriter<?>) creditNoteWriter;
            } else {
                throw new IllegalArgumentException("Unsupported type: " + item.getClass());
            }
        });

        return cw;
    }
}
```

---

## ‚úÖ Step wiring

```java
@Bean
public Step xmlInvoiceStep(JobRepository repo,
                           PlatformTransactionManager tx,
                           UblXmlReader reader,
                           ClassifierCompositeItemWriter<Object> writer) {

    return new StepBuilder("xmlInvoiceStep", repo)
            .<Object, Object>chunk(10, tx)
            .reader(reader)
            .writer(writer)
            .build();
}
```

---

### üöÄ Flow

1. Reader peeks at XML root ‚Üí produces `InvoiceType` or `CreditNoteType`.
2. Classifier writer checks instance type ‚Üí routes to correct concrete writer.
3. You keep **specialized writer logic** (file naming, grouping, etc.) but have **only one step** to maintain.

---

üëâ Do you want me to also give you a **JUnit test** that feeds two XML files (one invoice, one credit note) into this step and proves they get routed to the right writer?

Perfect üëç now you‚Äôve got your `/processed` directory populated with the actual files you moved in there (inputs after fetch, outputs after upload).

To delete them only **if the batch job completed successfully**, the cleanest way is to use a **JobExecutionListener** that fires after the job ends:

---

## ‚úÖ Listener-based cleanup

```java
@Component
@RequiredArgsConstructor
public class CosProcessedCleanupListener implements JobExecutionListener {

    private final CosStorageService cos;

    @Value("${cos.bucket}")
    private String bucket;

    @Value("${cos.processed-prefix:processed/}")
    private String processedPrefix;

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            // list all objects under processed/ and delete
            List<String> keys = cos.listKeys(bucket, processedPrefix);
            keys.forEach(k -> cos.deleteObject(bucket, k));
        } else {
            // optional: leave processed/ intact for debugging
            log.warn("Job failed, keeping files in {}/{}", bucket, processedPrefix);
        }
    }
}
```

---

## ‚úÖ Service methods in your `CosStorageService`

```java
public List<String> listKeys(String bucket, String prefix) {
    List<String> keys = new ArrayList<>();
    ObjectListing listing = s3Client.listObjects(bucket, prefix);
    while (true) {
        for (S3ObjectSummary s : listing.getObjectSummaries()) {
            keys.add(s.getKey());
        }
        if (listing.isTruncated()) {
            listing = s3Client.listNextBatchOfObjects(listing);
        } else break;
    }
    return keys;
}

public void deleteObject(String bucket, String key) {
    s3Client.deleteObject(bucket, key);
}
```

---

## ‚úÖ Wiring it into your job

In your job config:

```java
@Bean
public Job invoiceJob(JobRepository repo, PlatformTransactionManager tx,
                      Step fetchStep, Step processStep, Step uploadStep,
                      CosProcessedCleanupListener cleanupListener) {
    return new JobBuilder("invoiceJob", repo)
        .listener(cleanupListener)  // attach listener here
        .start(fetchStep)
        .next(processStep)
        .next(uploadStep)
        .build();
}
```

---

### üîë Advantages

* Deletes only if the job `COMPLETED`.
* Leaves files if the job `FAILED` (so you can debug).
* No need to pass filenames around in execution context ‚Äî it just wipes the whole `processed/` prefix when successful.

---

üëâ Do you want me to adapt this so it **only deletes the specific keys your tasklets recorded in ExecutionContext** (instead of scanning all of `processed/`)? That‚Äôs safer if multiple jobs run in parallel.




You‚Äôre right ‚Äî those assertions only pass if your classes implement **value-based equality**.
Right now `SupplierEntity` and `CosConfig` only have `@Getter/@Setter`, so they inherit `Object.equals/hashCode` (identity). Two different instances ‚Üí **not equal**, and hash codes usually differ.

Below are two ways forward. I‚Äôll default to **fixing the tests** to match current code (identity semantics). If you want value-based equality instead, I‚Äôve added the exact Lombok changes + matching tests too.

---

# A) Keep current code (identity equality) ‚Äî ‚úÖ revised tests

## `SupplierEntityTest.java`

```java
package com.bnpp.pf.einvoice.connect.batch.entity;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class SupplierEntityTest {

    @Test
    void gettersAndSettersWork() {
        SupplierEntity s = new SupplierEntity();
        s.setId(1L);
        s.setEnterpriseNumber("ENT-123");
        s.setCompanyName("Alpha Ltd");

        assertThat(s.getId()).isEqualTo(1L);
        assertThat(s.getEnterpriseNumber()).isEqualTo("ENT-123");
        assertThat(s.getCompanyName()).isEqualTo("Alpha Ltd");
    }

    @Test
    void equalsIsIdentity_basedOnObjectImplementation() {
        SupplierEntity s1 = new SupplierEntity();
        s1.setEnterpriseNumber("ENT-123");

        SupplierEntity s2 = new SupplierEntity();
        s2.setEnterpriseNumber("ENT-123");

        // identity semantics
        assertThat(s1).isNotEqualTo(s2);
        assertThat(s1).isEqualTo(s1);
        assertThat(s1).isNotEqualTo(null);
    }

    @Test
    void toStringContainsFields() {
        SupplierEntity s = new SupplierEntity();
        s.setEnterpriseNumber("E-5");
        s.setCompanyName("Zeta Ltd");
        assertThat(s.toString()).contains("E-5").contains("Zeta Ltd");
    }
}
```

## `CosConfigTest.java`

```java
package com.bnpp.pf.einvoice.connect.cos.config;

import org.junit.jupiter.api.Test;
import org.springframework.test.util.ReflectionTestUtils;

import static org.assertj.core.api.Assertions.assertThat;

class CosConfigTest {

    @Test
    void gettersAndSettersWork() {
        CosConfig c = new CosConfig();
        c.setInstance("dev-instance");
        c.setTimeOut(30);
        assertThat(c.getInstance()).isEqualTo("dev-instance");
        assertThat(c.getTimeOut()).isEqualTo(30);
    }

    @Test
    void complexFieldsViaReflection() {
        CosConfig c = new CosConfig();
        Object bucket = new Object(); // replace with real Bucket if available
        Object iam = new Object();    // replace with real Iam if available
        ReflectionTestUtils.setField(c, "bucket", bucket);
        ReflectionTestUtils.setField(c, "iam", iam);
        assertThat(c.getBucket()).isSameAs(bucket);
        assertThat(c.getIam()).isSameAs(iam);
    }

    @Test
    void equalsIsIdentity_andToStringHasUsefulInfo() {
        CosConfig c1 = new CosConfig();
        c1.setInstance("A"); c1.setTimeOut(5);

        CosConfig c2 = new CosConfig();
        c2.setInstance("A"); c2.setTimeOut(5);

        // object identity semantics
        assertThat(c1).isNotEqualTo(c2);
        assertThat(c1).isEqualTo(c1);
        assertThat(c1.toString()).contains("A");
    }
}
```

These tests won‚Äôt assert hash equality/inequality (since `Object.hashCode()` is identity-based and not something we should rely on deterministically across JVMs). They still give you coverage for the class behavior you actually have.

---

# B) If you **want value-based equality** (optional) ‚Äî change Lombok + tests

## Production changes

### For JPA entities (recommended pattern)

Use a stable, unique business key (you already have `enterprise_number UNIQUE`), not the generated `id`:

```java
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "suppliers")
@Getter @Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class SupplierEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @EqualsAndHashCode.Include
    @Column(name = "enterprise_number", nullable = false, unique = true)
    private String enterpriseNumber;

    @Column(name = "company_name")
    private String companyName;
}
```

### For `CosConfig`

If you want simple value equality over its fields:

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "cos")
@Data // generates getters, setters, equals, hashCode, toString
public class CosConfig {
    private String instance;
    private Bucket bucket;
    private Iam iam;
    private int timeOut;
}
```

## Matching tests (when value-based equality is enabled)

```java
// SupplierEntity equality by enterpriseNumber
@Test
void supplierEqualityByBusinessKey() {
    SupplierEntity a = new SupplierEntity(); a.setEnterpriseNumber("ENT-123");
    SupplierEntity b = new SupplierEntity(); b.setEnterpriseNumber("ENT-123");
    assertThat(a).isEqualTo(b);
    assertThat(a.hashCode()).isEqualTo(b.hashCode());
}

// CosConfig value-based equality
@Test
void cosConfigValueEquality() {
    CosConfig c1 = new CosConfig(); c1.setInstance("A"); c1.setTimeOut(5);
    CosConfig c2 = new CosConfig(); c2.setInstance("A"); c2.setTimeOut(5);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
}
```

---

## Which should you pick?

* If you don‚Äôt want to modify production code right now, **use option A** (updated tests).
* If equality by content is desired (often useful for DTO/configs; for JPA be careful), **use option B**, with the JPA-friendly `@EqualsAndHashCode` approach on `SupplierEntity`.

If you tell me which route you prefer, I can adjust the rest of your suite in the same style.

```

These tests won‚Äôt assert hash equality/inequality (since `Object.hashCode()` is identity-based and not something we should rely on deterministically across JVMs). They still give you coverage for the class behavior you actually have.

---

# B) If you **want value-based equality** (optional) ‚Äî change Lombok + tests

## Production changes

### For JPA entities (recommended pattern)

Use a stable, unique business key (you already have `enterprise_number UNIQUE`), not the generated `id`:

```java
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "suppliers")
@Getter @Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class SupplierEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @EqualsAndHashCode.Include
    @Column(name = "enterprise_number", nullable = false, unique = true)
    private String enterpriseNumber;

    @Column(name = "company_name")
    private String companyName;
}
```

### For `CosConfig`

If you want simple value equality over its fields:

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "cos")
@Data // generates getters, setters, equals, hashCode, toString
public class CosConfig {
    private String instance;
    private Bucket bucket;
    private Iam iam;
    private int timeOut;
}
```

## Matching tests (when value-based equality is enabled)

```java
// SupplierEntity equality by enterpriseNumber
@Test
void supplierEqualityByBusinessKey() {
    SupplierEntity a = new SupplierEntity(); a.setEnterpriseNumber("ENT-123");
    SupplierEntity b = new SupplierEntity(); b.setEnterpriseNumber("ENT-123");
    assertThat(a).isEqualTo(b);
    assertThat(a.hashCode()).isEqualTo(b.hashCode());
}

// CosConfig value-based equality
@Test
void cosConfigValueEquality() {
    CosConfig c1 = new CosConfig(); c1.setInstance("A"); c1.setTimeOut(5);
    CosConfig c2 = new CosConfig(); c2.setInstance("A"); c2.setTimeOut(5);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
}
```

---

## Which should you pick?

* If you don‚Äôt want to modify production code right now, **use option A** (updated tests).
* If equality by content is desired (often useful for DTO/configs; for JPA be careful), **use option B**, with the JPA-friendly `@EqualsAndHashCode` approach on `SupplierEntity`.

If you tell me which route you prefer, I can adjust the rest of your suite in the same style.

```

---

### ‚úÖ What this covers

* **SupplierEntity**: all Lombok-generated getters/setters, `equals`, `hashCode`, `toString`.
* **CosConfig**: getters/setters, reflection injection for `bucket` + `iam`, equality/hashCode/toString.

---

üëâ Do you also want me to add **negative tests** (e.g. `equals` with different values, `null` checks) to hit more branches in Lombok-generated methods?
