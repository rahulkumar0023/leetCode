Yes — you can adapt the logic to support **both formats**:

* **New**: `A_01.pdf`, `A_02.csv`, etc.
* **Legacy**: `A.pdf` (and `A.csv`, `A.jpeg`, etc.)

Right now your `isAttachmentForBase()` only matches `base + "_"...`, so `A.pdf` is not considered an attachment and gets skipped.

---

## 1) Code change: accept `A.<ext>` as well as `A_<suffix>.<ext>`

Update your method like this (also keeps legacy `-` just in case):

```java
private boolean isAttachmentForBase(String fileName, String normalizedBase) {
    if (fileName == null || fileName.isBlank() || normalizedBase == null || normalizedBase.isBlank()) {
        return false;
    }

    String lower = fileName.toLowerCase(Locale.ROOT);

    // Never treat the XML itself as an attachment
    if (lower.equals(normalizedBase + ".xml")) {
        return false;
    }

    if (!lower.startsWith(normalizedBase)) {
        return false;
    }

    int baseLen = normalizedBase.length();
    if (lower.length() <= baseLen) {
        return false;
    }

    char separator = lower.charAt(baseLen);

    // Support: A_01.pdf (new), A.pdf (legacy), A-1.pdf (older legacy)
    return separator == '_' || separator == '.' || separator == '-';
}
```

✅ With this change:

* `A.pdf` matches (separator `.`)
* `A_01.pdf` matches (separator `_`)
* `A.xml` does **not** match
* `AB.pdf` does **not** match (doesn’t start with `A` + separator)

Your existing `copySingleAttachment()` already works for both:

* for `A.pdf`, suffix becomes `.pdf`
* for `A_01.pdf`, suffix becomes `_01.pdf`

So **no change needed** there.

---

## 2) JUnit 5 test class (high coverage + covers your “A.pdf is skipped” bug)

This covers:

* legacy `A.pdf`
* new `A_01.pdf`, `A_02.csv`
* not copying `A.xml`
* `shouldSkip()` branches
* invalid source dir branch
* IOException branch (by passing a “targetDir” that is actually a file)

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    @Test
    void moveAttachments_shouldCopyLegacyAndNewAttachments_andSkipXml() throws Exception {
        Path sourceDir = tempDir.resolve("source");
        Path targetDir = tempDir.resolve("target");
        Files.createDirectories(sourceDir);
        Files.createDirectories(targetDir);

        // Source files
        Files.writeString(sourceDir.resolve("A.xml"), "<xml/>");
        Files.write(sourceDir.resolve("A.pdf"), new byte[] { 1, 2, 3 });
        Files.write(sourceDir.resolve("A_01.pdf"), new byte[] { 4, 5 });
        Files.write(sourceDir.resolve("A_02.csv"), "x,y\n1,2\n".getBytes());
        Files.write(sourceDir.resolve("B.pdf"), new byte[] { 9 }); // should not match

        // Mock PathConfig -> unzipped/xml directory
        PathConfig pathConfig = mock(PathConfig.class);
        UnzippedPathConfig unzipped = mock(UnzippedPathConfig.class);
        when(pathConfig.getUnzipped()).thenReturn(unzipped);
        when(unzipped.getXml()).thenReturn(sourceDir);

        SplitAttachmentMover mover = new SplitAttachmentMover(pathConfig);

        List<Path> moved = mover.moveAttachments("A", "A.xml", targetDir);

        assertEquals(3, moved.size(), "Expected A.pdf, A_01.pdf, A_02.csv");

        assertTrue(Files.exists(targetDir.resolve("A.pdf")));
        assertTrue(Files.exists(targetDir.resolve("A_01.pdf")));
        assertTrue(Files.exists(targetDir.resolve("A_02.csv")));

        assertFalse(Files.exists(targetDir.resolve("A.xml")), "XML must not be copied as attachment");
        assertFalse(Files.exists(targetDir.resolve("B.pdf")), "Other base attachments must not be copied");
    }

    @Test
    void moveAttachments_shouldCreateUniqueNameIfTargetAlreadyExists() throws Exception {
        Path sourceDir = tempDir.resolve("source2");
        Path targetDir = tempDir.resolve("target2");
        Files.createDirectories(sourceDir);
        Files.createDirectories(targetDir);

        Files.writeString(sourceDir.resolve("A.xml"), "<xml/>");
        Files.write(sourceDir.resolve("A.pdf"), new byte[] { 1 });

        // Pre-create A.pdf in target to trigger uniqueIfExists()
        Files.write(targetDir.resolve("A.pdf"), new byte[] { 9 });

        PathConfig pathConfig = mock(PathConfig.class);
        UnzippedPathConfig unzipped = mock(UnzippedPathConfig.class);
        when(pathConfig.getUnzipped()).thenReturn(unzipped);
        when(unzipped.getXml()).thenReturn(sourceDir);

        SplitAttachmentMover mover = new SplitAttachmentMover(pathConfig);

        List<Path> moved = mover.moveAttachments("A", "A.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("A.pdf")));
        assertTrue(
            Files.exists(targetDir.resolve("A-2.pdf")),
            "Expected unique filename A-2.pdf when A.pdf already exists"
        );
    }

    @Test
    void moveAttachments_shouldReturnEmpty_whenShouldSkip() {
        PathConfig pathConfig = mock(PathConfig.class);
        SplitAttachmentMover mover = new SplitAttachmentMover(pathConfig);

        List<Path> moved = mover.moveAttachments(" ", "A.xml", tempDir.resolve("t"));
        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_shouldReturnEmpty_whenSourceDirMissing() {
        PathConfig pathConfig = mock(PathConfig.class);
        UnzippedPathConfig unzipped = mock(UnzippedPathConfig.class);
        when(pathConfig.getUnzipped()).thenReturn(unzipped);
        when(unzipped.getXml()).thenReturn(tempDir.resolve("does-not-exist"));

        SplitAttachmentMover mover = new SplitAttachmentMover(pathConfig);

        List<Path> moved = mover.moveAttachments("A", "A.xml", tempDir.resolve("t"));
        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_shouldReturnEmpty_onIOException_whenTargetDirIsAFile() throws IOException {
        Path sourceDir = tempDir.resolve("source3");
        Files.createDirectories(sourceDir);
        Files.writeString(sourceDir.resolve("A.xml"), "<xml/>");
        Files.write(sourceDir.resolve("A.pdf"), new byte[] { 1 });

        Path targetAsFile = tempDir.resolve("targetAsFile");
        Files.writeString(targetAsFile, "I am a file, not a directory");

        PathConfig pathConfig = mock(PathConfig.class);
        UnzippedPathConfig unzipped = mock(UnzippedPathConfig.class);
        when(pathConfig.getUnzipped()).thenReturn(unzipped);
        when(unzipped.getXml()).thenReturn(sourceDir);

        SplitAttachmentMover mover = new SplitAttachmentMover(pathConfig);

        List<Path> moved = mover.moveAttachments("A", "A.xml", targetAsFile);

        assertTrue(moved.isEmpty(), "Should return empty when createDirectories fails");
    }

    /**
     * These types must match your real project types.
     * If your Unzipped config class name differs, replace it accordingly.
     */
    interface PathConfig {
        UnzippedPathConfig getUnzipped();
    }

    interface UnzippedPathConfig {
        Path getXml();
    }
}
```

### Notes on the test

* I intentionally avoided Mockito `eq()` to match your Sonar guidance.
* If your real types are not `PathConfig` / `UnzippedPathConfig` (names differ), replace those interfaces with your actual classes, **or keep these interfaces and mock the real ones in your project**.

---

## 3) Why your PDF “disappeared”

Because with your current matcher:

```java
return lower.startsWith(normalizedBase + "_")
    && !lower.equals(normalizedBase + ".xml");
```

`A.pdf` does not start with `A_`, so it never gets copied. After the updated matcher, it will be picked up again.

---

If you paste your actual `PathConfig` / `getUnzipped()` classes (names + methods), I can adjust the test to compile in your repo exactly (no placeholder interfaces).
