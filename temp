import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.services.s3.model.ObjectListing;
import com.amazonaws.services.s3.model.S3ObjectSummary;
import org.springframework.core.io.InputStreamResource;

import java.util.ArrayList;
import java.util.List;

public class CosService {

    private final AmazonS3 s3Client = AmazonS3ClientBuilder.defaultClient();

    public List<InputStreamResource> fetchFiles(String bucketName, String prefix) {
        List<InputStreamResource> resources = new ArrayList<>();
        ObjectListing objectListing = s3Client.listObjects(bucketName, prefix);

        for (S3ObjectSummary summary : objectListing.getObjectSummaries()) {
            S3Object s3Object = s3Client.getObject(bucketName, summary.getKey());
            resources.add(new InputStreamResource(s3Object.getObjectContent()));
        }

        return resources;
    }
}


import org.bouncycastle.openpgp.PGPPrivateKey;
import org.bouncycastle.openpgp.PGPObjectFactory;
import org.bouncycastle.openpgp.PGPPublicKeyEncryptedData;
import org.bouncycastle.openpgp.PGPUtil;

import java.io.*;
import java.util.zip.ZipInputStream;

public class PgpDecryptionUtils {

    public InputStream decryptAndDecompress(InputStream encryptedInputStream, PGPPrivateKey privateKey, char[] passphrase) throws Exception {
        // Step 1: Decrypt the PGP file
        InputStream decryptedStream = decrypt(encryptedInputStream, privateKey, passphrase);

        // Step 2: Decompress the ZIP file
        return decompressZip(decryptedStream);
    }

    private InputStream decrypt(InputStream encryptedInputStream, PGPPrivateKey privateKey, char[] passphrase) throws Exception {
        InputStream pgpInputStream = PGPUtil.getDecoderStream(encryptedInputStream);
        PGPObjectFactory pgpObjectFactory = new PGPObjectFactory(pgpInputStream, null);

        PGPPublicKeyEncryptedData encryptedData = (PGPPublicKeyEncryptedData) pgpObjectFactory.nextObject();
        return new BufferedInputStream(encryptedData.getDataStream(privateKey, "BC"));
    }

    private InputStream decompressZip(InputStream decryptedStream) throws IOException {
        ZipInputStream zipInputStream = new ZipInputStream(decryptedStream);
        zipInputStream.getNextEntry(); // Access the first entry in the ZIP file
        return new BufferedInputStream(zipInputStream);
    }
}


import org.springframework.batch.item.file.MultiResourceItemReader;
import org.springframework.core.io.InputStreamResource;

import java.util.List;

public class DecryptingMultiResourceItemReader<T> extends MultiResourceItemReader<T> {

    private final PgpDecryptionUtils pgpDecryptionUtils;
    private final PGPPrivateKey privateKey;
    private final char[] passphrase;

    public DecryptingMultiResourceItemReader(PgpDecryptionUtils pgpDecryptionUtils, PGPPrivateKey privateKey, char[] passphrase) {
        this.pgpDecryptionUtils = pgpDecryptionUtils;
        this.privateKey = privateKey;
        this.passphrase = passphrase;
    }

    public void setEncryptedResources(List<InputStreamResource> encryptedResources) {
        setResources(encryptedResources.stream()
                .map(resource -> {
                    try {
                        return new InputStreamResource(pgpDecryptionUtils.decryptAndDecompress(resource.getInputStream(), privateKey, passphrase));
                    } catch (Exception e) {
                        throw new RuntimeException("Error decrypting and decompressing resource", e);
                    }
                }).toArray(InputStreamResource[]::new));
    }
}
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.mapping.DefaultLineMapper;
import org.springframework.batch.item.file.transform.DelimitedLineTokenizer;

@Bean
public FlatFileItemReader<MyData> flatFileItemReader() {
    FlatFileItemReader<MyData> reader = new FlatFileItemReader<>();
    reader.setLinesToSkip(1); // Skip header line

    DefaultLineMapper<MyData> lineMapper = new DefaultLineMapper<>();
    DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer();
    tokenizer.setNames("column1", "column2", "column3");
    lineMapper.setLineTokenizer(tokenizer);
    lineMapper.setFieldSetMapper(fieldSet -> new MyData(
            fieldSet.readString("column1"),
            fieldSet.readInt("column2"),
            fieldSet.readString("column3")
    ));
    reader.setLineMapper(lineMapper);

    return reader;
}


import org.springframework.batch.item.support.SynchronizedItemStreamReader;

@Bean
public SynchronizedItemStreamReader<MyData> synchronizedItemStreamReader(DecryptingMultiResourceItemReader<MyData> multiResourceItemReader) {
    SynchronizedItemStreamReader<MyData> synchronizedReader = new SynchronizedItemStreamReader<>();
    synchronizedReader.setDelegate(multiResourceItemReader);
    return synchronizedReader;
}

import org.springframework.context.annotation.Bean;

@Bean
public DecryptingMultiResourceItemReader<MyData> decryptingMultiResourceItemReader(CosService cosService, Decryptor decryptor) {
    // Step 1: Fetch the list of encrypted files from COS
    List<InputStreamResource> encryptedFiles = cosService.fetchFiles("my-bucket", "encrypted-files/");

    // Step 2: Pass the encrypted files to the reader
    DecryptingMultiResourceItemReader<MyData> multiResourceItemReader = new DecryptingMultiResourceItemReader<>(decryptor);
    multiResourceItemReader.setEncryptedResources(encryptedFiles);

    return multiResourceItemReader;
}



import java.io.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipFiles {

    public static void main(String[] args) {
        String[] filesToZip = {
                "/path/to/file1.txt",
                "/path/to/file2.txt"
        };
        String outputZipFile = "/path/to/output.zip";

        try {
            zipFiles(filesToZip, outputZipFile);
            System.out.println("Files zipped successfully to: " + outputZipFile);
        } catch (IOException e) {
            System.err.println("Error during zipping: " + e.getMessage());
        }
    }

    public static void zipFiles(String[] filesToZip, String outputZipFile) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(outputZipFile);
             ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos))) {

            for (String filePath : filesToZip) {
                File file = new File(filePath);

                if (!file.exists() || !file.isFile()) {
                    System.err.println("Skipping: " + filePath + " (not a valid file)");
                    continue;
                }

                // Create a new ZIP entry for the file
                ZipEntry entry = new ZipEntry(file.getName());
                zos.putNextEntry(entry);

                // Write file data into the ZIP entry
                try (FileInputStream fis = new FileInputStream(file)) {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = fis.read(buffer)) != -1) {
                        zos.write(buffer, 0, bytesRead);
                    }
                }

                zos.closeEntry();
                System.out.println("Added to ZIP: " + filePath);
            }
        }
    }
}
import java.io.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class UnzipFiles {

    public static void main(String[] args) {
        String zipFilePath = "/path/to/input.zip";
        String outputDirectory = "/path/to/extracted/";

        try {
            unzip(zipFilePath, outputDirectory);
            System.out.println("Files extracted successfully to: " + outputDirectory);
        } catch (IOException e) {
            System.err.println("Error during unzipping: " + e.getMessage());
        }
    }

    public static void unzip(String zipFilePath, String outputDirectory) throws IOException {
        try (FileInputStream fis = new FileInputStream(zipFilePath);
             ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis))) {

            ZipEntry entry;
            byte[] buffer = new byte[1024];

            while ((entry = zis.getNextEntry()) != null) {
                File outputFile = new File(outputDirectory, entry.getName());

                if (entry.isDirectory()) {
                    outputFile.mkdirs(); // Create directories
                } else {
                    // Ensure parent directories exist
                    outputFile.getParentFile().mkdirs();

                    // Write file content
                    try (FileOutputStream fos = new FileOutputStream(outputFile)) {
                        int bytesRead;
                        while ((bytesRead = zis.read(buffer)) != -1) {
                            fos.write(buffer, 0, bytesRead);
                        }
                    }
                }
                zis.closeEntry();
                System.out.println("Extracted: " + entry.getName());
            }
        }
    }
}


=========================================
import org.springframework.batch.item.file.MultiResourceItemReader;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

public class DecryptingMultiResourceItemReader<T> extends MultiResourceItemReader<T> {

    private final Decryptor decryptor; // Your decryption utility

    public DecryptingMultiResourceItemReader(Decryptor decryptor) {
        this.decryptor = decryptor;
    }

    public void setEncryptedResources(Resource[] encryptedResources) {
        // Wrap each resource with the decryption logic
        Resource[] decryptedResources = new Resource[encryptedResources.length];
        for (int i = 0; i < encryptedResources.length; i++) {
            try {
                decryptedResources[i] = decryptResource(encryptedResources[i]);
            } catch (Exception e) {
                throw new RuntimeException("Failed to decrypt resource: " + encryptedResources[i].getFilename(), e);
            }
        }
        super.setResources(decryptedResources);
    }

    private Resource decryptResource(Resource encryptedResource) throws Exception {
        InputStream encryptedStream = encryptedResource.getInputStream();

        // Use ByteArrayOutputStream to capture the decrypted output
        ByteArrayOutputStream decryptedOutputStream = new ByteArrayOutputStream();
        decryptor.decrypt(encryptedStream, decryptedOutputStream);

        // Convert the decrypted output to an InputStream and return it as a Resource
        InputStream decryptedInputStream = new ByteArrayInputStream(decryptedOutputStream.toByteArray());
        return new InputStreamResource(decryptedInputStream);
    }
}
=========================================
import java.io.InputStream;
import java.io.OutputStream;

public class Decryptor {

    public void decrypt(InputStream encryptedStream, OutputStream decryptedStream) throws Exception {
        // Your decryption logic here
        // Example: Using a PGP library to decrypt the stream
        System.out.println("Decrypting file...");
        // Write the decrypted data to the decryptedStream
    }
}

================================================================

import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;

import java.util.ArrayList;
import java.util.List;

public class CosService {

    public Resource[] fetchEncryptedFiles() {
        // Simulate fetching files from a COS bucket
        List<Resource> resources = new ArrayList<>();
        resources.add(new InputStreamResource(getClass().getResourceAsStream("/path/to/encrypted-file1.pgp")));
        resources.add(new InputStreamResource(getClass().getResourceAsStream("/path/to/encrypted-file2.pgp")));
        return resources.toArray(new Resource[0]);
    }
}

=============================================================

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BatchConfiguration {

    @Bean
    public DecryptingMultiResourceItemReader<MyData> decryptingMultiResourceItemReader(CosService cosService, Decryptor decryptor) {
        Resource[] encryptedFiles = cosService.fetchEncryptedFiles();

        DecryptingMultiResourceItemReader<MyData> multiResourceItemReader = new DecryptingMultiResourceItemReader<>(decryptor);
        multiResourceItemReader.setEncryptedResources(encryptedFiles);

        return multiResourceItemReader;
    }
}

===========================================================
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.item.ItemWriter;
import org.springframework.context.annotation.Bean;

@Configuration
public class StepConfiguration {

    @Bean
    public Step processStep(StepBuilderFactory stepBuilderFactory,
                            DecryptingMultiResourceItemReader<MyData> decryptingReader,
                            ItemWriter<MyData> itemWriter) {
        return stepBuilderFactory.get("processStep")
                .<MyData, MyData>chunk(10)
                .reader(decryptingReader)
                .writer(itemWriter)
                .build();
    }
}

=======================================================
import org.springframework.batch.item.ItemWriter;

import java.util.List;

public class MyDataWriter implements ItemWriter<MyData> {

    @Override
    public void write(List<? extends MyData> items) throws Exception {
        for (MyData item : items) {
            System.out.println("Processed Item: " + item);
        }
    }
}

