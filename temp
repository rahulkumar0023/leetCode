1. Store References and Clean Up via a StepExecutionListener
You can store the file paths (or even File references) in the Spring Batch ExecutionContext when you create the temporary files. Then, in a StepExecutionListener.afterStep() method, retrieve these references and delete the files manually.

Example: Adding File References to ExecutionContext
In your composite service (or wherever you create the temporary file), after you create the temp file you can store its absolute path in the ExecutionContext:

java
Copy
public Resource decryptAndUnzip(InputStream encryptedInputStream, StepExecution stepExecution) throws Exception {
    // --- Step 1: Decrypt into a temporary ZIP file ---
    File decryptedZipFile = File.createTempFile("decrypted-", ".zip");
    // Save file path for cleanup later
    stepExecution.getExecutionContext().put("decryptedZipFile", decryptedZipFile.getAbsolutePath());
    
    try (OutputStream fileOut = new FileOutputStream(decryptedZipFile)) {
        decryptionUtil.decrypt(encryptedInputStream, fileOut);
    }

    // --- Step 2: Unzip the decrypted ZIP file ---
    List<File> extractedFiles = unzipUtil.unzipFile(decryptedZipFile);
    if (extractedFiles == null || extractedFiles.isEmpty()) {
        throw new RuntimeException("No files extracted from the decrypted ZIP file.");
    }
    // For this example, pick the first extracted file and store its path for cleanup.
    File extractedFile = extractedFiles.get(0);
    stepExecution.getExecutionContext().put("extractedFile", extractedFile.getAbsolutePath());

    // --- Step 3: Wrap it as a Resource ---
    return new FileSystemResource(extractedFile);
}
Example: StepExecutionListener for Cleanup
Create a listener that deletes temporary files after the step completes:

java
Copy
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import java.io.File;

public class TempFileCleanupListener implements StepExecutionListener {

    @Override
    public void beforeStep(StepExecution stepExecution) {
        // No cleanup needed before the step starts.
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        // Retrieve file paths from the ExecutionContext
        String decryptedZipFilePath = stepExecution.getExecutionContext().getString("decryptedZipFile");
        String extractedFilePath = stepExecution.getExecutionContext().getString("extractedFile");

        if (decryptedZipFilePath != null) {
            File decryptedZipFile = new File(decryptedZipFilePath);
            if (decryptedZipFile.exists() && decryptedZipFile.delete()) {
                System.out.println("Deleted temporary decrypted ZIP file: " + decryptedZipFilePath);
            } else {
                System.err.println("Failed to delete temporary decrypted ZIP file: " + decryptedZipFilePath);
            }
        }

        if (extractedFilePath != null) {
            File extractedFile = new File(extractedFilePath);
            if (extractedFile.exists() && extractedFile.delete()) {
                System.out.println("Deleted temporary extracted file: " + extractedFilePath);
            } else {
                System.err.println("Failed to delete temporary extracted file: " + extractedFilePath);
            }
        }
        return stepExecution.getExitStatus();
    }
}
Then attach this listener to your step:

java
Copy
@Bean
public Step myStep() {
    return stepBuilderFactory.get("myStep")
            .<MyModel, MyModel>chunk(10)
            .reader(reader())
            .processor(processor())
            .writer(writer())
            .listener(new TempFileCleanupListener())
            .build();
}
2. Use a JobExecutionListener for Global Cleanup
If your job consists of multiple steps and you want a global cleanup after the whole job completes, you can create a JobExecutionListener instead:

java
Copy
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import java.io.File;

public class TempJobCleanupListener implements JobExecutionListener {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // No pre-cleanup logic needed here.
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // Retrieve temporary file paths from job execution context
        // (You would need to store them in the job context as well)
        String decryptedZipFilePath = jobExecution.getExecutionContext().getString("decryptedZipFile");
        String extractedFilePath = jobExecution.getExecutionContext().getString("extractedFile");

        if (decryptedZipFilePath != null) {
            File decryptedZipFile = new File(decryptedZipFilePath);
            if (decryptedZipFile.exists() && decryptedZipFile.delete()) {
                System.out.println("Deleted temporary decrypted ZIP file: " + decryptedZipFilePath);
            }
        }
        if (extractedFilePath != null) {
            File extractedFile = new File(extractedFilePath);
            if (extractedFile.exists() && extractedFile.delete()) {
                System.out.println("Deleted temporary extracted file: " + extractedFilePath);
            }
        }
    }
}
