got it — let’s cover the **`execute(...)`** of `FetchDecryptUnzipTasklet`.

Because I don’t see the full body of `execute`, I’ll give you a **drop-in test harness** that works for the common shapes I see in code like yours (Tasklet + `CosStorageService` + `PDPDecrypt` + unzip to `/tmp/unzipped/xml`). You only need to tweak 1–2 lines to match your `CosStorageService` download method name (I’ve shown 3 options).

## What this test does

* Builds a **real encrypted file**: `payload.zip.pgp` (zip contains a CSV).
* Mocks **`PDPDecrypt.decrypt(InputStream, OutputStream)`** to copy bytes (simulates successful decrypt).
* Mocks **`CosStorageService`** to “download” and hand your tasklet the encrypted file (choose A/B/C depending on your API).
* Runs **`tasklet.execute(contribution, chunkContext)`** with a real `StepExecution`.
* Asserts:

  * `RepeatStatus.FINISHED`
  * Unzipped files exist in **`/tmp/unzipped/xml`** (used by your `SplitPDFMover`)
  * (Optional) `hasCsv` flag set in the **Job/Step ExecutionContext** if your tasklet sets it.

> If your tasklet writes to a different target dir, change `TARGET_DIR`.

---

### `FetchDecryptUnzipTaskletExecuteTest.java`

```java
package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.cos.CosStorageService;   // adjust package
import com.bnpp.pf.einvoice.connect.pgp.PDPDecrypt;          // adjust package
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentMatchers;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

/**
 * Covers FetchDecryptUnzipTasklet.execute(...) end-to-end with real files:
 *  - mock CosStorageService to "download" the encrypted file
 *  - PDPDecrypt mock copies bytes (pretend decrypt)
 *  - execute() should decrypt, unzip, and (optionally) set hasCsv=true
 */
class FetchDecryptUnzipTaskletExecuteTest {

  private static final Path TARGET_DIR = Path.of("/tmp/unzipped/xml/"); // align with your code

  @TempDir Path tmp;

  private PDPDecrypt pdpDecrypt;
  private CosStorageService cos;
  private FetchDecryptUnzipTasklet tasklet;

  @BeforeEach
  void setUp() {
    pdpDecrypt = mock(PDPDecrypt.class);
    cos = mock(CosStorageService.class);
    tasklet = new FetchDecryptUnzipTasklet();

    // Inject mocks into the tasklet (field names must match your class)
    ReflectionTestUtils.setField(tasklet, "pdpDecrypt", pdpDecrypt);
    ReflectionTestUtils.setField(tasklet, "cosStorageService", cos);

    // If your tasklet uses configurable dirs/keys via @Value, inject them too:
    // ReflectionTestUtils.setField(tasklet, "sourceBucket", "test-bucket");
    // ReflectionTestUtils.setField(tasklet, "objectKey", "payload.zip.pgp");
    // ReflectionTestUtils.setField(tasklet, "targetDir", TARGET_DIR); // if a field exists
  }

  @Test
  void execute_downloadsDecryptsAndUnzips_thenFinishes() throws Exception {
    // ---------- Arrange a real encrypted file: payload.zip.pgp ----------
    Path zip = buildZipWithCsv(tmp.resolve("payload.zip"));        // zip with 1 csv
    Path encrypted = tmp.resolve("payload.zip.pgp");               // "encrypted" wrapper file
    Files.copy(zip, encrypted, StandardCopyOption.REPLACE_EXISTING);

    // PDPDecrypt: simply copies bytes from in->out
    doAnswer(inv -> { try (InputStream in = inv.getArgument(0);
                           OutputStream out = inv.getArgument(1)) { in.transferTo(out); }
                   return null; })
        .when(pdpDecrypt).decrypt(any(InputStream.class), any(OutputStream.class));

    // CosStorageService: choose ONE of the following stubs to match your API:

    // A) If execute() does: cos.downloadToTemp(...) and returns a Path/File
    // when(cos.downloadToTemp(anyString(), anyString())).thenReturn(encrypted);

    // B) If execute() does: cos.getObjectStream(...), returns InputStream
    // when(cos.getObjectStream(anyString(), anyString()))
    //     .thenAnswer(a -> Files.newInputStream(encrypted));

    // C) If execute() does: cos.download(bucket, key, destinationPath)
    // doAnswer(a -> { Path dest = a.getArgument(2); Files.copy(encrypted, dest,
    //     StandardCopyOption.REPLACE_EXISTING); return null; })
    //     .when(cos).download(anyString(), anyString(), any(Path.class));

    // ---- Pick ONE stub above and delete the others. ----------------------

    // Build a real StepContribution & ChunkContext
    StepExecution stepExecution = new StepExecution("fetchDecryptUnzip", new JobExecution(123L));
    StepContribution contribution = new StepContribution(stepExecution);
    ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

    // Optionally prime parameters/context if your execute() reads them:
    // stepExecution.getJobParameters().getParameters().put("objectKey", new JobParameter("payload.zip.pgp"));
    // stepExecution.getExecutionContext().put("cosKey", "payload.zip.pgp");

    // Ensure target dir starts clean
    if (Files.exists(TARGET_DIR)) {
      try (var s = Files.list(TARGET_DIR)) { s.forEach(p -> p.toFile().delete()); }
    }
    Files.createDirectories(TARGET_DIR);

    // ---------- Act ----------
    RepeatStatus status = tasklet.execute(contribution, chunkContext);

    // ---------- Assert ----------
    assertThat(status).isEqualTo(RepeatStatus.FINISHED);

    // the CSV from the zip should now exist under the target dir
    boolean csvPresent = Files.list(TARGET_DIR)
        .anyMatch(p -> p.getFileName().toString().toLowerCase().endsWith(".csv"));
    assertThat(csvPresent).isTrue();

    // If your execute() sets a hasCsv flag in EC (used by CsvFilePresenceDecider), assert it:
    Object hasCsv = stepExecution.getJobExecution().getExecutionContext().get("hasCsv");
    // If your code sets it, uncomment the line below:
    // assertThat(hasCsv).isEqualTo(Boolean.TRUE);

    // verify decrypter used
    verify(pdpDecrypt, atLeastOnce()).decrypt(any(InputStream.class), any(OutputStream.class));
    // verify cos called at least once (adapt to your stub)
    // verify(cos, atLeastOnce()).downloadToTemp(anyString(), anyString());
  }

  // ----------------- helpers -----------------

  private static Path buildZipWithCsv(Path zipPath) throws Exception {
    Files.createDirectories(zipPath.getParent());
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zipPath))) {
      zos.putNextEntry(new ZipEntry("invoices/sample.csv"));
      zos.write("id,amount\n1,100.00\n".getBytes(StandardCharsets.UTF_8));
      zos.closeEntry();
    }
    return zipPath;
  }
}
```

### If `execute()` also handles error paths

Add one more test that makes `pdpDecrypt.decrypt(..)` throw an `IOException` (or make `CosStorageService` throw). Then assert whether your `execute()`:

* returns `RepeatStatus.FINISHED` and sets `hasCsv=false`, **or**
* throws (then assertThrows).

```java
@Test
void execute_handlesDecryptionError() throws Exception {
  // make cos stub hand back a file as above…
  doThrow(new IOException("boom"))
      .when(pdpDecrypt).decrypt(any(InputStream.class), any(OutputStream.class));

  StepExecution se = new StepExecution("s", new JobExecution(1L));
  StepContribution c = new StepContribution(se);
  ChunkContext cc = new ChunkContext(new StepContext(se));

  // either:
  // assertThatThrownBy(() -> tasklet.execute(c, cc)).isInstanceOf(Exception.class);
  // or (if you swallow and flag):
  // RepeatStatus rs = tasklet.execute(c, cc);
  // assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
  // assertThat(se.getJobExecution().getExecutionContext().get("hasCsv")).isEqualTo(Boolean.FALSE);
}
```

---

### Why this will bump coverage

This runs the **real control flow in `execute()`** (download → decrypt → unzip → context flags), exercising:

* field injections (both services)
* success path branches
* filesystem side-effects at the same locations your production components use.

If you paste the test and pick the correct **CosStorageService** stub (A/B/C), you should see `execute(...)` turn green. If you drop the exact body of `execute` here, I’ll pin the stub to your method signature and add the negative test to match your error handling precisely.
