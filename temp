package com.yourcompany.batch.cos;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.test.MetaDataInstanceFactory;

import static org.mockito.Mockito.*;

class CosProcessedCleanupListenerTest {

    private CosService cosService;
    private CosProcessedCleanupListener listener;
    private CosProcessedContextSupport contextSupport;

    @BeforeEach
    void setUp() {
        cosService = Mockito.mock(CosService.class);
        listener = new CosProcessedCleanupListener(cosService);
        contextSupport = listener; // listener implements CosProcessedContextSupport
    }

    @Test
    void afterJob_whenCompleted_shouldDeleteOnlyRecordedKeysWithProcessedPrefix() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobExecution, "step1");

        // store just file names in context
        contextSupport.addProcessedKey(stepExecution, "in1.csv.zip.pgp");
        contextSupport.addProcessedKey(stepExecution, "in2.csv.zip.pgp");

        jobExecution.setStatus(BatchStatus.COMPLETED);

        // when
        listener.afterJob(jobExecution);

        // then ‚Äì verify the exact keys passed to deleteObject
        verify(cosService).deleteObject("/processed/in1.csv.zip.pgp");
        verify(cosService).deleteObject("/processed/in2.csv.zip.pgp");
        verifyNoMoreInteractions(cosService);
    }

    @Test
    void afterJob_whenCompletedAndNoKeys_shouldNotCallCos() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        jobExecution.setStatus(BatchStatus.COMPLETED);

        // when
        listener.afterJob(jobExecution);

        // then
        verifyNoInteractions(cosService);
    }

    @Test
    void afterJob_whenNotCompleted_shouldNotDeleteAnythingEvenIfKeysExist() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobExecution, "step1");

        contextSupport.addProcessedKey(stepExecution, "in1.csv.zip.pgp");
        jobExecution.setStatus(BatchStatus.FAILED);

        // when
        listener.afterJob(jobExecution);

        // then
        verifyNoInteractions(cosService);
    }
}


Nice, we‚Äôre at the testing phase üòÑ
I‚Äôll give you **two JUnit 5 test classes**:

1. `CosProcessedContextSupportTest` ‚Äì tests the default methods `addProcessedKey` and `getProcessedKeys`.
2. `CosProcessedCleanupListenerTest` ‚Äì tests that the listener deletes only the recorded keys and respects the job status.

I‚Äôll assume:

* You use **Spring Batch** with `spring-batch-test` (for `MetaDataInstanceFactory`).
* You use **Mockito**.
* Your listener looks roughly like the one we discussed:

```java
@Component
public class CosProcessedCleanupListener implements JobExecutionListener, CosProcessedContextSupport {

    private final CosService cosService;

    public CosProcessedCleanupListener(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) { }

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() != BatchStatus.COMPLETED) {
            return;
        }

        List<String> processedKeys = getProcessedKeys(jobExecution);
        if (processedKeys.isEmpty()) {
            return;
        }

        processedKeys.forEach(cosService::deleteObject);
    }
}
```

If your method name is `deleteFile` instead of `deleteObject`, just adjust in the tests.

---

## 1Ô∏è‚É£ JUnit for `CosProcessedContextSupport`

```java
package com.yourcompany.batch.cos;

import org.junit.jupiter.api.Test;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.test.MetaDataInstanceFactory;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class CosProcessedContextSupportTest {

    // Anonymous implementation just to test the default methods
    private final CosProcessedContextSupport support = new CosProcessedContextSupport() {};

    @Test
    void addProcessedKey_shouldStoreKeysInJobExecutionContext() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobExecution, "testStep");

        // when
        support.addProcessedKey(stepExecution, "processed/file1.csv.zip.pgp");
        support.addProcessedKey(stepExecution, "processed/file2.csv.zip.pgp");

        // then
        List<String> keys = support.getProcessedKeys(jobExecution);
        assertThat(keys)
                .hasSize(2)
                .containsExactly(
                        "processed/file1.csv.zip.pgp",
                        "processed/file2.csv.zip.pgp"
                );
    }

    @Test
    void getProcessedKeys_shouldReturnEmptyListWhenNoneStored() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();

        // when
        List<String> keys = support.getProcessedKeys(jobExecution);

        // then
        assertThat(keys).isEmpty();
    }
}
```

**What this verifies:**

* `addProcessedKey`:

  * Uses the **job** `ExecutionContext`.
  * Appends keys and re-stores the list.
* `getProcessedKeys`:

  * Returns an empty list if nothing is stored (no NPE, no cast issues).

---

## 2Ô∏è‚É£ JUnit for `CosProcessedCleanupListener`

Here we test three scenarios:

1. `COMPLETED` + keys recorded ‚Üí deletes them all.
2. `COMPLETED` + no keys recorded ‚Üí does nothing.
3. `FAILED` (or anything non-COMPLETED) + keys recorded ‚Üí does nothing.

```java
package com.yourcompany.batch.cos;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.test.MetaDataInstanceFactory;

import static org.mockito.Mockito.*;

class CosProcessedCleanupListenerTest {

    private CosService cosService;
    private CosProcessedCleanupListener listener;

    // We want to reuse the default methods from the listener itself
    private CosProcessedContextSupport contextSupport;

    @BeforeEach
    void setUp() {
        this.cosService = Mockito.mock(CosService.class);
        this.listener = new CosProcessedCleanupListener(cosService);
        this.contextSupport = listener; // it implements CosProcessedContextSupport
    }

    @Test
    void afterJob_whenCompleted_shouldDeleteOnlyRecordedKeys() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobExecution, "step1");

        // record keys via default method
        contextSupport.addProcessedKey(stepExecution, "processed/incoming/file1.csv.zip.pgp");
        contextSupport.addProcessedKey(stepExecution, "processed/outgoing/file2.xml.zip.pgp");

        jobExecution.setStatus(BatchStatus.COMPLETED);

        // when
        listener.afterJob(jobExecution);

        // then
        verify(cosService).deleteObject("processed/incoming/file1.csv.zip.pgp");
        verify(cosService).deleteObject("processed/outgoing/file2.xml.zip.pgp");
        verifyNoMoreInteractions(cosService);
    }

    @Test
    void afterJob_whenCompletedAndNoKeys_shouldNotCallCos() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        jobExecution.setStatus(BatchStatus.COMPLETED);

        // when
        listener.afterJob(jobExecution);

        // then
        verifyNoInteractions(cosService);
    }

    @Test
    void afterJob_whenNotCompleted_shouldNotDeleteAnythingEvenIfKeysExist() {
        // given
        JobExecution jobExecution = MetaDataInstanceFactory.createJobExecution();
        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobExecution, "step1");

        // record one key
        contextSupport.addProcessedKey(stepExecution, "processed/incoming/file1.csv.zip.pgp");

        jobExecution.setStatus(BatchStatus.FAILED); // or STOPPED, etc.

        // when
        listener.afterJob(jobExecution);

        // then
        verifyNoInteractions(cosService);
    }
}
```

If your service uses a different method name:

* `cosService.deleteFile(key)` instead of `deleteObject(key)` ‚Üí just change in the tests.

---

## Small recap of how this all ties together

* Tasklets (fetch/upload) call `addProcessedKey(stepExecution, key)` when they move/upload files into `/processed/...`.
* These keys are stored in the **job** `ExecutionContext` under `processedCosKeys`.
* `CosProcessedCleanupListener.afterJob(jobExecution)`:

  * If status != `COMPLETED` ‚Üí skip.
  * Otherwise, call `getProcessedKeys(jobExecution)` ‚Üí list of keys for this run.
  * If list is non-empty ‚Üí delete **only** those keys.

So now you can:

* Keep `/processed` when there were **no files** or the job **failed**.
* Clean up only what you actually touched in a **successful** run.

If you paste your current `CosService` interface (method names), I can tweak the tests to fit it exactly.




Yes üíØ ‚Äî that‚Äôs exactly what you want:
‚úÖ record only the keys you touched (fetched/uploaded),
‚úÖ then in `CosProcessedCleanupListener` delete *only* those keys.

Here‚Äôs a **step-by-step implementation** using a small **helper interface** that both tasklets + listener can reuse.

---

## Step 1 ‚Äì Create a shared helper interface for the ExecutionContext

This gives you reusable default methods to add/get keys from the **job** `ExecutionContext`.

```java
package com.yourcompany.batch.cos;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.item.ExecutionContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public interface CosProcessedContextSupport {

    String PROCESSED_COS_KEYS = "processedCosKeys";

    @SuppressWarnings("unchecked")
    default void addProcessedKey(StepExecution stepExecution, String key) {
        JobExecution jobExecution = stepExecution.getJobExecution();
        ExecutionContext jobContext = jobExecution.getExecutionContext();

        List<String> keys = (List<String>) jobContext.get(PROCESSED_COS_KEYS);
        if (keys == null) {
            keys = new ArrayList<>();
        }

        keys.add(key);

        // ‚≠ê IMPORTANT: re-put so Spring Batch marks context as dirty
        jobContext.put(PROCESSED_COS_KEYS, keys);
    }

    @SuppressWarnings("unchecked")
    default List<String> getProcessedKeys(JobExecution jobExecution) {
        ExecutionContext jobContext = jobExecution.getExecutionContext();
        List<String> keys = (List<String>) jobContext.get(PROCESSED_COS_KEYS);
        if (keys == null) {
            return Collections.emptyList();
        }
        return keys;
    }
}
```

You‚Äôll use `addProcessedKey(...)` in **fetch** + **upload** tasklets, and `getProcessedKeys(...)` in the cleanup listener.

---

## Step 2 ‚Äì Fetch tasklet: record fetched/moved encrypted files

Assume you have something like:

```java
@Component
public class FetchEncryptedFilesTasklet implements Tasklet, CosProcessedContextSupport {

    private final CosService cosService;

    public FetchEncryptedFilesTasklet(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution,
                                ChunkContext chunkContext) throws Exception {

        StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();

        // Example: fetch and move to /processed
        List<String> incomingKeys = cosService.listIncomingEncryptedFiles(); 
        for (String key : incomingKeys) {
            // e.g. key = "incoming/myfile1.csv.zip.pgp"
            String processedKey = cosService.moveToProcessed(key); 
            // e.g. processedKey = "processed/incoming/myfile1.csv.zip.pgp"

            // üîπ Record this processed COS key in the job context
            addProcessedKey(stepExecution, processedKey);
        }

        return RepeatStatus.FINISHED;
    }
}
```

So now every encrypted file moved into `/processed/...` from this tasklet will be remembered.

---

## Step 3 ‚Äì Upload tasklet: also register outgoing files

Same pattern for outgoing/upload step.

```java
@Component
public class UploadFilesToCosTasklet implements Tasklet, CosProcessedContextSupport {

    private final CosService cosService;

    public UploadFilesToCosTasklet(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution,
                                ChunkContext chunkContext) throws Exception {

        StepExecution stepExecution = chunkContext.getStepContext().getStepExecution();

        // Example: upload generated XML/zip/pgp to outgoing/processed
        List<File> filesToUpload = getFilesFromLocalDir(); // your logic

        for (File file : filesToUpload) {
            String processedKey = cosService.uploadToProcessed(file);
            // e.g. "processed/outgoing/invoice_123.xml.zip.pgp"

            // üîπ Record processed key
            addProcessedKey(stepExecution, processedKey);
        }

        return RepeatStatus.FINISHED;
    }
}
```

Now both **incoming** and **outgoing** processed objects are tracked in the **same** list in the job `ExecutionContext`.

---

## Step 4 ‚Äì Implement `CosProcessedCleanupListener` that deletes only recorded keys

This listener runs *after the job* and deletes only the objects that were registered.

```java
package com.yourcompany.batch.cos;

import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class CosProcessedCleanupListener implements JobExecutionListener, CosProcessedContextSupport {

    private final CosService cosService;

    public CosProcessedCleanupListener(CosService cosService) {
        this.cosService = cosService;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // nothing
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        BatchStatus status = jobExecution.getStatus();

        // ‚ùå If job failed, do NOT clean processed
        if (status != BatchStatus.COMPLETED) {
            // keep all processed files for investigation
            return;
        }

        // ‚úÖ Only on COMPLETED, get recorded keys from job context
        List<String> processedKeys = getProcessedKeys(jobExecution);

        if (processedKeys.isEmpty()) {
            // This is the ‚Äúno file in COS‚Äù case --> nothing to delete, directory stays
            return;
        }

        for (String key : processedKeys) {
            try {
                cosService.deleteObject(key);  // only delete these keys
            } catch (Exception e) {
                // You can ignore "not found" errors if desired
                // or just log and continue
            }
        }
    }
}
```

**Behavior now:**

* **Job COMPLETED + some files processed**
  ‚Üí only those recorded keys under `/processed/...` are deleted.

* **Job FAILED / STOPPED**
  ‚Üí cleanup is skipped; `/processed` and all keys stay.

* **Job COMPLETED + no files in bucket** (your edge case)
  ‚Üí `processedKeys` is empty ‚Üí `afterJob` deletes nothing; `/processed` directory is preserved.

So you no longer rely on deleting ‚Äúthe entire `/processed` directory‚Äù, only the *objects* you recorded.

---

## Step 5 ‚Äì Wire the listener into the job

In your `Job` config:

```java
@Bean
public Job myCosJob(JobRepository jobRepository,
                    Step fetchStep,
                    Step uploadStep,
                    CosProcessedCleanupListener cosProcessedCleanupListener) {

    return new JobBuilder("myCosJob", jobRepository)
            .listener(cosProcessedCleanupListener)
            .start(fetchStep)
            .next(uploadStep)
            // ... other steps ...
            .build();
}
```

And make sure the steps use your tasklets that implement `CosProcessedContextSupport`.

---

If you want, you can paste your actual `CosService` and step definitions, and I can plug these pieces directly into your existing code with the exact method names you‚Äôre using.
