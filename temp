Thank you ‚Äî that clarifies everything.

You've used:

* ‚úÖ `org.jvnet.jaxb2.maven2:maven-jaxb2-plugin` ‚Üí **JAXB 2.x tooling (javax-based)**
* ‚ùå But you‚Äôre running it with **Jakarta JAXB 4.x runtime (jakarta-based)** at runtime

That **mismatch between class generation (javax) and runtime (jakarta)** is the core issue.

---

### ‚ùó Root Problem Recap

| Tool                                  | Namespace                                                   |
| ------------------------------------- | ----------------------------------------------------------- |
| `org.jvnet.jaxb2.maven2`              | ‚úÖ Generates `javax.xml.bind.annotation.*`                   |
| `org.glassfish.jaxb:jaxb-runtime:4.x` | ‚ùå Expects `jakarta.xml.bind.annotation.*`                   |
| Result                                | üö® PropertyException: `namespacePrefixMapper` not supported |

So: **generated classes are `javax`**, but the **runtime is `jakarta`** ‚Äî and those don't mix cleanly.

---

### ‚úÖ Option 1: **Switch Entirely to Jakarta Tooling** (Recommended)

**Step 1: Use Jakarta-compatible plugin to generate classes**

Replace the old plugin with:

```xml
<plugin>
  <groupId>org.glassfish.jaxb</groupId>
  <artifactId>jaxb-maven-plugin</artifactId>
  <version>4.0.2</version>
  <executions>
    <execution>
      <id>xjc</id>
      <goals><goal>xjc</goal></goals>
      <configuration>
        <sources>
          <source>src/main/resources/xsd</source>
        </sources>
        <packageName>com.mycompany.ubl.invoice</packageName>
        <outputDirectory>${project.build.directory}/generated-sources/jaxb</outputDirectory>
      </configuration>
    </execution>
  </executions>
</plugin>
```

This will generate classes with `jakarta.xml.bind.annotation.*` and solve the runtime mismatch.

**Step 2: Remove old `javax.xml.bind` artifacts from your dependencies**

**Step 3: Use Jakarta property key:**

```java
marshaller.setProperty("jakarta.xml.bind.namespacePrefixMapper", new MyNamespacePrefixMapper());
```

And extend:

```java
import org.glassfish.jaxb.runtime.marshaller.NamespacePrefixMapper;
```

---

### ‚úÖ Option 2: Stick with JAXB 2.x (Legacy-safe)

If switching tools isn't feasible (due to PEPPOL schemas or constraints), then:

**Step 1: Revert to JAXB 2.x runtime (`javax`)**

```xml
<dependency>
  <groupId>com.sun.xml.bind</groupId>
  <artifactId>jaxb-impl</artifactId>
  <version>2.3.5</version>
</dependency>
```

And use:

```java
marshaller.setProperty("com.sun.xml.bind.namespacePrefixMapper", new MyNamespacePrefixMapper());
```

Extending:

```java
import com.sun.xml.bind.marshaller.NamespacePrefixMapper;
```

This matches what the `org.jvnet.jaxb2.maven2` plugin generates.

‚úÖ **This will make `ns2`, `ns3` go away.**

---

### üß† TL;DR

You have two valid paths:

| Approach           | Generation Plugin                      | Runtime Dependency                              | Namespace   | PrefixMapper Property                    |
| ------------------ | -------------------------------------- | ----------------------------------------------- | ----------- | ---------------------------------------- |
| ‚úÖ Jakarta (modern) | `org.glassfish.jaxb:jaxb-maven-plugin` | `jakarta.xml.bind + glassfish jaxb-runtime:4.x` | `jakarta.*` | `jakarta.xml.bind.namespacePrefixMapper` |
| ‚úÖ Legacy (safe)    | `org.jvnet.jaxb2.maven2`               | `com.sun.xml.bind:jaxb-impl:2.3.x`              | `javax.*`   | `com.sun.xml.bind.namespacePrefixMapper` |

---

Would you like a ready-to-run Jakarta version of the UBL schema generation to get started quickly?
