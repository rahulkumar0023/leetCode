---
Yep ‚Äî below are concrete, copy-pasteable changes for both:
	1.	XmlInvoiceWriter (same pattern applies to XmlCreditNoteWriter too)
	2.	PackageAndUploadTasklet

Goal:
‚úÖ Put invoices into a per-invoice subdirectory only for MILES and FINANCE
‚úÖ Keep attachments in the same per-invoice folder
‚úÖ Ensure packaging still finds files recursively and zips them

‚∏ª

1) Changes in XmlInvoiceWriter

What we‚Äôll do

When you already resolved the base output directory (e.g. processed/xml/miles or processed/xml/finance), we will:
	‚Ä¢	derive a safe folder name from invoice id
	‚Ä¢	create outputDir = baseDir/<invoiceId>/ ONLY for miles+finance
	‚Ä¢	write XML into that folder
	‚Ä¢	move attachments into that same folder

Add these helpers in XmlInvoiceWriter

Put near other private helpers:

private Path resolveInvoiceSubDirIfNeeded(Path baseOutputDir, InvoiceType invoice) throws IOException {
    if (baseOutputDir == null) {
        throw new IOException("Base output directory is null");
    }

    String baseDirName = baseOutputDir.getFileName() != null ? baseOutputDir.getFileName().toString() : "";
    boolean isMilesOrFinance = MILES.equalsIgnoreCase(baseDirName) || "finance".equalsIgnoreCase(baseDirName);

    Path finalDir = baseOutputDir;

    if (isMilesOrFinance) {
        String invoiceId = safeInvoiceId(invoice);
        String folderName = sanitizeForFileName(invoiceId); // you already import this
        if (folderName == null || folderName.isBlank()) {
            throw new IOException("Invoice id is missing for miles/finance folder");
        }

        Path normalizedBase = baseOutputDir.toAbsolutePath().normalize();
        Path candidate = normalizedBase.resolve(folderName).normalize();

        if (!candidate.startsWith(normalizedBase)) {
            throw new IOException("Invalid invoice subdirectory");
        }

        Files.createDirectories(candidate);
        finalDir = candidate;
    }

    return finalDir;
}

private static String safeInvoiceId(InvoiceType invoice) {
    String id = null;
    if (invoice != null && invoice.getID() != null) {
        id = invoice.getID().getValue();
    }
    return id;
}

Now change updateInvoiceName(...) to use it

Find the place where you currently do:
	‚Ä¢	createOutputxml(invoice, outputDir, invoiceFileName);
	‚Ä¢	and then attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);

Replace with:

Path finalOutputDir = resolveInvoiceSubDirIfNeeded(outputDir, invoice);

createOutputxml(invoice, finalOutputDir, invoiceFileName);

if (isJobTypeXml) {
    String sourceInvoiceBase = registry.lookup(invoice); // used for attachment matching
    attachmentMover.moveAttachments(sourceInvoiceBase, invoiceFileName, finalOutputDir);
}

‚úÖ That‚Äôs the key change.
Everything else (bucket resolving, filename logic, etc.) can remain as-is.

Do the same thing in XmlCreditNoteWriter, just adapt types:
	‚Ä¢	CreditNoteType instead of InvoiceType
	‚Ä¢	and call safeCreditNoteId(...) accordingly.

‚∏ª

2) Changes in PackageAndUploadTasklet

Your tasklet currently:
	‚Ä¢	uses listFiles() / isEmptyPath(...) in a way that will treat ‚Äúfolder full of subfolders‚Äù as empty
	‚Ä¢	then zipDirectory(processedFile, zipFile) ‚Äî if that zip is not recursive, you‚Äôll miss everything

So we update:
	1.	isEmptyPath(...) ‚Üí recursive
	2.	zipDirectory(...) ‚Üí recursive file walk

‚∏ª

2.1 Replace isEmptyPath(...) with a recursive version

private static boolean isEmptyPath(Path root) throws IOException {
    boolean empty = true;

    if (root != null && Files.exists(root)) {
        try (var stream = Files.walk(root)) {
            empty = stream.filter(Files::isRegularFile).findFirst().isEmpty();
        }
    }

    return empty;
}

Optional: If you want better log counts (instead of listFiles().length), add:

private static long countFilesRecursively(Path root) throws IOException {
    long count = 0L;

    if (root != null && Files.exists(root)) {
        try (var stream = Files.walk(root)) {
            count = stream.filter(Files::isRegularFile).count();
        }
    }

    return count;
}

Then your logs for miles/finance can be:

log.info("Miles XML directory path: {} contains {} files", milesXmlPath, countFilesRecursively(milesXmlPath));

(Also: consider avoiding absolute paths in logs if Fortify is strict.)

‚∏ª

2.2 Make sure zipDirectory(...) is recursive

If your existing zipDirectory(...) is one-level, replace it with this:

private void zipDirectory(Path rootDir, File zipFile) throws IOException {
    Path normalizedRoot = rootDir.toAbsolutePath().normalize();

    try (var fos = new FileOutputStream(zipFile);
         var bos = new BufferedOutputStream(fos);
         var zos = new ZipOutputStream(bos)) {

        try (var paths = Files.walk(normalizedRoot)) {
            paths.filter(Files::isRegularFile).forEach(path -> {
                Path normalizedPath = path.toAbsolutePath().normalize();
                if (!normalizedPath.startsWith(normalizedRoot)) {
                    // safety check; should never happen
                    throw new UncheckedIOException(new IOException("Invalid path while zipping"));
                }

                String entryName = normalizedRoot.relativize(normalizedPath)
                        .toString()
                        .replace('\\', '/');

                ZipEntry entry = new ZipEntry(entryName);

                try {
                    zos.putNextEntry(entry);
                    Files.copy(normalizedPath, zos);
                    zos.closeEntry();
                } catch (IOException ex) {
                    throw new UncheckedIOException(ex);
                }
            });
        } catch (UncheckedIOException ex) {
            throw ex.getCause();
        }
    }
}

‚úÖ This will include:
	‚Ä¢	miles/<invoiceId>/...
	‚Ä¢	finance/<invoiceId>/...

inside the zip.

‚∏ª

2.3 Fortify/Sonar improvement in encrypt step (highly recommended)

You currently do:

pgpEncrypt.encrypt(new FileInputStream(zipFile), new FileOutputStream(encryptedFile));

Change to try-with-resources:

try (var in = new FileInputStream(zipFile);
     var out = new FileOutputStream(encryptedFile)) {
    pgpEncrypt.encrypt(in, out);
}


‚∏ª

Quick checklist after these changes

‚úÖ Writers create:
	‚Ä¢	processed/xml/miles/<invoiceId>/*.xml
	‚Ä¢	processed/xml/finance/<invoiceId>/*.xml
‚Ä¶and attachments land there too.

‚úÖ Tasklet:
	‚Ä¢	sees miles/finance as ‚Äúnot empty‚Äù even if only subfolders exist
	‚Ä¢	zips recursively, so it will include invoice folders + files

‚∏ª

If you want, paste your current zipDirectory(...) and isEmptyPath(...) implementations (or screenshots) and I‚Äôll tailor the patch to match your existing style and avoid any surprise diffs.

----

Understood. Right now your pipeline is doing:

* It **uses the XML** as the ‚Äútruth‚Äù to rename everything else ‚úÖ
* But when you **rename the XML itself**, you rebuild the name and accidentally drop the original trailing sequence (`_01`) ‚ùå

So you need one extra rule:

> **When generating the new XML filename, carry forward the trailing `_NNN` from the *source* XML name (`X_01.xml`) and append it to the *new* XML name.**

Because your attachments are renamed ‚Äúbased on the XML‚Äù, if the XML becomes `‚Ä¶_INV_123.xml` instead of `‚Ä¶_INV_123_01.xml`, then everything will follow the wrong base.

---

## Where to get the `_01` from

In your `XmlInvoiceWriter` you already do:

```java
String invoiceId = registry.lookup(invoice);
attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);
```

That `invoiceId` is your **source filename base**, usually coming from the unzipped XML name (e.g., `X_01` or `A1_B123_multiplethings_01`).
That‚Äôs the best place to extract the suffix.

---

## Fix: Preserve trailing sequence when building `invoiceFileName`

### 1) Add a helper that extracts trailing `_NNN`

No regex needed:

```java
private static String extractTrailingSequenceSuffix(String sourceBaseName) {
    if (sourceBaseName == null || sourceBaseName.isBlank()) {
        return "";
    }

    int lastUnderscore = sourceBaseName.lastIndexOf('_');
    if (lastUnderscore < 0) {
        return "";
    }

    String suffix = sourceBaseName.substring(lastUnderscore + 1);
    if (suffix.length() < 1 || suffix.length() > 3) {
        return "";
    }

    for (int i = 0; i < suffix.length(); i++) {
        char ch = suffix.charAt(i);
        if (ch < '0' || ch > '9') {
            return "";
        }
    }

    return "_" + suffix; // keep underscore
}
```

This supports:

* `X_01` ‚Üí `_01`
* `X_2` ‚Üí `_2`
* `X_999` ‚Üí `_999`
* `A1_B123_multiplethings_01` ‚Üí `_01`

‚Ä¶and ignores:

* `X_ABC`
* `X_0000`
* `X_01_more`

---

### 2) Apply it when generating the *new* XML filename

Inside your `updateInvoiceName(...)`, you currently build:

* `... + ".xml"`

Change it to:

* `... + suffix + ".xml"`

But you must compute `suffix` from the **source XML name**, not from the new name.

So do this inside the `isJobTypeXml` block:

```java
String invoiceId = registry.lookup(invoice); // e.g. "X_01"
String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);
...
invoiceFileName = /* your renamed base */ + trailingSuffix + ".xml";
createOutputxml(invoice, outputDir, invoiceFileName);
attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);
```

### Concretely, your finance branch becomes:

```java
String invoiceId = registry.lookup(invoice);
String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);

String supplierPartyRaw = invoiceBucketResolver.getSupplierName(invoice.getAccountingSupplierParty());
String supplierParty = sanitizeForFileName(supplierPartyRaw);
String invoiceNumberPart = sanitizeForFileName(invoice.getID().getValue());

invoiceFileName =
        getCurrentDateTimeValue()
                + (supplierParty != null ? supplierParty + "_" : "")
                + "_INV_" + invoiceNumberPart
                + trailingSuffix
                + ".xml";
```

And your non-finance branch becomes:

```java
String invoiceId = registry.lookup(invoice);
String trailingSuffix = extractTrailingSequenceSuffix(invoiceId);

String invoiceNumberPart = sanitizeForFileName(invoice.getID().getValue());

invoiceFileName =
        sanitizeForFileName(invoiceFileName)
                + "_INV_" + invoiceNumberPart + "_"
                + getCurrentDateTimeValue()
                + trailingSuffix
                + ".xml";
```

‚úÖ Result: `X_01.xml` renames to something like:

* `20260130_SUPPLIER_INV_123456_01.xml`
  ‚Ä¶and then attachments become:
* `20260130_SUPPLIER_INV_123456_02.pdf` (etc) only if your mover also preserves their own `_NNN` (see note below)

---

## Important note about the attachments (`X_02.pdf`, `X_03.pdf`, ‚Ä¶)

You said **all these are renamed based on the XML**.

There are two valid strategies:

### Strategy A (most common)

* XML final name ends with `_01`
* Each attachment keeps its *own* trailing sequence (`_02`, `_03`, ‚Ä¶) and only changes the base

So:

* `X_02.pdf` ‚Üí `NEWBASE_02.pdf`
* `X_03.pdf` ‚Üí `NEWBASE_03.pdf`

This requires the mover to:

* derive `NEWBASE` from `invoiceFileName` **without extension and without `_01`**
* then append each attachment‚Äôs original suffix

If your mover instead renames every attachment to match the XML exactly, you‚Äôll overwrite.

### Strategy B (simpler but lossy)

* rename all attachments to the XML base exactly (bad if multiple PDFs)

Given your earlier summary and multi-attachment examples, you likely want **Strategy A**.

If you paste `SplitAttachmentMover.moveAttachments(...)`, I‚Äôll tell you which strategy it‚Äôs implementing and adjust it to preserve per-attachment suffixes safely.

---

## JUnit tests to lock this in

### Unit test for suffix extraction

```java
@Test
void extractTrailingSequenceSuffix_shouldReturnUnderscoreDigits_whenPresentAtEnd() {
    assertThat(extractTrailingSequenceSuffix("X_01")).isEqualTo("_01");
    assertThat(extractTrailingSequenceSuffix("A1_B123_multiplethings_999")).isEqualTo("_999");
    assertThat(extractTrailingSequenceSuffix("X_2")).isEqualTo("_2");
}

@Test
void extractTrailingSequenceSuffix_shouldReturnEmpty_whenMissingOrInvalid() {
    assertThat(extractTrailingSequenceSuffix("X")).isEmpty();
    assertThat(extractTrailingSequenceSuffix("X_")).isEmpty();
    assertThat(extractTrailingSequenceSuffix("X_0000")).isEmpty();
    assertThat(extractTrailingSequenceSuffix("X_0A")).isEmpty();
}
```

### Writer-level test idea (minimal)

Mock/stub `registry.lookup(invoice)` to return `"X_01"` and assert the generated output xml filename contains `"_01.xml"`.

(If you show your existing writer tests setup, I‚Äôll give you the exact compile-ready test.)

---

## Bottom line

To keep `_01`:

‚úÖ **Extract trailing `_NNN` from the source XML base** (`registry.lookup(invoice)`)
‚úÖ **Append it to the newly generated XML filename before `.xml`**
‚úÖ Then the mover will automatically rename everything based on the corrected XML name

If you share `SplitAttachmentMover.moveAttachments(...)` (even a screenshot), I‚Äôll also ensure your PDFs keep `_02/_03` instead of being forced to `_01`.







---------------------------

Below is **drop-in JUnit 5 coverage** for the code in your screenshot:

* `toCreditNoteTypeGroup(...)` branch behavior:

  * when `AllowanceChargeCbcChargeIndicator` is **false** ‚Üí creates **CreditNoteLine**
  * when **true** ‚Üí **skips** line and calls `createAllowanceCharge(...)`
* `createAllowanceCharge(...)` behavior:

  * sets `LegalMonetaryTotal.AllowanceTotalAmount` only when `LegalMonetaryTotalCbcAllowanceAmount` is present
  * always appends `toAllowanceChargeList(row)` results into `creditNoteType.getAllowanceCharge()`

I‚Äôve written these in the same style as your existing `CsvInvoiceMapperTest` (no Mockito, no `eq()`, uses your generated `CsvInvoiceMapperImpl`).

---

## ‚úÖ Add these tests to `CsvInvoiceMapperTest`

```java
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class CsvInvoiceMapperTest {

    private final CsvInvoiceMapper mapper = new CsvInvoiceMapperImpl();

    @Test
    void toCreditNoteTypeGroup_whenIndicatorFalse_addsCreditLine_andDoesNotAddAllowanceCharge() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-1", new ArrayList<>());
        CsvInvoiceDto line = new CsvInvoiceDto();
        line.setInvoiceLineCbcId("1");
        line.setAllowanceChargeCbcChargeIndicator("false");
        line.setInvoiceLineCbcLineExtensionAmount("10.00");
        line.setInvoiceLineCbcVATPercentage("21");

        group.getRows().add(line);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        assertThat(credit.getCreditNoteLine()).hasSize(1);
        assertThat(credit.getAllowanceCharge()).isEmpty();
    }

    @Test
    void toCreditNoteTypeGroup_whenIndicatorTrue_skipsCreditLine_andCreatesAllowanceCharge_andSetsAllowanceTotal() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-2", new ArrayList<>());

        CsvInvoiceDto allowanceRow = new CsvInvoiceDto();
        allowanceRow.setInvoiceLineCbcId("1");
        allowanceRow.setAllowanceChargeCbcChargeIndicator("true");

        // triggers allowancetotalamount set
        allowanceRow.setLegalMonetaryTotalCbcAllowanceAmount("15.00");

        // triggers charge build in toAllowanceChargeList(row)
        allowanceRow.setAllowanceChargeCbcAmount("15.00");
        allowanceRow.setBaseAmountCbcCurrencyId("EUR");
        allowanceRow.setAllowanceChargeCbcChargeReason("Discount");

        group.getRows().add(allowanceRow);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        // because indicator true => else branch => no credit line created
        assertThat(credit.getCreditNoteLine()).isEmpty();

        // allowance total set
        assertThat(credit.getLegalMonetaryTotal()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getCurrencyID()).isEqualTo("EUR");
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getValue())
                .isEqualByComparingTo(new BigDecimal("15.00"));

        // allowanceCharge list populated from toAllowanceChargeList(row)
        assertThat(credit.getAllowanceCharge()).hasSize(1);
    }

    @Test
    void toCreditNoteTypeGroup_whenIndicatorTrue_andAllowanceAmountMissing_doesNotSetAllowanceTotal_butStillAddsAllowanceCharge() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-3", new ArrayList<>());

        CsvInvoiceDto allowanceRow = new CsvInvoiceDto();
        allowanceRow.setInvoiceLineCbcId("1");
        allowanceRow.setAllowanceChargeCbcChargeIndicator("true");

        // allowance total is NOT set when this is empty/null
        allowanceRow.setLegalMonetaryTotalCbcAllowanceAmount(null);

        // but charge list is still added
        allowanceRow.setAllowanceChargeCbcAmount("10.00");
        allowanceRow.setBaseAmountCbcCurrencyId("EUR");

        group.getRows().add(allowanceRow);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        assertThat(credit.getCreditNoteLine()).isEmpty();

        // allowance total should remain unset
        assertThat(credit.getLegalMonetaryTotal()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount()).isNull();

        // but allowance charge should still be present
        assertThat(credit.getAllowanceCharge()).hasSize(1);
    }

    @Test
    void toCreditNoteTypeGroup_mixedRows_createsCreditLinesForNonAllowanceRows_andAllowanceChargeForAllowanceRow() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-4", new ArrayList<>());

        CsvInvoiceDto normal1 = new CsvInvoiceDto();
        normal1.setInvoiceLineCbcId("1");
        normal1.setAllowanceChargeCbcChargeIndicator("false");
        normal1.setInvoiceLineCbcLineExtensionAmount("100.00");
        normal1.setInvoiceLineCbcVATPercentage("21");

        CsvInvoiceDto allowance = new CsvInvoiceDto();
        allowance.setInvoiceLineCbcId("2");
        allowance.setAllowanceChargeCbcChargeIndicator("true");
        allowance.setLegalMonetaryTotalCbcAllowanceAmount("5.00");
        allowance.setAllowanceChargeCbcAmount("5.00");
        allowance.setBaseAmountCbcCurrencyId("EUR");

        CsvInvoiceDto normal2 = new CsvInvoiceDto();
        normal2.setInvoiceLineCbcId("3");
        normal2.setAllowanceChargeCbcChargeIndicator("false");
        normal2.setInvoiceLineCbcLineExtensionAmount("50.00");
        normal2.setInvoiceLineCbcVATPercentage("0");

        group.getRows().addAll(List.of(normal1, allowance, normal2));

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        // only the two non-allowance rows become credit lines
        assertThat(credit.getCreditNoteLine()).hasSize(2);

        // allowance row becomes allowance charge
        assertThat(credit.getAllowanceCharge()).hasSize(1);

        // allowance total set from allowance row
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getValue())
                .isEqualByComparingTo("5.00");

        // tax totals computed once at end
        assertThat(credit.getTaxTotal()).isNotEmpty();
    }
}
```

---

## Notes (why these tests match your implementation)

* Your code uses:

  ```java
  boolean allowanceChargeIndicator =
      Boolean.parseBoolean(row.getAllowanceChargeCbcChargeIndicator());
  if (!allowanceChargeIndicator) { add line } else { createAllowanceCharge(...) }
  ```

  So `"true"` ‚Üí allowance branch, `"false"` ‚Üí line branch.

* `createAllowanceCharge` sets `AllowanceTotalAmount` only if the string is non-empty, and always:

  ```java
  allowanceCharge.addAll(toAllowanceChargeList(row));
  ```

These tests assert exactly those behaviors.

---

If you paste the **exact package name** and confirm whether your group constructor is `new CsvInvoiceGroup("id", new ArrayList<>())` (as shown in your earlier tests), I can tailor the imports/types so it compiles 100% without any tweaking.




------------


Yep ‚Äî your current `SplitAttachmentMover` is **very close**, but one detail in the rename logic is what breaks the ‚Äúkeep number on XML but not duplicate it on attachments‚Äù requirement.

### ‚úÖ What you want

Given:

```
A_01.xml   (output XML)
A_02.pdf
A_03.pdf
A_04.jpg
A_05.csv
```

When copying attachments for `A_01.xml`, the copied files should remain:

```
A_02.pdf, A_03.pdf, A_04.jpg, A_05.csv
```

**Not**:

```
A_01_02.pdf, A_01_03.pdf, ...
```

---

## Why it happens in your current code

In `moveAttachments()` you compute:

* `normalizedBase = normalizeAttachmentBase(xmlBaseName)`  ‚úÖ (becomes `"a"`)
* `targetBase = stripExtension(outputXmlFileName)` ‚úÖ (becomes `"A_01"`)

Then in `copySingleAttachment()` you do:

```java
String suffix = fileName.substring(baseLen);   // "_02.pdf"
Path dest = targetDir.resolve(targetBase + suffix); // "A_01" + "_02.pdf"
```

So it becomes: **`A_01_02.pdf`** ‚ùå

---

# ‚úÖ Minimal change you need

### 1) Compute a *targetPrefixWithoutSeq* (e.g. `"A"`) once in `moveAttachments()`

Add this next to `targetBase`:

```java
String targetFileName = Paths.get(outputXmlFileName).getFileName().toString();
String targetNoExt = stripExtension(targetFileName).trim();
String targetPrefix = stripTrailingSeqRaw(targetNoExt);   // "A" from "A_01"
```

Where `stripTrailingSeqRaw()` removes the last `_<digits>` **without lowercasing**:

```java
private static String stripTrailingSeqRaw(String s) {
    if (s == null) {
        return null;
    }
    int us = s.lastIndexOf('_');
    if (us < 0 || us == s.length() - 1) {
        return s;
    }
    int i = us + 1;
    while (i < s.length() && Character.isDigit(s.charAt(i))) {
        i++;
    }
    if (i == us + 1) {
        return s; // no digits after underscore
    }
    if (i != s.length()) {
        return s; // digits not at end -> don't strip
    }
    return s.substring(0, us);
}
```

### 2) Pass `targetPrefix` into `copyMatchingAttachments(...)`

Change signature:

```java
private List<Path> copyMatchingAttachments(
        Path sourceDir,
        Path targetDir,
        String normalizedBase,
        String targetBase,
        String targetPrefix) throws IOException
```

And call it like:

```java
List<Path> moved = copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase, targetPrefix);
```

### 3) In `copySingleAttachment()`, use `targetPrefix` (not `targetBase`) when building dest

Change method signature too:

```java
private Path copySingleAttachment(
        Path source,
        String fileName,
        String normalizedBase,
        Path targetDir,
        String targetBase,
        String targetPrefix) throws IOException
```

Then change this line:

```java
Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
```

to:

```java
Path dest = uniqueIfExists(targetDir.resolve(targetPrefix + suffix));
```

‚úÖ Now the output will be:

* XML stays: `A_01.xml`
* Attachments stay: `A_02.pdf`, `A_03.pdf`, ‚Ä¶

---

## Important: you do NOT need to change `normalizeAttachmentBase()`

Even though it strips `_01`, that is still correct because:

* it‚Äôs used only for **matching**
* you **don‚Äôt want** attachments to be tied to `_01`, you want them tied to the prefix (`A`)

So:

* keep stripping sequence for matching ‚úÖ
* stop using target XML seq in attachment rename ‚úÖ

---

## Quick sanity example after change

* `outputXmlFileName = A_01.xml` ‚Üí `targetPrefix = A`
* fileName = `A_02.pdf` ‚Üí suffix `_02.pdf`
* dest = `A + _02.pdf` ‚Üí `A_02.pdf` ‚úÖ

---

If you want, I can also give you a small **JUnit @TempDir test** for `SplitAttachmentMover` that creates a fake unzipped folder and verifies the copied filenames exactly match `A_02.pdf`, `A_03.pdf`, etc.



----------
Great catch ‚Äî this is exactly the right question to ask üëç
Nothing is ‚Äúmissing‚Äù at runtime, it‚Äôs just a **method you still need to define**.

Let me walk you through it cleanly and show **where it lives, why it exists, and the exact code**.

---

## What you asked about

You saw this line:

```java
return buildTaxSubtotalForVat(group, new BigDecimal("21"));
```

and asked:

> where is this method?

### ‚úÖ Answer

`buildTaxSubtotalForVat(...)` is a **new default helper method** that you must add **yourself** inside **`CsvInvoiceMapper`**.
It is **not generated by MapStruct** and it does **not already exist** unless you created it earlier.

It sits **next to** your other default methods like `toInvoiceTypeGroup(...)`.

---

## Why you need this method

You now have **two responsibilities**:

| VAT case   | How it‚Äôs calculated                                       |
| ---------- | --------------------------------------------------------- |
| VAT **0**  | Special logic ‚Üí sum `InvoiceLine_cbc_LineExtensionAmount` |
| VAT **21** | Generic logic ‚Üí sum taxable + tax amounts                 |

So you split the logic:

* `buildVatZeroSubtotal(...)` ‚Üí VAT 0 only
* `buildTaxSubtotalForVat(...)` ‚Üí generic VAT (21, maybe others later)

This keeps:

* logic **clear**
* subtotals printed **once**
* code **Sonar-friendly**

---

## Where it lives (important)

**Location:**

```java
@Mapper(componentModel = "spring")
public interface CsvInvoiceMapper {
    // ‚¨áÔ∏è HERE
}
```

It must be a **`default` method** so MapStruct does **not** try to generate it.

---

## Exact method you should add (VAT 21)

Here is the **complete, production-safe implementation**:

```java
default TaxSubtotalType buildTaxSubtotalForVat(
        CsvInvoiceGroup group,
        BigDecimal vatPercentage
) {
    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxSum = BigDecimal.ZERO;
    boolean found = false;

    for (CsvInvoiceDto row : group.getRows –∏–∑–≤–µ—Å—Ç–Ω–æ) {
        BigDecimal rowVat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (rowVat != null && rowVat.compareTo(vatPercentage) == 0) {
            found = true;

            taxableSum = taxableSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalExclVatValue())
            );

            taxSum = taxSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalVatAmountValue())
            );
        }
    }

    if (!found) {
        return null; // no VAT 21 lines ‚Üí no subtotal
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType category = getTaxCategory(
        vatPercentage,
        false,
        group.getRows().get(0).getItemCbcName()
    );
    taxSubtotal.setTaxCategory(category);

    return taxSubtotal;
}
```

---

## How it‚Äôs used (now it makes sense)

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {
    TaxTotalType taxTotal = new TaxTotalType();

    // VAT 21 (generic)
    TaxSubtotalType vat21 = buildTaxSubtotalForVat(group, new BigDecimal("21"));
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    // VAT 0 (special)
    TaxSubtotalType vat0 = buildVatZeroSubtotal(group);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

---

## Helper you also need (already referenced)

```java
default BigDecimal safeAmount(String value) {
    if (value == null || value.isBlank()) {
        return BigDecimal.ZERO;
    }
    return toAmount(value);
}
```

---

## Final mental model (so it sticks)

* **MapStruct mappings** ‚Üí structure only
* **Default methods** ‚Üí business aggregation logic
* **`buildTaxSubtotalForVat`** ‚Üí generic VAT logic (21)
* **`buildVatZeroSubtotal`** ‚Üí special VAT 0 logic
* **`toTaxTotal(group)`** ‚Üí orchestrates both, once per invoice

Nothing is duplicated, nothing runs per line accidentally.

---

If you want, next I can:

* üîç Add **debug logs** that prove this runs once per invoice
* üß™ Write **JUnit tests** for VAT 21 + VAT 0 together
* ‚ôªÔ∏è Mirror the same logic for **CreditNote mapper**

Just tell me where you want to go next.
