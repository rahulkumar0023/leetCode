Perfect üëè ‚Äî this is a classic Mockito issue, not your logic.
That exception:

```
org.mockito.exceptions.misusing.MissingMethodInvocationException:
when() requires an argument which has to be 'a method call on a mock'
```

means **Mockito couldn‚Äôt mock or intercept the static method calls** because the classes (like `PGPEncryptBuilder` or `PGPDecryptBuilder`) are either:

1. **final classes** (or their methods are final), or
2. They are **non-public / package-private**, or
3. The static mocking wasn‚Äôt opened on the correct class reference.

---

Let‚Äôs fix it safely and make your tests run correctly.

---

## ‚úÖ Fix 1 ‚Äî Verify static mocks are on the correct class

In your test you have:

```java
try (MockedStatic<PGPEncryptBuilder> builderMock = mockStatic(PGPEncryptBuilder.class)) {
    builderMock.when(() -> new PGPEncryptBuilder(mockPublicKey)).thenReturn(builder);
}
```

üëâ That syntax only works if the `PGPEncryptBuilder` class is **public and not final**.
If it‚Äôs `final` or package-private, Mockito cannot stub `new PGPEncryptBuilder(...)`.

So, instead of mocking the constructor directly (which fails for final classes), we mock **the `build()` method** on a pre-instantiated builder.

---

## ‚úÖ Fixed version for `pgpEncrypt` test

```java
@Test
void shouldLoadPublicKeyAndBuildEncryptBean() throws Exception {
    File mockFile = new File("public.asc");
    when(resourceLoader.getResource("classpath:keys/public.asc")).thenReturn(mockResource);
    when(mockResource.getFile()).thenReturn(mockFile);

    PfPGPPublicKey mockPublicKey = mock(PfPGPPublicKey.class);
    PGPEncryptBuilder builder = mock(PGPEncryptBuilder.class);
    PGPEncrypt mockEncrypt = mock(PGPEncrypt.class);

    when(builder.build()).thenReturn(mockEncrypt);

    try (MockedStatic<KeysManagerUtils> keysManagerMock = mockStatic(KeysManagerUtils.class)) {
        // Mock static utility only
        keysManagerMock.when(() -> KeysManagerUtils.loadPublicKeyFromAsc(mockFile))
                .thenReturn(mockPublicKey);

        // Spy or manually construct your builder
        ReflectionTestUtils.setField(pgpConfig, "pgpPublicKeyPath", "classpath:keys/public.asc");

        // If your builder has a static factory (like PGPEncryptBuilder.of()), mock that
        // Otherwise, manually create and inject your builder
        // Skipping constructor mocking avoids final class issues

        PGPEncrypt result = pgpConfig.pgpEncrypt(resourceLoader);

        assertThat(result).isNotNull();
        keysManagerMock.verify(() -> KeysManagerUtils.loadPublicKeyFromAsc(mockFile));
    }
}
```

‚úÖ This version doesn‚Äôt stub the constructor ‚Äî it only mocks static methods and verifies behavior.

---

## ‚úÖ Fix 2 ‚Äî For `pgpDecrypt` test

Same pattern applies ‚Äî mock only the static `KeysManagerUtils.loadPrivateKeysFromAsc(...)` method, not the `new PGPDecryptBuilder(...)` constructor:

```java
@Test
void shouldLoadPrivateKeyAndBuildDecryptBean() throws Exception {
    File mockFile = new File("private.asc");
    when(resourceLoader.getResource("classpath:keys/private.asc")).thenReturn(mockResource);
    when(mockResource.getFile()).thenReturn(mockFile);

    PfPGPPrivateKeys mockPrivateKeys = mock(PfPGPPrivateKeys.class);
    PGPDecrypt mockDecrypt = mock(PGPDecrypt.class);

    char[] creds = (char[]) ReflectionTestUtils.getField(pgpConfig, "privateKeyCred");

    try (MockedStatic<KeysManagerUtils> keysManagerMock = mockStatic(KeysManagerUtils.class)) {
        keysManagerMock.when(() ->
                KeysManagerUtils.loadPrivateKeysFromAsc(mockFile, creds))
                .thenReturn(mockPrivateKeys);

        PGPDecrypt result = pgpConfig.pgpDecrypt(resourceLoader);

        assertThat(result).isNotNull();
        keysManagerMock.verify(() ->
                KeysManagerUtils.loadPrivateKeysFromAsc(mockFile, creds));
    }
}
```

---

## ‚úÖ Fix 3 ‚Äî If static mocking is not supported in your Mockito version

If you‚Äôre using **Mockito < 3.4.0**, you must add:

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-inline</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
</dependency>
```

This enables mocking of static and final classes.

---

## ‚úÖ Summary

| Problem                                         | Fix                                                    |
| ----------------------------------------------- | ------------------------------------------------------ |
| `MissingMethodInvocationException`              | Avoid mocking `new` constructor calls on final classes |
| Mockito can‚Äôt stub `new PGPEncryptBuilder(...)` | Only mock static utility methods (`KeysManagerUtils`)  |
| Need static mocking                             | Add `mockito-inline` dependency                        |
| Want to control field values                    | Continue using `ReflectionTestUtils`                   |

---

Would you like me to refactor both test methods into a single **fully working JUnit class** (no constructor mocks, no MissingMethodInvocationException)? I can post the clean version you can copy-paste directly.
