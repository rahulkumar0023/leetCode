You’re right—let’s remove the duplication. Both `InvoiceType` and `CreditNoteType` expose **the same UBL types** for what we need: `List<DocumentReferenceType>` (contracts) and `AccountingSupplierPartyType → PartyType` (supplier). So make one core resolver that works off those shared types, and keep only two tiny entry points.

```java
@Service
@RequiredArgsConstructor
public class BucketResolver {

  private final SupplierRepository repository;
  private static final Set<String> PREFIXES = Set.of("12","13","14","15","19");

  // ---- Tiny type-specific entry points ----
  public String resolveBucket(InvoiceType inv) {
    return resolve(inv.getContractDocumentReference(),
                   partyOf(inv.getAccountingSupplierParty()));
  }

  public String resolveBucket(CreditNoteType cn) {
    return resolve(cn.getContractDocumentReference(),
                   partyOf(cn.getAccountingSupplierParty()));
  }

  // ---- Single core resolver on shared UBL types ----
  private String resolve(List<DocumentReferenceType> contracts, PartyType party) {
    String contractId = firstId(contracts);
    String supplierCompanyId = firstCompanyId(party);
    boolean prefixMatch = contractId != null && PREFIXES.stream().anyMatch(contractId::startsWith);
    boolean supplierMatch = supplierCompanyId != null && repository.existsByEnterpriseNumber(supplierCompanyId);
    return (prefixMatch || supplierMatch) ? "M" : "F";
  }

  // ---- Small helpers (shared) ----
  private PartyType partyOf(AccountingSupplierPartyType asp) {
    return asp != null ? asp.getParty() : null;
  }

  private String firstId(List<DocumentReferenceType> refs) {
    return (refs != null && !refs.isEmpty() && refs.get(0).getID() != null)
        ? refs.get(0).getID().getValue() : null;
  }

  private String firstCompanyId(PartyType party) {
    if (party == null || party.getPartyTaxScheme() == null || party.getPartyTaxScheme().isEmpty()) return null;
    var pts = party.getPartyTaxScheme().get(0);
    return pts.getCompanyID() != null ? pts.getCompanyID().getValue() : null;
  }
}
```

### Why this is cleaner

* Only **two** tiny public methods; all logic lives in one place.
* Uses UBL’s shared types, so no duplication of extraction code.
* Easy to extend (e.g., add `DebitNoteType` with one-liner entry point).




Here’s a compact JUnit 5 test for the deduplicated `BucketResolver` (using Mockito). Tweak the import package for your generated UBL classes.

```java
// Adjust these imports to your generated UBL package names:
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;

import com.alphacredit.batch.service.BucketResolver;
import com.alphacredit.batch.domain.supplier.SupplierRepository;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentMatchers;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class BucketResolverTest {

    @Mock SupplierRepository repo;
    BucketResolver resolver;

    @BeforeEach
    void setUp() {
        resolver = new BucketResolver(repo);
    }

    // --- InvoiceType tests ---

    @Test
    void invoice_prefixMatch_goesToM() {
        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("12-ABC")); // prefix 12
        inv.setAccountingSupplierParty(asp(null));                 // no supplier match

        String bucket = resolver.resolveBucket(inv);

        assertThat(bucket).isEqualTo("M");
        verify(repo, never()).existsByEnterpriseNumber(anyString());
    }

    @Test
    void invoice_supplierMatch_goesToM() {
        when(repo.existsByEnterpriseNumber("BE0123")).thenReturn(true);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("99-XYZ")); // no prefix match
        inv.setAccountingSupplierParty(asp("BE0123"));            // supplier match

        String bucket = resolver.resolveBucket(inv);

        assertThat(bucket).isEqualTo("M");
        verify(repo).existsByEnterpriseNumber("BE0123");
    }

    @Test
    void invoice_noMatch_goesToF() {
        when(repo.existsByEnterpriseNumber("BE999")).thenReturn(false);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("77-XYZ")); // no prefix
        inv.setAccountingSupplierParty(asp("BE999"));             // repo says false

        String bucket = resolver.resolveBucket(inv);

        assertThat(bucket).isEqualTo("F");
        verify(repo).existsByEnterpriseNumber("BE999");
    }

    @Test
    void invoice_nullSafe_emptyLists_goesToF() {
        InvoiceType inv = new InvoiceType();
        // no contract refs, no supplier party

        String bucket = resolver.resolveBucket(inv);

        assertThat(bucket).isEqualTo("F");
        verify(repo, never()).existsByEnterpriseNumber(anyString());
    }

    // --- CreditNoteType tests ---

    @Test
    void creditNote_prefixMatch_goesToM() {
        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("15-HELLO"));
        cn.setAccountingSupplierParty(asp(null));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("M");
        verify(repo, never()).existsByEnterpriseNumber(anyString());
    }

    @Test
    void creditNote_supplierMatch_goesToM() {
        when(repo.existsByEnterpriseNumber("BE777")).thenReturn(true);

        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("88-NOPE"));
        cn.setAccountingSupplierParty(asp("BE777"));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("M");
        verify(repo).existsByEnterpriseNumber("BE777");
    }

    // --- Helpers ---

    private static DocumentReferenceType docRef(String idValue) {
        DocumentReferenceType dr = new DocumentReferenceType();
        IDType id = new IDType();
        id.setValue(idValue);
        dr.setID(id);
        return dr;
    }

    private static AccountingSupplierPartyType asp(String companyId) {
        AccountingSupplierPartyType asp = new AccountingSupplierPartyType();
        PartyType party = new PartyType();

        if (companyId != null) {
            PartyTaxSchemeType tax = new PartyTaxSchemeType();
            CompanyIDType cid = new CompanyIDType();
            cid.setValue(companyId);
            tax.setCompanyID(cid);
            party.getPartyTaxScheme().add(tax);
        }
        asp.setParty(party);
        return asp;
    }
}
```

**Notes**

* Uses AssertJ for crisp assertions; switch to `org.junit.jupiter.api.Assertions` if you prefer.
* If your generated classes live under different packages (e.g., `eu.peppol.ubl...`), update the import lines accordingly.
* This covers: prefix rule, supplier DB match, no-match fallback, null-safety, and both `InvoiceType` & `CreditNoteType`.
