@ExtendWith(MockitoExtension.class)
class InvoiceJobSchedulerTest {

    @Mock private JobLauncher jobLauncher;
    @Mock private Job xmlInvoiceJob;
    @Mock private Job csvInvoiceJob;
    @Mock private SchedulerConfig schedulerConfig;

    @InjectMocks private InvoiceJobScheduler scheduler;

    @Test
    void shouldRunXmlInvoiceJob() throws Exception {
        when(jobLauncher.run(any(Job.class), any(JobParameters.class)))
            .thenReturn(mock(JobExecution.class));

        scheduler.xmlInvoiceJobScheduler();

        verify(jobLauncher, times(1))
            .run(eq(xmlInvoiceJob), argThat(p -> "xml".equals(p.getString("jobType"))));
    }

    @Test
    void shouldRunCsvInvoiceJob() throws Exception {
        when(jobLauncher.run(any(Job.class), any(JobParameters.class)))
            .thenReturn(mock(JobExecution.class));

        scheduler.csvInvoiceJobScheduler();

        verify(jobLauncher, times(1))
            .run(eq(csvInvoiceJob), argThat(p -> "csv".equals(p.getString("jobType"))));
    }

    @Test
    void shouldThrowInvoiceProcessingExceptionWhenRunFails() throws Exception {
        when(jobLauncher.run(any(Job.class), any(JobParameters.class)))
            .thenThrow(new JobExecutionAlreadyRunningException("Already running"));

        assertThatThrownBy(() -> scheduler.runJob(xmlInvoiceJob, "xmlInvoiceJob"))
            .isInstanceOf(InvoiceProcessingException.class)
            .hasMessageContaining("Failed to launch invoiceJob");

        verify(jobLauncher).run(any(Job.class), any(JobParameters.class));
    }
}
