Great â€” a `Tasklet` is the perfect fit when you want to perform **imperative, single-purpose logic**, like fetching, decrypting, and unzipping files in sequence. Here's how you can structure it:

---

## âœ… Plan

Create a `DecryptAndUnzipTasklet` that:

1. Calls `cosService.fetchEncryptedFiles()` â†’ returns `List<File>`
2. Decrypts each `.zip.pgp` file â†’ returns decrypted `.zip` files
3. Unzips each `.zip` file into `/tmp/unzipped/` or another working directory

---

## âœ… 1. `CosStorageService.java` (simplified)

```java
@Component
public class CosStorageService {

    public List<File> fetchEncryptedFiles() {
        // Simulate fetching encrypted files from COS to /tmp
        return List.of(new File("/tmp/invoice-batch-1.zip.pgp"));
    }
}
```

---

## âœ… 2. `DecryptAndUnzipTasklet.java`

```java
@Component
public class DecryptAndUnzipTasklet implements Tasklet {

    private final CosStorageService cosService;

    public DecryptAndUnzipTasklet(CosStorageService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        List<File> encryptedFiles = cosService.fetchEncryptedFiles();
        for (File encrypted : encryptedFiles) {
            File decryptedZip = decryptFile(encrypted);
            unzipFile(decryptedZip, Paths.get("/tmp/unzipped"));
        }
        return RepeatStatus.FINISHED;
    }

    private File decryptFile(File encryptedFile) throws IOException {
        // Simulated decryption: just rename file (in real life, use BouncyCastle, etc.)
        File decrypted = new File(encryptedFile.getAbsolutePath().replace(".pgp", ""));
        Files.copy(encryptedFile.toPath(), decrypted.toPath(), StandardCopyOption.REPLACE_EXISTING);
        System.out.println("Decrypted: " + decrypted.getName());
        return decrypted;
    }

    private void unzipFile(File zipFile, Path targetDir) throws IOException {
        targetDir.toFile().mkdirs();
        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                File outFile = targetDir.resolve(entry.getName()).toFile();
                try (FileOutputStream fos = new FileOutputStream(outFile)) {
                    zis.transferTo(fos);
                }
                System.out.println("Extracted: " + outFile.getName());
            }
        }
    }
}
```

---

## âœ… 3. Add to Your Batch Config

```java
@Bean
public Step decryptUnzipStep(JobRepository repo, PlatformTransactionManager tx,
                              DecryptAndUnzipTasklet tasklet) {
    return new StepBuilder("decryptUnzipStep", repo)
            .tasklet(tasklet, tx)
            .build();
}
```

Then chain it before your invoice step in the job:

```java
@Bean
public Job invoiceJob(JobRepository repo, Step decryptUnzipStep, Step invoiceStep) {
    return new JobBuilder("invoiceJob", repo)
            .start(decryptUnzipStep)
            .next(invoiceStep)
            .build();
}
```

---

## âœ… Result

Your batch job now:

1. **Fetches** `.zip.pgp` files from COS
2. **Decrypts** them to `.zip`
3. **Unzips** them into `/tmp/unzipped`
4. **Then Step 2** reads & processes each XML invoice

---

Would you like a test tasklet runner or unit tests for this setup?




Yes â€” splitting into **three dedicated steps** is an excellent design. It provides:

* âœ… Clear separation of concerns
* âœ… Easier debugging
* âœ… Independent retries
* âœ… Cleaner logging and exception handling

---

## âœ… Recommended 3-Step Spring Batch Job

### ðŸ”¹ **Step 1: `fetchEncryptedStep`**

* Fetch `.zip.pgp` files from COS (download to `/tmp/encrypted`)
* Store downloaded `File` paths in `ExecutionContext` or local directory

### ðŸ”¹ **Step 2: `decryptAndUnzipStep`**

* Read the encrypted files from `/tmp/encrypted`
* Decrypt `.pgp` â†’ `.zip`
* Unzip `.zip` â†’ `.xml` into `/tmp/unzipped`

### ðŸ”¹ **Step 3: `invoiceStep`**

* Multi-resource XML reader reads from `/tmp/unzipped`
* Your existing processor & writer
* Upload processed files back to COS or move to archive

---

## âœ… Technical Breakdown

### 1. `fetchEncryptedTasklet`

```java
@Component
public class FetchEncryptedTasklet implements Tasklet {

    private final CosStorageService cosService;

    public FetchEncryptedTasklet(CosStorageService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext context) throws Exception {
        List<String> cosKeys = List.of("invoices-batch1.zip.pgp", "invoices-batch2.zip.pgp");

        for (String key : cosKeys) {
            File localFile = cosService.downloadToLocal(key); // saves to /tmp/encrypted
            System.out.println("Fetched: " + localFile.getAbsolutePath());
        }

        return RepeatStatus.FINISHED;
    }
}
```

---

### 2. `decryptAndUnzipTasklet`

```java
@Component
public class DecryptAndUnzipTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext context) throws Exception {
        File[] encryptedFiles = new File("/tmp/encrypted").listFiles((dir, name) -> name.endsWith(".pgp"));
        if (encryptedFiles == null) return RepeatStatus.FINISHED;

        for (File pgpFile : encryptedFiles) {
            File zipFile = decrypt(pgpFile); // simulate decryption
            unzip(zipFile, new File("/tmp/unzipped"));
        }

        return RepeatStatus.FINISHED;
    }

    private File decrypt(File pgp) throws IOException {
        File zip = new File(pgp.getAbsolutePath().replace(".pgp", ""));
        Files.copy(pgp.toPath(), zip.toPath(), StandardCopyOption.REPLACE_EXISTING);
        return zip;
    }

    private void unzip(File zipFile, File destDir) throws IOException {
        destDir.mkdirs();
        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                File newFile = new File(destDir, entry.getName());
                try (FileOutputStream fos = new FileOutputStream(newFile)) {
                    zis.transferTo(fos);
                }
            }
        }
    }
}
```

---

### 3. `invoiceStep` (already implemented)

```java
@Bean
public Step invoiceStep(JobRepository repo, PlatformTransactionManager tx,
                        InvoiceProcessor proc, InvoiceWriter writer) throws IOException {
    MultiResourceItemReader<InvoiceType> reader = new MultiResourceItemReader<>();
    reader.setResources(new PathMatchingResourcePatternResolver()
        .getResources("file:/tmp/unzipped/*.xml"));
    reader.setDelegate(new SingleInvoiceReader());

    return new StepBuilder("invoiceStep", repo)
            .<InvoiceType, InvoiceType>chunk(1, tx)
            .reader(reader)
            .processor(proc)
            .writer(writer)
            .build();
}
```

---

## âœ… Final Job Configuration

```java
@Bean
public Job invoiceJob(JobRepository repo,
                      Step fetchEncryptedStep,
                      Step decryptAndUnzipStep,
                      Step invoiceStep) {

    return new JobBuilder("invoiceJob", repo)
            .start(fetchEncryptedStep)
            .next(decryptAndUnzipStep)
            .next(invoiceStep)
            .build();
}
```

---

Would you like me to generate all the actual Spring bean definitions for these three steps now?

