Perfect. Let me now give you the **complete working code** for:

‚úÖ `InvoiceBucketResolver` (as a real Spring component)
‚úÖ Unit tests for both conditions (`prefix match` and `supplier match`)
‚úÖ How to use it in your `XmlInvoiceWriter` or any batch component

---

## üì¶ 1. `InvoiceBucketResolver.java`

```java
package com.yourcompany.yourapp.util;

import com.yourcompany.yourapp.service.SupplierService;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@Component
@RequiredArgsConstructor
public class InvoiceBucketResolver {

    private static final List<String> PREFIXES = List.of("12", "13", "14", "15", "19");

    private final SupplierService supplierService;

    /**
     * Main logic to determine if the invoice belongs in bucket "M" or "F"
     */
    public String resolveBucket(InvoiceType invoice) {
        String contractId = getContractId(invoice);
        String supplierCompanyId = getSupplierCompanyId(invoice);

        boolean prefixMatch = PREFIXES.stream().anyMatch(contractId::startsWith);
        boolean knownSupplier = supplierService.isKnownSupplier(supplierCompanyId);

        return (prefixMatch || knownSupplier) ? "M" : "F";
    }

    private String getContractId(InvoiceType invoice) {
        return Optional.ofNullable(invoice.getContractDocumentReference())
                .filter(list -> !list.isEmpty())
                .map(list -> list.get(0).getID())
                .map(IDType::getValue)
                .orElse("");
    }

    private String getSupplierCompanyId(InvoiceType invoice) {
        return Optional.ofNullable(invoice.getAccountingSupplierParty())
                .map(AccountingSupplierPartyType::getParty)
                .map(PartyType::getPartyTaxScheme)
                .filter(list -> !list.isEmpty())
                .map(list -> list.get(0).getCompanyID())
                .map(IDType::getValue)
                .orElse("");
    }
}
```

---

## üß™ 2. `InvoiceBucketResolverTest.java`

```java
package com.yourcompany.yourapp.util;

import com.yourcompany.yourapp.service.SupplierService;
import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class InvoiceBucketResolverTest {

    private SupplierService supplierService;
    private InvoiceBucketResolver resolver;

    @BeforeEach
    void setup() {
        supplierService = mock(SupplierService.class);
        resolver = new InvoiceBucketResolver(supplierService);
    }

    @Test
    void testBucketM_whenContractIdStartsWithPrefix() {
        InvoiceType invoice = new InvoiceType();

        ContractDocumentReferenceType contract = new ContractDocumentReferenceType();
        IDType contractId = new IDType();
        contractId.setValue("14-XYZ");
        contract.setID(contractId);
        invoice.getContractDocumentReference().add(contract);

        when(supplierService.isKnownSupplier(any())).thenReturn(false);

        assertEquals("M", resolver.resolveBucket(invoice));
    }

    @Test
    void testBucketM_whenKnownSupplier() {
        InvoiceType invoice = new InvoiceType();

        AccountingSupplierPartyType asp = new AccountingSupplierPartyType();
        PartyType party = new PartyType();
        PartyTaxSchemeType tax = new PartyTaxSchemeType();
        IDType companyId = new IDType();
        companyId.setValue("123456789");
        tax.setCompanyID(companyId);
        party.getPartyTaxScheme().add(tax);
        asp.setParty(party);
        invoice.setAccountingSupplierParty(asp);

        when(supplierService.isKnownSupplier("123456789")).thenReturn(true);

        assertEquals("M", resolver.resolveBucket(invoice));
    }

    @Test
    void testBucketF_whenNoMatch() {
        InvoiceType invoice = new InvoiceType();
        // No contract ID
        // No known supplier

        when(supplierService.isKnownSupplier(any())).thenReturn(false);

        assertEquals("F", resolver.resolveBucket(invoice));
    }
}
```

---

## ‚úÖ 3. How to Use in `XmlInvoiceWriter` or Anywhere

In your XML writer, processor, or file naming logic:

```java
@Autowired
private InvoiceBucketResolver bucketResolver;

...

String bucket = bucketResolver.resolveBucket(invoice); // "M" or "F"
String filename = bucket + "-" + invoice.getID().getValue() + ".xml";
```

---

## ‚úÖ Summary

| Class                       | Purpose                                   |
| --------------------------- | ----------------------------------------- |
| `InvoiceBucketResolver`     | Resolves if invoice goes in M or F bucket |
| `InvoiceBucketResolverTest` | Validates logic across 3 scenarios        |
| Usage                       | Prefix file or use in routing logic       |

---

Let me know if you'd like:

* To wire this into your Spring Batch job as part of the writer
* Add zip/encryption logic to post-process "M" and "F" files separately
* A test for how filenames are resolved

We can move to the next step!




Great ‚Äî that‚Äôs the cleanest approach for your case:

> You have **two separate jobs**:
> ‚úÖ `xmlInvoiceJob`
> ‚úÖ `csvInvoiceJob`

So you want to:

* Run **each job only if its own file type is present**
* Skip the job **entirely** if no relevant files exist **after** fetch/decrypt/unzip

---

## ‚úÖ Clean Architecture for This Setup

### Each Job Has:

* Step 1: `fetchDecryptAndUnzipStep`
* Step 2: `FilePresenceDecider` (job-specific)
* Step 3: Invoice processing step (XML or CSV)

---

## ‚úÖ 1. `XmlFilePresenceDecider.java`

```java
@Component
public class XmlFilePresenceDecider implements JobExecutionDecider {

    private static final String XML_DIR = "/tmp/unzipped/xml";

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        File dir = new File(XML_DIR);
        boolean hasXml = dir.exists() && dir.isDirectory() &&
                         Arrays.stream(dir.listFiles())
                               .anyMatch(f -> f.getName().endsWith(".xml"));

        return hasXml ? new FlowExecutionStatus("CONTINUE") : new FlowExecutionStatus("SKIP");
    }
}
```

---

## ‚úÖ 2. `CsvFilePresenceDecider.java`

```java
@Component
public class CsvFilePresenceDecider implements JobExecutionDecider {

    private static final String CSV_DIR = "/tmp/unzipped/csv";

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        File dir = new File(CSV_DIR);
        boolean hasCsv = dir.exists() && dir.isDirectory() &&
                         Arrays.stream(dir.listFiles())
                               .anyMatch(f -> f.getName().endsWith(".csv"));

        return hasCsv ? new FlowExecutionStatus("CONTINUE") : new FlowExecutionStatus("SKIP");
    }
}
```

---

## ‚úÖ 3. Job Config ‚Äî XML Job

```java
@Bean
public Job xmlInvoiceJob(JobBuilderFactory jobs,
                         Step fetchDecryptAndUnzipStep,
                         Step xmlProcessingStep,
                         XmlFilePresenceDecider xmlFilePresenceDecider) {

    return jobs.get("xmlInvoiceJob")
        .start(fetchDecryptAndUnzipStep)
        .next(xmlFilePresenceDecider)
            .on("CONTINUE").to(xmlProcessingStep)
        .from(xmlFilePresenceDecider)
            .on("SKIP").end()
        .end()
        .build();
}
```

---

## ‚úÖ 4. Job Config ‚Äî CSV Job

```java
@Bean
public Job csvInvoiceJob(JobBuilderFactory jobs,
                         Step fetchDecryptAndUnzipStep,
                         Step csvProcessingStep,
                         CsvFilePresenceDecider csvFilePresenceDecider) {

    return jobs.get("csvInvoiceJob")
        .start(fetchDecryptAndUnzipStep)
        .next(csvFilePresenceDecider)
            .on("CONTINUE").to(csvProcessingStep)
        .from(csvFilePresenceDecider)
            .on("SKIP").end()
        .end()
        .build();
}
```

---

## ‚úÖ Optional Enhancement: Share `fetchDecryptAndUnzipStep`

Since both jobs use the same fetch logic, you can reuse the step across both ‚Äî Spring Batch allows steps to be shared between jobs.

> Just be sure it's **stateless** or uses `@StepScope` if dynamic parameters are involved.

---

## ‚úÖ TL;DR ‚Äî You Now Have:

| Job             | Steps                                     |
| --------------- | ----------------------------------------- |
| `xmlInvoiceJob` | `fetchDecrypt ‚Üí XmlDecider ‚Üí xmlStep`     |
| `csvInvoiceJob` | `fetchDecrypt ‚Üí CsvDecider ‚Üí csvStep`     |
| Outcome         | Each job skips itself if no files present |

---

Would you like me to generate a shared helper to check file presence so both deciders are DRY? Or combine this into a sample working config file


Great ‚Äî you‚Äôre tying it all together now. Let‚Äôs break this down and give you a complete solution for:

‚∏ª

‚úÖ GOAL

After processing invoices (from XML), group them by supplier type:

	‚Ä¢	‚ÄúM‚Äù (miles suppliers)
	‚Ä¢	‚ÄúF‚Äù (finance suppliers)

Then:
	1.	‚úÖ Write each invoice as XML file
	2.	‚úÖ Group them into:
	‚Ä¢	miles-invoices.zip ‚Üí PGP encrypt ‚Üí upload to COS
	‚Ä¢	finance-invoices.zip ‚Üí PGP encrypt ‚Üí upload to COS

‚∏ª

üß± COMPONENTS NEEDED

We‚Äôll now implement:

Component	Responsibility
InvoiceBucketResolver	Determine M/F for each invoice
XmlInvoiceWriter (enhanced)	Write invoices into bucket-specific folders
ZipperService	Zip M/F folders separately
PgpEncryptionService	Encrypt zipped files
CosUploader	Upload encrypted files to COS
UploadCoordinator	Orchestrates zip + encrypt + upload post-job


‚∏ª

‚úÖ 1. InvoiceBucketResolver.java

Same as before (miles = ‚ÄúM‚Äù, finance = ‚ÄúF‚Äù):

@Component
@RequiredArgsConstructor
public class InvoiceBucketResolver {

    private final SupplierService supplierService;

    private static final List<String> PREFIXES = List.of("12", "13", "14", "15", "19");

    public String resolveBucket(InvoiceType invoice) {
        String contractId = Optional.ofNullable(invoice.getContractDocumentReference())
            .filter(l -> !l.isEmpty())
            .map(l -> l.get(0).getID().getValue())
            .orElse("");

        String companyId = Optional.ofNullable(invoice.getAccountingSupplierParty())
            .map(asp -> asp.getParty())
            .map(p -> p.getPartyTaxScheme())
            .filter(list -> !list.isEmpty())
            .map(list -> list.get(0).getCompanyID().getValue())
            .orElse("");

        boolean matchesPrefix = PREFIXES.stream().anyMatch(contractId::startsWith);
        boolean knownSupplier = supplierService.isKnownSupplier(companyId);

        return (matchesPrefix || knownSupplier) ? "M" : "F";
    }
}


‚∏ª

‚úÖ 2. XmlInvoiceWriter.java (enhanced writer)

Writes each invoice into /tmp/out/xml/M/ or /tmp/out/xml/F/ based on bucket:

@Component
@RequiredArgsConstructor
public class XmlInvoiceWriter implements ItemWriter<InvoiceType> {

    private final InvoiceBucketResolver bucketResolver;
    private final UblDocumentWriter documentWriter;

    @Override
    public void write(List<? extends InvoiceType> invoices) throws Exception {
        for (InvoiceType invoice : invoices) {
            String bucket = bucketResolver.resolveBucket(invoice);
            String id = invoice.getID().getValue();
            Path outputDir = Path.of("/tmp/out/xml", bucket);
            Files.createDirectories(outputDir);

            File outputFile = outputDir.resolve(id + ".xml").toFile();
            documentWriter.write(invoice, outputFile);
        }
    }
}


‚∏ª

‚úÖ 3. ZipperService.java

@Component
public class ZipperService {

    public File zipDirectory(Path dir, String outputZipName) throws IOException {
        Path zipPath = dir.resolveSibling(outputZipName);
        try (FileOutputStream fos = new FileOutputStream(zipPath.toFile());
             ZipOutputStream zos = new ZipOutputStream(fos)) {
            Files.walk(dir)
                .filter(Files::isRegularFile)
                .forEach(file -> {
                    try {
                        ZipEntry zipEntry = new ZipEntry(dir.relativize(file).toString());
                        zos.putNextEntry(zipEntry);
                        Files.copy(file, zos);
                        zos.closeEntry();
                    } catch (IOException e) {
                        throw new RuntimeException("Zipping failed", e);
                    }
                });
        }
        return zipPath.toFile();
    }
}


‚∏ª

‚úÖ 4. PgpEncryptionService.java

@Component
public class PgpEncryptionService {

    public File encrypt(File inputFile, File publicKeyFile, File outputEncryptedFile) throws Exception {
        // Use BouncyCastle or another PGP library
        // For simplicity assume it's implemented
        return outputEncryptedFile;
    }
}


‚∏ª

‚úÖ 5. CosUploader.java

@Component
@RequiredArgsConstructor
public class CosUploader {

    private final AmazonS3 s3; // Assume S3 compatible COS client

    public void upload(File file, String bucket, String key) {
        s3.putObject(bucket, key, file);
    }
}


‚∏ª

‚úÖ 6. UploadCoordinator.java

Orchestrates the post-processing

@Component
@RequiredArgsConstructor
public class UploadCoordinator {

    private final ZipperService zipperService;
    private final PgpEncryptionService pgpService;
    private final CosUploader cosUploader;

    @Value("${cos.bucket.miles}")
    private String milesBucket;

    @Value("${cos.bucket.finance}")
    private String financeBucket;

    @Value("${pgp.publicKey}")
    private File publicKey;

    public void postProcessAndUpload() throws Exception {
        Path baseDir = Path.of("/tmp/out/xml");

        for (String type : List.of("M", "F")) {
            Path dir = baseDir.resolve(type);
            if (!Files.exists(dir) || Files.list(dir).findAny().isEmpty()) continue;

            File zip = zipperService.zipDirectory(dir, type + "-invoices.zip");
            File encrypted = new File(zip.getParent(), zip.getName() + ".pgp");
            pgpService.encrypt(zip, publicKey, encrypted);

            String bucket = type.equals("M") ? milesBucket : financeBucket;
            String objectKey = "invoices/" + encrypted.getName();

            cosUploader.upload(encrypted, bucket, objectKey);
        }
    }
}


‚∏ª

‚úÖ 7. Trigger UploadCoordinator After Job

In Spring Batch, define a JobExecutionListener:

@Component
@RequiredArgsConstructor
public class UploadJobListener implements JobExecutionListener {

    private final UploadCoordinator uploadCoordinator;

    @Override
    public void afterJob(JobExecution jobExecution) {
        try {
            uploadCoordinator.postProcessAndUpload();
        } catch (Exception e) {
            throw new RuntimeException("Upload failed", e);
        }
    }
}

Attach it to your job:

@Bean
public Job xmlInvoiceJob(JobBuilderFactory jobs,
                         Step xmlProcessingStep,
                         UploadJobListener listener) {
    return jobs.get("xmlInvoiceJob")
        .start(xmlProcessingStep)
        .listener(listener)
        .build();
}


‚∏ª

‚úÖ Directory Structure Summary

/tmp/out/xml/
‚îú‚îÄ‚îÄ M/
‚îÇ   ‚îú‚îÄ‚îÄ invoice1.xml
‚îÇ   ‚îú‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ F/
‚îÇ   ‚îú‚îÄ‚îÄ invoiceA.xml
‚îÇ   ‚îú‚îÄ‚îÄ ...


‚∏ª

‚úÖ Final Flow Summary

Step	What It Does
XmlInvoiceWriter	Writes each invoice into /tmp/out/xml/M or /F
UploadCoordinator	Zips, encrypts, and uploads M and F buckets separately
UploadJobListener	Triggers upload at the end of the job


‚∏ª

‚úÖ Let Me Know If You Need
	‚Ä¢	Full working code with mocks/tests
	‚Ä¢	Integration with AWS S3 or IBM COS SDK
	‚Ä¢	PGP utility using BouncyCastle
	‚Ä¢	Dynamic bucket configuration per environment

Ready to plug into your job!

Yes ‚Äî you absolutely can and should do that!
It‚Äôs a great optimization, and it keeps your /tmp/unzipped directory clean and relevant to each job.

‚∏ª

‚úÖ Goal Recap

During the shared fetchDecryptAndUnzipStep, you want to:

	‚Ä¢	Only unzip CSV-related .zip.pgp files when running csvInvoiceJob
	‚Ä¢	Only unzip XML-related .zip.pgp files when running xmlInvoiceJob

‚∏ª

‚úÖ Solution: Use JobParameters to pass the job type

And inside your fetchDecryptAndUnzipTasklet, only process files of that type.

‚∏ª

‚úÖ 1. Pass job type as a parameter

When launching jobs:

jobLauncher.run(csvInvoiceJob, new JobParametersBuilder()
    .addString("jobType", "csv")
    .addLong("time", System.currentTimeMillis())
    .toJobParameters());

Or for XML:

jobLauncher.run(xmlInvoiceJob, new JobParametersBuilder()
    .addString("jobType", "xml")
    .addLong("time", System.currentTimeMillis())
    .toJobParameters());


‚∏ª

‚úÖ 2. Inject the jobType parameter in your tasklet

Use @StepScope and Spring EL to read the parameter dynamically.

@Component
@StepScope
public class FetchDecryptAndUnzipTasklet implements Tasklet {

    @Value("#{jobParameters['jobType']}")
    private String jobType;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        File fetchDir = new File("/input/downloaded"); // or wherever files are

        for (File encryptedFile : fetchDir.listFiles()) {
            if (!encryptedFile.getName().endsWith(".zip.pgp")) continue;

            if (shouldExtractFile(encryptedFile)) {
                // decrypt ‚Üí unzip ‚Üí /tmp/unzipped/xml or /tmp/unzipped/csv
                extractFileToTemp(encryptedFile);
            } else {
                System.out.println("Skipping unrelated file: " + encryptedFile.getName());
            }
        }

        return RepeatStatus.FINISHED;
    }

    private boolean shouldExtractFile(File file) {
        String name = file.getName().toLowerCase();

        return (jobType.equals("xml") && name.contains("xml")) ||
               (jobType.equals("csv") && name.contains("csv"));
    }

    private void extractFileToTemp(File encryptedFile) {
        // 1. Decrypt to temp ZIP
        // 2. Unzip to /tmp/unzipped/xml or /tmp/unzipped/csv based on jobType
        File unzipDir = new File("/tmp/unzipped/" + jobType);
        // ... implement logic here
    }
}


‚∏ª

‚úÖ 3. Update job configuration to inject the tasklet

Make sure the tasklet is declared as a bean:

@Bean
@StepScope
public FetchDecryptAndUnzipTasklet fetchDecryptAndUnzipTasklet() {
    return new FetchDecryptAndUnzipTasklet();
}

@Bean
public Step fetchDecryptAndUnzipStep(StepBuilderFactory steps,
                                     FetchDecryptAndUnzipTasklet tasklet) {
    return steps.get("fetchDecryptAndUnzipStep")
        .tasklet(tasklet)
        .build();
}


‚∏ª

‚úÖ What You Achieve

Job Type	Files Extracted To
csvInvoiceJob	/tmp/unzipped/csv/ only
xmlInvoiceJob	/tmp/unzipped/xml/ only

Unrelated files are skipped in the decrypt-unzip step.

‚∏ª

‚úÖ TL;DR

Task	Solution
Selective unzip per job	‚úÖ Use jobType JobParameter
Read it in tasklet	‚úÖ Use @StepScope + @Value(...)
Skip unrelated files	‚úÖ Use filename filter logic
Keep /tmp clean	‚úÖ Only write to relevant subfolder


‚∏ª

Let me know if you want:
	‚Ä¢	A fully working decrypt ‚Üí unzip utility
	‚Ä¢	File filtering based on metadata (not just filename)
	‚Ä¢	Integration with COS bucket listings (if pulling from COS)

We can easily extend this further.
import org.springframework.beans.factory.annotation.Value;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

@Component
public class TempCleanupTasklet implements Tasklet {

    @Value("${cleanup.zipPgpDir:/tmp}")
    private String zipPgpDir;

    @Value("${cleanup.fullDeleteDirs}")
    private String[] fullDeleteDirs; // will split by comma

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws IOException {
        // 1Ô∏è‚É£ Clean only .zip.pgp files in zipPgpDir
        try (Stream<Path> files = Files.list(Paths.get(zipPgpDir))) {
            files.filter(path -> path.getFileName().toString().endsWith(".zip.pgp"))
                 .forEach(path -> {
                     try {
                         Files.deleteIfExists(path);
                         System.out.println("Deleted: " + path);
                     } catch (IOException e) {
                         System.err.println("Failed to delete: " + path + " - " + e.getMessage());
                     }
                 });
        }

        // 2Ô∏è‚É£ Fully delete contents of specific subdirectories
        List<String> dirs = Arrays.asList(fullDeleteDirs);
        for (String dir : dirs) {
            Path directory = Paths.get(dir.trim());
            if (Files.exists(directory) && Files.isDirectory(directory)) {
                try (Stream<Path> files = Files.walk(directory)) {
                    files.sorted((a, b) -> b.compareTo(a)) // delete children first
                         .filter(Files::exists)
                         .forEach(path -> {
                             try {
                                 Files.delete(path);
                                 System.out.println("Deleted: " + path);
                             } catch (IOException e) {
                                 System.err.println("Failed to delete: " + path + " - " + e.getMessage());
                             }
                         });
                }
            }
        }

        return RepeatStatus.FINISHED;
    }
}

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;

import java.nio.file.Files;
import java.nio.file.Path;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;

class TempCleanupTaskletTest {

    @TempDir
    Path tmpDir; // Will be used for .zip.pgp cleanup

    @TempDir
    Path unzippedDir; // Will be fully deleted

    @TempDir
    Path processedDir; // Will be fully deleted

    @Test
    void testCleanupDeletesCorrectFiles() throws Exception {
        // Arrange: Create files
        Files.createFile(tmpDir.resolve("file1.zip.pgp")); // should be deleted
        Files.createFile(tmpDir.resolve("file2.txt"));     // should remain
        Files.createFile(unzippedDir.resolve("fileA.txt")); // should be deleted
        Files.createFile(processedDir.resolve("fileB.txt")); // should be deleted

        TempCleanupTasklet tasklet = new TempCleanupTasklet();
        tasklet.setZipPgpDir(tmpDir.toString());
        tasklet.setFullDeleteDirs(new String[]{
                unzippedDir.toString(),
                processedDir.toString()
        });

        // Act
        StepContribution contribution = mock(StepContribution.class);
        ChunkContext chunkContext = mock(ChunkContext.class);
        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        // Assert: Tasklet finished
        assertThat(status).isEqualTo(RepeatStatus.FINISHED);

        // Verify .zip.pgp file is gone
        assertThat(Files.exists(tmpDir.resolve("file1.zip.pgp"))).isFalse();

        // Verify .txt file remains
        assertThat(Files.exists(tmpDir.resolve("file2.txt"))).isTrue();

        // Verify directories are gone
        assertThat(Files.exists(unzippedDir)).isFalse();
        assertThat(Files.exists(processedDir)).isFalse();
    }
}



