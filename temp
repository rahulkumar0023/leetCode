import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.mockito.Mockito;

import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    private Path sourceDir;
    private Path targetDir;

    private PathConfig pathConfig;
    private SplitAttachmentMover mover;

    @BeforeEach
    void setup() throws Exception {
        sourceDir = Files.createDirectory(tempDir.resolve("unzippedXml"));
        targetDir = Files.createDirectory(tempDir.resolve("out"));

        pathConfig = Mockito.mock(PathConfig.class);
        PathConfig.Unzipped unzipped = Mockito.mock(PathConfig.Unzipped.class);

        when(pathConfig.getUnzipped()).thenReturn(unzipped);
        when(unzipped.getXml()).thenReturn(sourceDir);

        mover = new SplitAttachmentMover(pathConfig);
    }

    // -------------------------
    // Public API tests (moveAttachments)
    // -------------------------

    @Test
    void moveAttachments_copiesNewFormatAttachments_base_underscoreNN() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A_01.pdf", "pdf");
        write(sourceDir, "A_02.csv", "csv");
        write(sourceDir, "B_01.pdf", "other");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(2, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_01.pdf")));
        assertTrue(Files.exists(targetDir.resolve("OUT_02.csv")));
        assertFalse(Files.exists(targetDir.resolve("OUT.xml"))); // never copy xml as attachment
    }

    @Test
    void moveAttachments_supportsLegacy_baseDotExt_A_pdf() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "legacy");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT.pdf")));
    }

    @Test
    void moveAttachments_supportsOlderLegacy_baseDashNN_A_1_pdf() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-1.pdf", "olderLegacy");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-1.pdf")));
    }

    @Test
    void moveAttachments_skipsNonMatchingPrefix() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "X_01.pdf", "nope");
        write(sourceDir, "XA.pdf", "nope");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
        assertFalse(Files.exists(targetDir.resolve("OUT_01.pdf")));
        assertFalse(Files.exists(targetDir.resolve("OUTA.pdf")));
    }

    @Test
    void moveAttachments_ignoresNonRegularFiles() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        Files.createDirectory(sourceDir.resolve("A_01.pdf")); // directory named like attachment

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_createsUniqueNameIfTargetExists() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A_01.pdf", "pdf");

        // precreate output
        write(targetDir, "OUT_01.pdf", "existing");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_01-2.pdf")));
    }

    @Test
    void moveAttachments_returnsEmpty_whenInputsInvalid() {
        assertTrue(mover.moveAttachments("", "OUT.xml", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "OUT.xml", null).isEmpty());
    }

    @Test
    void moveAttachments_returnsEmpty_whenSourceDirMissing() throws Exception {
        // point sourceDir to a file instead of directory
        Path notADir = write(tempDir, "notADir.txt", "x");

        PathConfig.Unzipped unzipped = pathConfig.getUnzipped();
        when(unzipped.getXml()).thenReturn(notADir);

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_handlesIOException_whenTargetIsFile() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A_01.pdf", "pdf");

        Path targetIsFile = write(tempDir, "targetFile", "x");

        assertDoesNotThrow(() -> {
            List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetIsFile);
            assertTrue(moved.isEmpty());
        });
    }

    // -------------------------
    // Private method branch coverage (reflection)
    // This is needed because some branches are unreachable from filesystem iteration.
    // -------------------------

    @ParameterizedTest
    @CsvSource({
        // null/blank guards
        " ,A,false",
        "'',A,false",
        "A, ,false",
        "A,'',false",

        // xml itself must be false
        "A.xml,A,false",
        "a.XML,a,false",

        // prefix mismatch
        "B_01.pdf,A,false",

        // length <= baseLen branch (e.g., filename exactly base)
        "A,A,false",

        // separator not allowed: base followed by letter/number directly
        "A01.pdf,A,false",

        // allowed separators: '_', '.', '-'
        "A_01.pdf,A,true",
        "A.pdf,A,true",
        "A-1.pdf,A,true"
    })
    void isAttachmentForBase_privateMethodCoverage(String fileName, String base, boolean expected) throws Exception {
        boolean actual = invokeIsAttachmentForBase(fileName, base == null ? null : base.toLowerCase());
        assertEquals(expected, actual);
    }

    @Test
    void isAttachmentForBase_returnsFalse_whenFileNameDoesNotStartWithBase() throws Exception {
        assertFalse(invokeIsAttachmentForBase("XA.pdf", "a"));
        assertFalse(invokeIsAttachmentForBase("BA_01.pdf", "a"));
    }

    // -------------------------
    // Helpers
    // -------------------------

    private boolean invokeIsAttachmentForBase(String fileName, String normalizedBase) throws Exception {
        Method m = SplitAttachmentMover.class.getDeclaredMethod(
            "isAttachmentForBase", String.class, String.class
        );
        m.setAccessible(true);
        return (boolean) m.invoke(mover, fileName, normalizedBase);
    }

    private static Path write(Path dir, String name, String content) throws IOException {
        Path p = dir.resolve(name);
        Files.writeString(p, content);
        return p;
    }
}
