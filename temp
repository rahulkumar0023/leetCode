You‚Äôre right to suspect ‚Äúsomething is missing‚Äù ‚Äî the missing piece is **wiring**: you must (1) stop MapStruct from producing `taxTotal` from the *single* DTO, and (2) set `taxTotal` **once per group** after lines are built. That‚Äôs what guarantees **exactly one VAT-21 subtotal and one VAT-0 subtotal**.

Below are **all changes again, step-by-step**, with **no `safeAmount()`** (we‚Äôll use your existing `toAmount()` only).

---

# Step 1 ‚Äî Stop MapStruct from mapping `taxTotal` per row

In your mapper method:

```java
InvoiceType toInvoiceType(CsvInvoiceDto dto);
```

Add:

```java
@Mapping(target = "taxTotal", ignore = true)
```

So MapStruct will **not** call any old `toTaxTotal(dto)` expression and won‚Äôt create duplicates.

‚úÖ This is mandatory.

---

# Step 2 ‚Äî Compute TaxTotal once per invoice group

In your existing:

```java
default InvoiceType toInvoiceTypeGroup(CsvInvoiceGroup group)
```

After you build invoice lines, add:

```java
invoice.getTaxTotal().clear();
invoice.getTaxTotal().addAll(toTaxTotal(group));
```

So `TaxTotal` is set **one time**, using the whole invoice.

‚úÖ This is mandatory.

---

# Step 3 ‚Äî Add the group-level `toTaxTotal(CsvInvoiceGroup group)`

Add this `default` method in the same mapper interface:

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {

    TaxTotalType taxTotal = new TaxTotalType();

    TaxSubtotalType vat21 = buildVat21Subtotal(group);
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    TaxSubtotalType vat0 = buildVatZeroSubtotal(group);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

‚úÖ This guarantees **at most 2 subtotals**.

---

# Step 4 ‚Äî VAT 0 subtotal: taxable = SUM(LineExtensionAmount) for VAT=0

This implements exactly what you asked:

> ‚Äúcalculate all the total of fields from CSV InvoiceLine_cbc_LineExtensionAmount only in case of VAT zero exempt‚Äù

Add:

```java
default TaxSubtotalType buildVatZeroSubtotal(CsvInvoiceGroup group) {

    BigDecimal taxableSum = BigDecimal.ZERO;
    boolean hasVatZero = false;

    for (CsvInvoiceDto row : group.getRows()) {
        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat != null && vat.compareTo(BigDecimal.ZERO) == 0) {
            hasVatZero = true;

            BigDecimal lineExt = toAmount(row.getInvoiceLineCbcLineExtensionAmount());
            if (lineExt != null) {
                taxableSum = taxableSum.add(lineExt);
            }
        }
    }

    if (!hasVatZero) {
        return null;
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(BigDecimal.ZERO);
    taxSubtotal.setTaxAmount(taxAmount);

    // reuse your existing category method (should set ID=E, percent=0, etc.)
    TaxCategoryType taxCategory =
            getTaxCategory(BigDecimal.ZERO, false, group.getRows().get(0).getItemCbcName());
    taxSubtotal.setTaxCategory(taxCategory);

    return taxSubtotal;
}
```

‚úÖ VAT 0 subtotal printed **once**
‚úÖ Uses **LineExtensionAmount sum only** for VAT=0
‚úÖ TaxAmount explicitly 0
‚úÖ No duplicates

---

# Step 5 ‚Äî VAT 21 subtotal: print once (group-level)

Now decide what ‚Äútaxable‚Äù and ‚Äútax amount‚Äù should be for VAT 21:

### Option A (recommended, consistent with VAT 0):

Use `LineExtensionAmount` sum as taxable, and compute tax from it.

```java
default TaxSubtotalType buildVat21Subtotal(CsvInvoiceGroup group) {

    BigDecimal taxableSum = BigDecimal.ZERO;
    boolean hasVat21 = false;

    for (CsvInvoiceDto row : group.getRows()) {
        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat != null && vat.compareTo(new BigDecimal("21")) == 0) {
            hasVat21 = true;

            BigDecimal lineExt = toAmount(row.getInvoiceLineCbcLineExtensionAmount());
            if (lineExt != null) {
                taxableSum = taxableSum.add(lineExt);
            }
        }
    }

    if (!hasVat21) {
        return null;
    }

    BigDecimal taxSum = taxableSum
            .multiply(new BigDecimal("21"))
            .divide(new BigDecimal("100"));

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType taxCategory =
            getTaxCategory(new BigDecimal("21"), false, group.getRows().get(0).getItemCbcName());
    taxSubtotal.setTaxCategory(taxCategory);

    return taxSubtotal;
}
```

üìå If you already have correct ‚ÄúVAT amount‚Äù fields per line and don‚Äôt want to calculate: you can sum those instead of calculating `taxSum`.

### Option B (use your existing ‚Äúsubtotal excl vat‚Äù and ‚Äúvat amount‚Äù CSV fields)

If you already trust these two fields:

* `AdditionalItemProperty_cbc_SubTotalExclVatValue`
* `AdditionalItemProperty_cbc_SubTotalVatAmountValue`

Then in VAT 21 builder, sum those two instead. (Tell me if you want this variant; it‚Äôs a 2-line change inside the loop.)

---

# Step 6 ‚Äî Remove/ignore old `toTaxTotal(CsvInvoiceDto dto)` usage

If you still have your old per-row `toTaxTotal(dto)` method, you can keep it, but:

‚úÖ It must NOT be referenced from MapStruct mappings anymore
(because Step 1 ignored `taxTotal`)

So it becomes effectively unused for invoice tax totals.

---

# Step 7 ‚Äî Final wiring: update `toInvoiceTypeGroup(group)` (full view)

Here‚Äôs the complete ‚Äúgroup‚Äù method shape you should have:

```java
default InvoiceType toInvoiceTypeGroup(CsvInvoiceGroup group) {

    CsvInvoiceDto first = group.getRows().get(0);

    InvoiceType invoice = toInvoiceType(first);

    invoice.getInvoiceLine().clear();
    for (CsvInvoiceDto row : group.getRows()) {
        invoice.getInvoiceLine().add(toInvoiceLine(row));
    }

    invoice.getTaxTotal().clear();
    invoice.getTaxTotal().addAll(toTaxTotal(group));

    return invoice;
}
```

---

# Summary of ALL changes

1. **Mapping change**: `@Mapping(target="taxTotal", ignore=true)` on `toInvoiceType(dto)`
2. **Group method change**: set tax totals once using `toTaxTotal(group)`
3. **New methods** in mapper:

   * `toTaxTotal(CsvInvoiceGroup group)`
   * `buildVatZeroSubtotal(CsvInvoiceGroup group)` ‚úÖ uses sum of `LineExtensionAmount` for VAT 0
   * `buildVat21Subtotal(CsvInvoiceGroup group)` ‚úÖ prints VAT 21 once (choose A or B)

---

If you tell me which VAT-21 strategy you want:

* **A)** compute VAT from taxable sum, or
* **B)** sum your existing CSV VAT amount fields

‚Ä¶I‚Äôll give you the final VAT-21 method matching your real CSV columns exactly.
