Great, let’s line this up cleanly and step-by-step so it’s easy to drop into your code.

**Goal**

After your POST to CFT:

1. Extract `idtu`.
2. Poll `GET /transfers/{idtu}`.
3. If `sentinel = "SENDING"` → keep waiting (within your existing size-based max wait).
4. If `sentinel = "CANCELLED"` **or** `diagi != 0` →

   * print `diagi` + `diagnostic`,
   * retry the **POST** once (full POST+GET again).
5. If it still fails → let the exception bubble so the batch fails like today.

We’ll reuse your **size-based wait Duration** (from the tasklet) as `maxWait`.

---

## Step 1 – Define a DTO for the status GET response

This matches what `/transfers/{idtu}` returns.

```java
public class TransferStatusResponse {

    private String idtu;
    private String sentinel;   // "COMPLETED", "SENDING", "CANCELLED", ...
    private int diagi;         // 0 = OK
    private String diagnostic; // text

    // getters and setters
}
```

Adjust field names if JSON is slightly different (with `@JsonProperty` if needed).

---

## Step 2 – Define a specific exception for “CANCELLED / diagi != 0”

We want to retry **only** in that case, not on every kind of error.

```java
public class TransferFailedException extends RuntimeException {
    public TransferFailedException(String message) {
        super(message);
    }
}
```

---

## Step 3 – Implement GET `/transfers/{idtu}` in your `CftApiClient`

Use your existing `RestTemplate` + `ObjectMapper`.

```java
private TransferStatusResponse getTransferStatus(String idtu) {
    String url = baseURL + "/transfers/{idtu}";   // adjust if your path differs

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("idtu", idtu);

    ResponseEntity<String> response =
            restTemplate.exchange(url, HttpMethod.GET, null, String.class, uriVariables);

    log.info("CFT GET status for idtu={} -> {}", idtu, response.getStatusCode());
    log.debug("CFT GET body: {}", response.getBody());

    try {
        return objectMapper.readValue(response.getBody(), TransferStatusResponse.class);
    } catch (Exception e) {
        throw new IllegalStateException("Failed to parse CFT status for idtu=" + idtu, e);
    }
}
```

---

## Step 4 – Poll `GET` until done or failed, using your max wait

This is where we look at `sentinel` and `diagi`.

```java
private void waitUntilTransferFinished(String idtu, Duration maxWait) {
    Duration pollInterval = Duration.ofSeconds(5);    // or whatever you like
    Instant deadline = Instant.now().plus(maxWait);

    while (true) {
        TransferStatusResponse status = getTransferStatus(idtu);

        String sentinel = status.getSentinel();
        int diagi = status.getDiagi();
        String diagText = status.getDiagnostic();

        log.info("CFT status idtu={} sentinel={} diagi={} diagnostic={}",
                 idtu, sentinel, diagi, diagText);

        // ✅ success
        if ("COMPLETED".equalsIgnoreCase(sentinel) && diagi == 0) {
            return;
        }

        // ❌ business failure: this is the one case we want to retry POST once
        if ("CANCELLED".equalsIgnoreCase(sentinel) || diagi != 0) {
            // print diagi and diagnostic in log message
            throw new TransferFailedException(
                    String.format("CFT transfer FAILED idtu=%s sentinel=%s diagi=%d diagnostic=%s",
                                  idtu, sentinel, diagi, diagText));
        }

        // ⏳ still running
        if ("SENDING".equalsIgnoreCase(sentinel)) {
            if (Instant.now().isAfter(deadline)) {
                throw new IllegalStateException(
                        String.format("CFT transfer still SENDING after %s for idtu=%s",
                                      maxWait, idtu));
            }

            try {
                Thread.sleep(pollInterval.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting for CFT status", e);
            }
            continue;
        }

        // any unexpected sentinel
        throw new IllegalStateException(
                String.format("Unexpected CFT sentinel='%s' for idtu=%s diagi=%d diagnostic=%s",
                              sentinel, idtu, diagi, diagText));
    }
}
```

**Important:** Only `CANCELLED` or `diagi != 0` throws `TransferFailedException`.
Everything else throws other exceptions → will **not** be retried.

---

## Step 5 – Extract your POST logic into a helper that returns `idtu`

This is your current POST code, wrapped and returning `idtu`.

```java
private String triggerTransferOnce(String outPath, String fileName, int attempt) throws Exception {
    String apiUrl = baseURL + "?part={part}&idtf={idtf}";

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);

    Map<String, String> requestBody = new HashMap<>();
    requestBody.put("fname", outPath);
    requestBody.put("pname", fileName);
    requestBody.put("sync", "YES");

    String jsonPayload = objectMapper.writeValueAsString(requestBody);
    HttpEntity<String> requestEntity = new HttpEntity<>(jsonPayload, headers);

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("part", destPART);
    uriVariables.put("idtf", destIDF);

    log.info("Sending CFT POST attempt {} to: {}", attempt, apiUrl);
    log.info("Headers: {}", headers);
    log.info("Body   : {}", requestBody);

    ResponseEntity<String> response =
            restTemplate.exchange(apiUrl, HttpMethod.POST, requestEntity,
                                  String.class, uriVariables);

    log.info("CFT POST attempt {} status: {}", attempt, response.getStatusCode());
    log.info("CFT POST attempt {} body  : {}", attempt, response.getBody());

    // Extract idtu from POST response
    JsonNode root = objectMapper.readTree(response.getBody());
    String idtu = root.path("idtu").asText(null);    // adjust if field name is different

    if (idtu == null || idtu.isEmpty()) {
        throw new IllegalStateException("CFT POST response did not contain idtu (attempt " + attempt + ")");
    }

    return idtu;
}
```

---

## Step 6 – Retry POST (once) when we get `CANCELLED` or `diagi != 0`

Now we glue it all together with a single retry.

```java
public void notifyAndWaitForCompletion(String outPath,
                                       String fileName,
                                       Duration maxWait) {
    // FIRST attempt
    try {
        String idtu = triggerTransferOnce(outPath, fileName, 1);
        waitUntilTransferFinished(idtu, maxWait);    // may throw TransferFailedException
        return;                                      // ✅ success, done
    } catch (TransferFailedException ex) {
        // This is specifically sentinel=CANCELLED or diagi!=0
        log.warn("CFT transfer failed on first attempt for file {}: {}. Retrying POST once...",
                 fileName, ex.getMessage());
    } catch (Exception ex) {
        // other errors in POST or parsing: you can choose to retry or not
        log.warn("CFT POST failed on first attempt for file {}: {}. Retrying POST once...",
                 fileName, ex.getMessage());
    }

    // SECOND (and last) attempt – if this fails, we let it bubble up
    try {
        String retryIdtu = triggerTransferOnce(outPath, fileName, 2);
        waitUntilTransferFinished(retryIdtu, maxWait);  // if this throws, job fails
    } catch (Exception ex) {
        throw new IllegalStateException("CFT notify failed after retry for file " + fileName, ex);
    }
}
```

So:

* Only **CANCELLED / diagi != 0** throw `TransferFailedException` → triggers the retry.
* If the second attempt also returns `CANCELLED` / error or something else goes wrong, the exception is thrown and your **batch step fails** as it does today.

---

## Step 7 – Use your existing size-based wait in the tasklet

In your `PackageAndUploadFilesTasklet`, where you previously did:

```java
if (cftEnabled) {
    cftApiClient.notifyUpload(key, encryptedFileName);

    // old: sleep based on size here
    // Thread.sleep(grace.toMillis());
}
```

Change to:

```java
if (cftEnabled) {
    long bytes = encryptedFile.length();
    Duration maxWait = pickWaitByTier(bytes, waittime); // your existing logic

    log.info("Payload size={} bytes. Using maxWait={} for CFT polling.", bytes, maxWait);
    cftApiClient.notifyAndWaitForCompletion(key, encryptedFileName, maxWait);
}
```

Now:

* Your **size-based wait** becomes a graceful *deadline* for CFT to finish.
* You **actively check** status (`sentinel`, `diagi`, `diagnostic`) instead of blind sleeping.
* On `CANCELLED` / `diagi != 0`:

  * You log everything,
  * retry POST + GET once,
  * then fail the job if it still doesn’t work.

If you want, next step we can add a tiny unit test for `waitUntilTransferFinished` that simulates `SENDING → SENDING → COMPLETED` and `CANCELLED`, but the above is the full set of “clean steps” to implement the behavior you described.
