Great â€” a `Tasklet` is the perfect fit when you want to perform **imperative, single-purpose logic**, like fetching, decrypting, and unzipping files in sequence. Here's how you can structure it:

---

## âœ… Plan

Create a `DecryptAndUnzipTasklet` that:

1. Calls `cosService.fetchEncryptedFiles()` â†’ returns `List<File>`
2. Decrypts each `.zip.pgp` file â†’ returns decrypted `.zip` files
3. Unzips each `.zip` file into `/tmp/unzipped/` or another working directory

---

## âœ… 1. `CosStorageService.java` (simplified)

```java
@Component
public class CosStorageService {

    public List<File> fetchEncryptedFiles() {
        // Simulate fetching encrypted files from COS to /tmp
        return List.of(new File("/tmp/invoice-batch-1.zip.pgp"));
    }
}
```

---

## âœ… 2. `DecryptAndUnzipTasklet.java`

```java
@Component
public class DecryptAndUnzipTasklet implements Tasklet {

    private final CosStorageService cosService;

    public DecryptAndUnzipTasklet(CosStorageService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        List<File> encryptedFiles = cosService.fetchEncryptedFiles();
        for (File encrypted : encryptedFiles) {
            File decryptedZip = decryptFile(encrypted);
            unzipFile(decryptedZip, Paths.get("/tmp/unzipped"));
        }
        return RepeatStatus.FINISHED;
    }

    private File decryptFile(File encryptedFile) throws IOException {
        // Simulated decryption: just rename file (in real life, use BouncyCastle, etc.)
        File decrypted = new File(encryptedFile.getAbsolutePath().replace(".pgp", ""));
        Files.copy(encryptedFile.toPath(), decrypted.toPath(), StandardCopyOption.REPLACE_EXISTING);
        System.out.println("Decrypted: " + decrypted.getName());
        return decrypted;
    }

    private void unzipFile(File zipFile, Path targetDir) throws IOException {
        targetDir.toFile().mkdirs();
        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                File outFile = targetDir.resolve(entry.getName()).toFile();
                try (FileOutputStream fos = new FileOutputStream(outFile)) {
                    zis.transferTo(fos);
                }
                System.out.println("Extracted: " + outFile.getName());
            }
        }
    }
}
```

---

## âœ… 3. Add to Your Batch Config

```java
@Bean
public Step decryptUnzipStep(JobRepository repo, PlatformTransactionManager tx,
                              DecryptAndUnzipTasklet tasklet) {
    return new StepBuilder("decryptUnzipStep", repo)
            .tasklet(tasklet, tx)
            .build();
}
```

Then chain it before your invoice step in the job:

```java
@Bean
public Job invoiceJob(JobRepository repo, Step decryptUnzipStep, Step invoiceStep) {
    return new JobBuilder("invoiceJob", repo)
            .start(decryptUnzipStep)
            .next(invoiceStep)
            .build();
}
```

---

## âœ… Result

Your batch job now:

1. **Fetches** `.zip.pgp` files from COS
2. **Decrypts** them to `.zip`
3. **Unzips** them into `/tmp/unzipped`
4. **Then Step 2** reads & processes each XML invoice

---

Would you like a test tasklet runner or unit tests for this setup?




Yes â€” splitting into **three dedicated steps** is an excellent design. It provides:

* âœ… Clear separation of concerns
* âœ… Easier debugging
* âœ… Independent retries
* âœ… Cleaner logging and exception handling

---

## âœ… Recommended 3-Step Spring Batch Job

### ðŸ”¹ **Step 1: `fetchEncryptedStep`**

* Fetch `.zip.pgp` files from COS (download to `/tmp/encrypted`)
* Store downloaded `File` paths in `ExecutionContext` or local directory

### ðŸ”¹ **Step 2: `decryptAndUnzipStep`**

* Read the encrypted files from `/tmp/encrypted`
* Decrypt `.pgp` â†’ `.zip`
* Unzip `.zip` â†’ `.xml` into `/tmp/unzipped`

### ðŸ”¹ **Step 3: `invoiceStep`**

* Multi-resource XML reader reads from `/tmp/unzipped`
* Your existing processor & writer
* Upload processed files back to COS or move to archive

---

## âœ… Technical Breakdown

### 1. `fetchEncryptedTasklet`

```java
@Component
public class FetchEncryptedTasklet implements Tasklet {

    private final CosStorageService cosService;

    public FetchEncryptedTasklet(CosStorageService cosService) {
        this.cosService = cosService;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext context) throws Exception {
        List<String> cosKeys = List.of("invoices-batch1.zip.pgp", "invoices-batch2.zip.pgp");

        for (String key : cosKeys) {
            File localFile = cosService.downloadToLocal(key); // saves to /tmp/encrypted
            System.out.println("Fetched: " + localFile.getAbsolutePath());
        }

        return RepeatStatus.FINISHED;
    }
}
```

---

### 2. `decryptAndUnzipTasklet`

```java
@Component
public class DecryptAndUnzipTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext context) throws Exception {
        File[] encryptedFiles = new File("/tmp/encrypted").listFiles((dir, name) -> name.endsWith(".pgp"));
        if (encryptedFiles == null) return RepeatStatus.FINISHED;

        for (File pgpFile : encryptedFiles) {
            File zipFile = decrypt(pgpFile); // simulate decryption
            unzip(zipFile, new File("/tmp/unzipped"));
        }

        return RepeatStatus.FINISHED;
    }

    private File decrypt(File pgp) throws IOException {
        File zip = new File(pgp.getAbsolutePath().replace(".pgp", ""));
        Files.copy(pgp.toPath(), zip.toPath(), StandardCopyOption.REPLACE_EXISTING);
        return zip;
    }

    private void unzip(File zipFile, File destDir) throws IOException {
        destDir.mkdirs();
        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                File newFile = new File(destDir, entry.getName());
                try (FileOutputStream fos = new FileOutputStream(newFile)) {
                    zis.transferTo(fos);
                }
            }
        }
    }
}
```

---

### 3. `invoiceStep` (already implemented)

```java
@Bean
public Step invoiceStep(JobRepository repo, PlatformTransactionManager tx,
                        InvoiceProcessor proc, InvoiceWriter writer) throws IOException {
    MultiResourceItemReader<InvoiceType> reader = new MultiResourceItemReader<>();
    reader.setResources(new PathMatchingResourcePatternResolver()
        .getResources("file:/tmp/unzipped/*.xml"));
    reader.setDelegate(new SingleInvoiceReader());

    return new StepBuilder("invoiceStep", repo)
            .<InvoiceType, InvoiceType>chunk(1, tx)
            .reader(reader)
            .processor(proc)
            .writer(writer)
            .build();
}
```

---

## âœ… Final Job Configuration

```java
@Bean
public Job invoiceJob(JobRepository repo,
                      Step fetchEncryptedStep,
                      Step decryptAndUnzipStep,
                      Step invoiceStep) {

    return new JobBuilder("invoiceJob", repo)
            .start(fetchEncryptedStep)
            .next(decryptAndUnzipStep)
            .next(invoiceStep)
            .build();
}
```

---

Would you like me to generate all the actual Spring bean definitions for these three steps now?



Perfect â€” to clean up **all temp files** (ZIPs, PGPs, XMLs, and the unzipped folder), you can add a final **cleanup Tasklet** as **Step 4** in your job.

---

## âœ… Cleanup Tasklet

### ðŸ”¹ `TempFileCleanupTasklet.java`

```java
@Component
public class TempFileCleanupTasklet implements Tasklet {

    private static final Path TMP_DIR = Paths.get("/tmp");
    private static final Path UNZIPPED_DIR = TMP_DIR.resolve("unzipped");

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        // Delete *.zip, *.pgp, *.xml from /tmp
        try (Stream<Path> files = Files.list(TMP_DIR)) {
            files.filter(path -> {
                String name = path.getFileName().toString().toLowerCase();
                return name.endsWith(".zip") || name.endsWith(".pgp") || name.endsWith(".xml");
            }).forEach(path -> {
                try {
                    Files.deleteIfExists(path);
                    System.out.println("Deleted: " + path);
                } catch (IOException e) {
                    System.err.println("Failed to delete: " + path + " â€” " + e.getMessage());
                }
            });
        }

        // Delete all files inside /tmp/unzipped
        if (Files.exists(UNZIPPED_DIR)) {
            Files.walk(UNZIPPED_DIR)
                .sorted(Comparator.reverseOrder()) // delete children before parent
                .map(Path::toFile)
                .forEach(File::delete);
            System.out.println("Cleaned up /tmp/unzipped");
        }

        return RepeatStatus.FINISHED;
    }
}
```

---

## âœ… Register Cleanup Step

### In `BatchConfig.java`:

```java
@Bean
public Step cleanupStep(JobRepository repo, PlatformTransactionManager tx, TempFileCleanupTasklet tasklet) {
    return new StepBuilder("cleanupStep", repo)
            .tasklet(tasklet, tx)
            .build();
}
```

---

## âœ… Update the Job

```java
@Bean
public Job invoiceJob(JobRepository repo,
                      Step fetchEncryptedStep,
                      Step decryptAndUnzipStep,
                      Step invoiceStep,
                      Step cleanupStep) {

    return new JobBuilder("invoiceJob", repo)
            .start(fetchEncryptedStep)
            .next(decryptAndUnzipStep)
            .next(invoiceStep)
            .next(cleanupStep) // âœ… Final cleanup
            .build();
}
```

---

This ensures all temporary files are removed **after successful invoice processing**, keeping your system clean and ready for the next run.

Would you like this step to run conditionally (e.g., only if previous steps succeed)?




private void unzipFile(File zipFile, Path targetDir) throws IOException {
    // Ensure /tmp/unzipped directory exists
    Files.createDirectories(targetDir);

    System.out.println("Unzipping: " + zipFile.getAbsolutePath());
    System.out.println("Target directory: " + targetDir.toAbsolutePath());

    try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {
        ZipEntry entry;
        while ((entry = zis.getNextEntry()) != null) {
            Path resolvedPath = targetDir.resolve(entry.getName()).normalize();

            // Ensure path is not malicious (zip-slip attack)
            if (!resolvedPath.startsWith(targetDir)) {
                throw new IOException("Entry is outside target dir: " + entry.getName());
            }

            if (entry.isDirectory()) {
                Files.createDirectories(resolvedPath);
            } else {
                Files.createDirectories(resolvedPath.getParent()); // ensure parent dir exists
                try (OutputStream out = Files.newOutputStream(resolvedPath)) {
                    zis.transferTo(out);
                }
                System.out.println("Extracted: " + resolvedPath.toAbsolutePath());
            }
        }
    }

    // Confirm directory exists after unzip
    System.out.println("Final check: " + targetDir + " exists? " + Files.exists(targetDir));
}

