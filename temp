@Component
public class InvoiceWriter implements ItemWriter<InvoiceType>, StepExecutionListener {

    private final Logger log = LoggerFactory.getLogger(getClass());
    private ExecutionContext context;

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.context = stepExecution.getExecutionContext();
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    @Override
    public void write(Chunk<? extends InvoiceType> items) {
        for (InvoiceType invoice : items) {
            String sourcePath = (String) context.get("current.file");
            if (sourcePath != null) {
                Path source = Paths.get(sourcePath);
                Path target = Paths.get("processed", source.getFileName().toString());

                try {
                    Files.createDirectories(target.getParent());
                    Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
                    log.info("Moved file {} to {}", source, target);
                } catch (IOException e) {
                    log.error("Failed to move file", e);
                }
            }

            log.info("Processed invoice ID: {}", invoice.getID().getValue());
        }
    }
}


Absolutely — here’s the complete, working code for your use case: reading XML invoices from a directory, tracking the current file, and writing (or moving) it to a processed/ folder using Spring Batch.

⸻

✅ 1. SingleInvoiceReader.java

public class SingleInvoiceReader implements
        ResourceAwareItemReaderItemStream<InvoiceType>,
        StepExecutionListener {

    private Resource resource;
    private ExecutionContext stepContext;
    private boolean alreadyRead = false;

    @Override
    public void setResource(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void open(ExecutionContext executionContext) {
        alreadyRead = false;
    }

    @Override
    public InvoiceType read() throws Exception {
        if (alreadyRead) return null;

        JAXBContext context = JAXBContext.newInstance("network.oxalis.peppol.ubl2.jaxb");
        Unmarshaller unmarshaller = context.createUnmarshaller();

        try (InputStream is = resource.getInputStream()) {
            JAXBElement<InvoiceType> root = (JAXBElement<InvoiceType>) unmarshaller.unmarshal(is);
            alreadyRead = true;
            return root.getValue();
        }
    }

    @Override
    public void update(ExecutionContext executionContext) {}

    @Override
    public void close() {}

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepContext = stepExecution.getExecutionContext();
        try {
            if (resource != null && resource.exists()) {
                String path = resource.getFile().getAbsolutePath();
                stepContext.putString("current.file", path);
            }
        } catch (IOException e) {
            throw new RuntimeException("Error accessing input file", e);
        }
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }
}


⸻

✅ 2. InvoiceWriter.java

@Component
public class InvoiceWriter implements ItemWriter<InvoiceType>, StepExecutionListener {

    private ExecutionContext context;

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.context = stepExecution.getExecutionContext();
    }

    @Override
    public void write(Chunk<? extends InvoiceType> items) {
        String sourcePath = context.getString("current.file", null);

        if (sourcePath != null) {
            Path source = Paths.get(sourcePath);
            Path target = Paths.get("src/main/resources/processed", source.getFileName().toString());

            try {
                Files.createDirectories(target.getParent());
                Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
                System.out.println("Copied to: " + target);
            } catch (IOException e) {
                System.err.println("Failed to move file: " + e.getMessage());
            }
        }

        for (InvoiceType invoice : items) {
            System.out.println("Processed invoice ID: " + invoice.getID().getValue());
        }
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }
}


⸻

✅ 3. Spring Configuration Snippet (Reader Bean)

@Bean
public MultiResourceItemReader<InvoiceType> multiInvoiceReader() throws IOException {
    MultiResourceItemReader<InvoiceType> reader = new MultiResourceItemReader<>();

    Resource[] resources = new PathMatchingResourcePatternResolver()
            .getResources("classpath:input/*.xml");

    reader.setResources(resources);
    reader.setDelegate(singleInvoiceReader());
    return reader;
}

@Bean
public SingleInvoiceReader singleInvoiceReader() {
    return new SingleInvoiceReader();
}


⸻

Important Notes:
	•	The files are copied to src/main/resources/processed/ for dev/test only.
	•	Replace copy with move in Files.copy(...) if you want to actually move them.
	•	Later, swap the file path with a COS uploader to integrate with cloud storage.

⸻

Would you like me to generate unit tests for this updated version too?



Absolutely — here’s the complete code setup for your two-step Spring Batch job:

⸻

✅ Step 1: COS Decrypt & Unzip

CosStorageService.java (placeholder for COS access)

@Component
public class CosStorageService {

    public File download(String cosKey) throws IOException {
        // Simulate download to /tmp
        File file = new File("/tmp/" + Paths.get(cosKey).getFileName());
        // TODO: Replace with actual COS SDK download
        System.out.println("Downloaded: " + file.getAbsolutePath());
        return file;
    }

    public void upload(File file, String targetKey) {
        // TODO: Implement upload to COS
        System.out.println("Uploading " + file.getName() + " to COS key: " + targetKey);
    }
}


⸻

CosFileReader.java

public class CosFileReader implements ItemReader<File> {

    private final Iterator<String> cosKeys;
    private final CosStorageService cosStorageService;

    public CosFileReader(List<String> keys, CosStorageService service) {
        this.cosKeys = keys.iterator();
        this.cosStorageService = service;
    }

    @Override
    public File read() throws Exception {
        return cosKeys.hasNext() ? cosStorageService.download(cosKeys.next()) : null;
    }
}


⸻

DecryptAndUnzipProcessor.java

public class DecryptAndUnzipProcessor implements ItemProcessor<File, List<File>> {

    @Override
    public List<File> process(File encryptedFile) throws Exception {
        // Simulated decrypt
        File decryptedZip = new File(encryptedFile.getAbsolutePath().replace(".pgp", ""));
        // Simulated unzip
        File targetDir = new File("/tmp/unzipped");
        targetDir.mkdirs();
        // TODO: Use real PGP decryptor and unzip logic
        System.out.println("Decrypted & unzipped: " + decryptedZip.getName());
        return List.of(new File(targetDir, "invoice1.xml")); // Simulated result
    }
}


⸻

XmlFileWriter.java

public class XmlFileWriter implements ItemWriter<List<File>> {
    @Override
    public void write(Chunk<? extends List<File>> items) {
        for (List<File> fileList : items) {
            fileList.forEach(f -> System.out.println("Ready to process XML: " + f.getAbsolutePath()));
        }
    }
}


⸻

✅ Step 2: XML Processing

InvoiceReader.java

public class InvoiceReader extends MultiResourceItemReader<InvoiceType> {
    public InvoiceReader(SingleInvoiceReader delegate) throws IOException {
        setResources(new PathMatchingResourcePatternResolver().getResources("file:/tmp/unzipped/*.xml"));
        setDelegate(delegate);
    }
}

SingleInvoiceReader.java

public class SingleInvoiceReader implements ResourceAwareItemReaderItemStream<InvoiceType> {

    private Resource resource;
    private boolean read = false;

    @Override
    public void setResource(Resource resource) {
        this.resource = resource;
    }

    @Override
    public InvoiceType read() throws Exception {
        if (read) return null;
        JAXBContext ctx = JAXBContext.newInstance("network.oxalis.peppol.ubl2.jaxb");
        Unmarshaller unmarshaller = ctx.createUnmarshaller();
        InvoiceType invoice = (InvoiceType) ((JAXBElement<?>) unmarshaller.unmarshal(resource.getInputStream())).getValue();
        read = true;
        return invoice;
    }

    @Override public void open(ExecutionContext ctx) { read = false; }
    @Override public void update(ExecutionContext ctx) {}
    @Override public void close() {}
}


⸻

InvoiceProcessor.java

@Component
public class InvoiceProcessor implements ItemProcessor<InvoiceType, InvoiceType> {
    @Override
    public InvoiceType process(InvoiceType item) {
        System.out.println("Processing invoice: " + item.getID().getValue());
        return item;
    }
}


⸻

InvoiceWriter.java

@Component
public class InvoiceWriter implements ItemWriter<InvoiceType> {

    private final CosStorageService cosService;

    public InvoiceWriter(CosStorageService service) {
        this.cosService = service;
    }

    @Override
    public void write(Chunk<? extends InvoiceType> items) {
        for (InvoiceType invoice : items) {
            File file = new File("/tmp/unzipped/" + invoice.getID().getValue() + ".xml");
            cosService.upload(file, "processed/" + file.getName());
        }
    }
}


⸻

✅ BatchConfig.java

@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Bean
    public Step cosStep(JobRepository repo, PlatformTransactionManager tx, CosStorageService cosService) {
        return new StepBuilder("cosStep", repo)
                .<File, List<File>>chunk(1, tx)
                .reader(new CosFileReader(List.of("file1.zip.pgp"), cosService))
                .processor(new DecryptAndUnzipProcessor())
                .writer(new XmlFileWriter())
                .build();
    }

    @Bean
    public Step invoiceStep(JobRepository repo, PlatformTransactionManager tx,
                            InvoiceProcessor proc, InvoiceWriter writer) throws IOException {
        SingleInvoiceReader delegate = new SingleInvoiceReader();
        return new StepBuilder("invoiceStep", repo)
                .<InvoiceType, InvoiceType>chunk(1, tx)
                .reader(new InvoiceReader(delegate))
                .processor(proc)
                .writer(writer)
                .build();
    }

    @Bean
    public Job job(JobRepository repo, Step cosStep, Step invoiceStep) {
        return new JobBuilder("cosInvoiceJob", repo)
                .start(cosStep)
                .next(invoiceStep)
                .build();
    }
}


⸻

Would you like to simulate PGP decryption and unzip with test files for local testing too?
