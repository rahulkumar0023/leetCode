Perfect üëç ‚Äî that‚Äôs a great candidate for a focused **JUnit 5 + Mockito** test.
Your `PGPConfig` class creates two beans:

* `pgpEncrypt()` ‚Üí loads a public key, builds a `PGPEncrypt`
* `pgpDecrypt()` ‚Üí loads a private key, builds a `PGPDecrypt`

Both depend on a `ResourceLoader` and `KeysManagerUtils` static methods.

---

## ‚úÖ **Goal**

* Provide **unit-level coverage** for both bean methods.
* Mock `ResourceLoader`, `Resource`, and `KeysManagerUtils`.
* Verify:

  * The public/private keys are loaded.
  * The correct beans are returned.

---

## ‚úÖ **JUnit Test (using JUnit 5 + Mockito + MockedStatic)**

```java
package com.bnpp.pf.einvoice.connect.pgp;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;

import java.io.File;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class PGPConfigTest {

    @Mock
    private ResourceLoader resourceLoader;

    @Mock
    private Resource mockResource;

    private PGPConfig pgpConfig;

    @BeforeEach
    void setUp() {
        pgpConfig = new PGPConfig();
        // inject test values
        pgpConfig.pgpPublicKeyPath = "classpath:keys/public.asc";
        pgpConfig.pgpPrivateKeyPath = "classpath:keys/private.asc";
        pgpConfig.privateKeyCred = "secret".toCharArray();
    }

    @Test
    void shouldLoadPublicKeyAndBuildEncryptBean() throws Exception {
        // Arrange
        File mockFile = new File("public.asc");
        when(resourceLoader.getResource(pgpConfig.pgpPublicKeyPath)).thenReturn(mockResource);
        when(mockResource.getFile()).thenReturn(mockFile);

        PfPGPPublicKey mockPublicKey = mock(PfPGPPublicKey.class);
        PGPEncrypt mockEncrypt = mock(PGPEncrypt.class);

        try (MockedStatic<KeysManagerUtils> keysManagerMock = mockStatic(KeysManagerUtils.class);
             MockedStatic<PGPEncryptBuilder> builderMock = mockStatic(PGPEncryptBuilder.class)) {

            keysManagerMock.when(() -> KeysManagerUtils.loadPublicKeyFromAsc(mockFile))
                    .thenReturn(mockPublicKey);

            PGPEncryptBuilder builder = mock(PGPEncryptBuilder.class);
            when(builder.build()).thenReturn(mockEncrypt);
            builderMock.when(() -> new PGPEncryptBuilder(mockPublicKey)).thenReturn(builder);

            // Act
            PGPEncrypt result = pgpConfig.pgpEncrypt(resourceLoader);

            // Assert
            assertThat(result).isEqualTo(mockEncrypt);
            keysManagerMock.verify(() -> KeysManagerUtils.loadPublicKeyFromAsc(mockFile));
            builderMock.verify(() -> new PGPEncryptBuilder(mockPublicKey));
            verify(builder).build();
        }
    }

    @Test
    void shouldLoadPrivateKeyAndBuildDecryptBean() throws Exception {
        // Arrange
        File mockFile = new File("private.asc");
        when(resourceLoader.getResource(pgpConfig.pgpPrivateKeyPath)).thenReturn(mockResource);
        when(mockResource.getFile()).thenReturn(mockFile);

        PfPGPPrivateKeys mockPrivateKeys = mock(PfPGPPrivateKeys.class);
        PGPDecrypt mockDecrypt = mock(PGPDecrypt.class);

        try (MockedStatic<KeysManagerUtils> keysManagerMock = mockStatic(KeysManagerUtils.class);
             MockedStatic<PGPDecryptBuilder> builderMock = mockStatic(PGPDecryptBuilder.class)) {

            keysManagerMock.when(() ->
                    KeysManagerUtils.loadPrivateKeysFromAsc(mockFile, pgpConfig.privateKeyCred))
                    .thenReturn(mockPrivateKeys);

            PGPDecryptBuilder builder = mock(PGPDecryptBuilder.class);
            when(builder.build()).thenReturn(mockDecrypt);
            builderMock.when(() -> new PGPDecryptBuilder(mockPrivateKeys)).thenReturn(builder);

            // Act
            PGPDecrypt result = pgpConfig.pgpDecrypt(resourceLoader);

            // Assert
            assertThat(result).isEqualTo(mockDecrypt);
            keysManagerMock.verify(() ->
                    KeysManagerUtils.loadPrivateKeysFromAsc(mockFile, pgpConfig.privateKeyCred));
            builderMock.verify(() -> new PGPDecryptBuilder(mockPrivateKeys));
            verify(builder).build();
        }
    }
}
```

---

## ‚úÖ **Key Points**

| Mock                                      | Purpose                                    |
| ----------------------------------------- | ------------------------------------------ |
| `ResourceLoader`, `Resource`              | Simulates Spring resource resolution       |
| `KeysManagerUtils`                        | Mocked statically (using `MockedStatic`)   |
| `PGPEncryptBuilder` / `PGPDecryptBuilder` | Mocked statically to isolate logic         |
| `assertThat(result)`                      | Confirms the correct object is returned    |
| `verify(...)`                             | Ensures the correct static calls were made |

---

## ‚úÖ **Expected Coverage**

| Method         | Lines covered | Result |
| -------------- | ------------- | ------ |
| `pgpEncrypt()` | Full coverage | ‚úÖ      |
| `pgpDecrypt()` | Full coverage | ‚úÖ      |

You‚Äôll also cover the log statements implicitly (no need to assert on logs).

---

Would you like me to add **negative tests** too (e.g., file not found ‚Üí exception thrown)?
That would bump coverage even higher and handle error branches.
