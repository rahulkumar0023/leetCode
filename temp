Nice—this is clean. On lines 45–51 you’ve got an empty `if/else` scaffold. You don’t need it at all because the resolver only returns the **bucket** (not the “reason”). Just collapse it to a single return:

```java
// replace lines 45–51 with this one-liner:
return (contractNumberMatch || knownSupplier) ? "miles" : "finance";
```

If someday you want to know *which* rule triggered (prefix vs supplier), return a small DTO/enum instead—but for bucket only, the one-liner is correct and removes dead code.

---

## JUnit 5 test for the whole class (InvoiceType + CreditNoteType)

Adjust package/imports to your UBL classes and service name (`supplierService.isKnownSupplier(...)`).

```java
package com.alphacredit.batch.service;

import oasis.names.specification.ubl.schema.xsd.commonaggregatecomponents_2.*;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.CompanyIDType;
import oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class InvoiceBucketResolverTest {

    @Mock SupplierService supplierService; // your real type here
    private InvoiceBucketResolver resolver;

    @BeforeEach
    void setUp() {
        resolver = new InvoiceBucketResolver(supplierService);
    }

    // ===== InvoiceType =====

    @Test
    void invoice_prefixMatch_returnsMiles() {
        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("12-ABC")); // matches prefix
        inv.setAccountingSupplierParty(asp(null));                 // no supplier id

        assertThat(resolver.resolveBucket(inv)).isEqualTo("miles");
        verifyNoInteractions(supplierService);
    }

    @Test
    void invoice_knownSupplier_returnsMiles() {
        when(supplierService.isKnownSupplier("BE0123")).thenReturn(true);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("77-NONE")); // no prefix
        inv.setAccountingSupplierParty(asp("BE0123"));

        assertThat(resolver.resolveBucket(inv)).isEqualTo("miles");
        verify(supplierService).isKnownSupplier("BE0123");
    }

    @Test
    void invoice_bothTrue_stillMiles() {
        when(supplierService.isKnownSupplier("BE0123")).thenReturn(true);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("14-OK")); // prefix hit
        inv.setAccountingSupplierParty(asp("BE0123"));           // supplier hit

        assertThat(resolver.resolveBucket(inv)).isEqualTo("miles");
        verify(supplierService).isKnownSupplier("BE0123");
    }

    @Test
    void invoice_noMatch_returnsFinance() {
        when(supplierService.isKnownSupplier("BE999")).thenReturn(false);

        InvoiceType inv = new InvoiceType();
        inv.getContractDocumentReference().add(docRef("90-NOPE"));
        inv.setAccountingSupplierParty(asp("BE999"));

        assertThat(resolver.resolveBucket(inv)).isEqualTo("finance");
        verify(supplierService).isKnownSupplier("BE999");
    }

    @Test
    void invoice_nullSafe_emptyData_returnsFinance() {
        InvoiceType inv = new InvoiceType(); // no refs, no party
        assertThat(resolver.resolveBucket(inv)).isEqualTo("finance");
        verifyNoInteractions(supplierService);
    }

    // ===== CreditNoteType =====

    @Test
    void creditNote_prefixMatch_returnsMiles() {
        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("19-HELLO"));
        cn.setAccountingSupplierParty(asp(null));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("miles");
        verifyNoInteractions(supplierService);
    }

    @Test
    void creditNote_knownSupplier_returnsMiles() {
        when(supplierService.isKnownSupplier("BE777")).thenReturn(true);

        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("88-NONE"));
        cn.setAccountingSupplierParty(asp("BE777"));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("miles");
        verify(supplierService).isKnownSupplier("BE777");
    }

    @Test
    void creditNote_noMatch_returnsFinance() {
        when(supplierService.isKnownSupplier("BE000")).thenReturn(false);

        CreditNoteType cn = new CreditNoteType();
        cn.getContractDocumentReference().add(docRef("33-NONE"));
        cn.setAccountingSupplierParty(asp("BE000"));

        assertThat(resolver.resolveBucket(cn)).isEqualTo("finance");
        verify(supplierService).isKnownSupplier("BE000");
    }

    // ===== Helpers =====

    private static DocumentReferenceType docRef(String idValue) {
        DocumentReferenceType dr = new DocumentReferenceType();
        IDType id = new IDType();
        id.setValue(idValue);
        dr.setID(id);
        return dr;
    }

    private static AccountingSupplierPartyType asp(String companyId) {
        AccountingSupplierPartyType asp = new AccountingSupplierPartyType();
        PartyType party = new PartyType();
        if (companyId != null) {
            PartyTaxSchemeType tax = new PartyTaxSchemeType();
            CompanyIDType cid = new CompanyIDType();
            cid.setValue(companyId);
            tax.setCompanyID(cid);
            party.getPartyTaxScheme().add(tax);
        }
        asp.setParty(party);
        return asp;
    }
}
```

### Notes

* Uses AssertJ for readable assertions; swap to JUnit’s `assertEquals` if you prefer.
* Covers both UBL types, null-safety, and “both rules true” case.
* If you don’t want to hit the repo on prefix hits, you already get that: we don’t short-circuit the boolean, but the test verifies interactions. If you want strict short-circuiting, you could structure the code to check prefix first and return early.
