Yes — and here are **all steps, end-to-end**, in the exact order you need to implement so:

✅ VAT 0 “exempt” subtotal is printed **once**
✅ Its **TaxableAmount = SUM(InvoiceLine_cbc_LineExtensionAmount)** only for VAT 0 rows
✅ VAT 21 subtotal is also printed **once** (your existing logic or same pattern)
✅ No duplicates, even if invoice lines are iterated multiple times

---

## Step 1 — Add a *group-level* sum method for VAT 0

Add to your `CsvInvoiceMapper`:

```java
default BigDecimal sumLineExtensionAmountForVatZero(CsvInvoiceGroup group) {

    BigDecimal sum = BigDecimal.ZERO;

    for (CsvInvoiceDto row : group.getRows()) {
        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat != null && vat.compareTo(BigDecimal.ZERO) == 0) {
            BigDecimal lineExt = toAmount(row.getInvoiceLineCbcLineExtensionAmount());
            if (lineExt != null) {
                sum = sum.add(lineExt);
            }
        }
    }

    return sum;
}
```

---

## Step 2 — Build ONE TaxSubtotal for VAT 0 using that sum

```java
default TaxSubtotalType buildVatZeroSubtotal(CsvInvoiceGroup group) {

    boolean hasVatZeroLine = false;
    for (CsvInvoiceDto row : group.getRows()) {
        BigDecimal vat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (vat != null && vat.compareTo(BigDecimal.ZERO) == 0) {
            hasVatZeroLine = true;
        }
    }

    if (!hasVatZeroLine) {
        return null;
    }

    BigDecimal taxableSum = sumLineExtensionAmountForVatZero(group);

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(BigDecimal.ZERO);
    taxSubtotal.setTaxAmount(taxAmount);

    // Reuse your existing logic: VAT 0 => E + exemption reason if applicable
    TaxCategoryType category =
            getTaxCategory(BigDecimal.ZERO, false, group.getRows().get(0).getItemCbcName());
    taxSubtotal.setTaxCategory(category);

    return taxSubtotal;
}
```

---

## Step 3 — Ensure VAT 21 subtotal is also built once (unchanged or similar)

If you already have a method like `buildTaxSubtotalForVat(group, 21)`, keep it.

Example:

```java
default TaxSubtotalType buildVat21Subtotal(CsvInvoiceGroup group) {
    return buildTaxSubtotalForVat(group, new BigDecimal("21"));
}
```

(If you want VAT 21 to ALSO sum `LineExtensionAmount`, say so and I’ll mirror VAT 0 logic for 21.)

---

## Step 4 — Build TaxTotal once per invoice (group)

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {

    TaxTotalType taxTotal = new TaxTotalType();

    TaxSubtotalType vat21 = buildVat21Subtotal(group);
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    TaxSubtotalType vat0 = buildVatZeroSubtotal(group);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

✅ This guarantees: at most **two** subtotals total (21 + 0).

---

## Step 5 — Mapping change: stop MapStruct from setting taxTotal per row

In your MapStruct mapping for:

`InvoiceType toInvoiceType(CsvInvoiceDto dto);`

Add:

```java
@Mapping(target = "taxTotal", ignore = true)
```

So MapStruct can’t accidentally call the per-row tax logic.

---

## Step 6 — Set TaxTotal only inside `toInvoiceTypeGroup(group)`

In your existing `toInvoiceTypeGroup`:

```java
default InvoiceType toInvoiceTypeGroup(CsvInvoiceGroup group) {

    CsvInvoiceDto first = group.getRows().get(0);
    InvoiceType invoice = toInvoiceType(first);

    invoice.getInvoiceLine().clear();
    for (CsvInvoiceDto row : group.getRows()) {
        invoice.getInvoiceLine().add(toInvoiceLine(row));
    }

    // ✅ set tax totals ONCE per invoice
    invoice.getTaxTotal().clear();
    invoice.getTaxTotal().addAll(toTaxTotal(group));

    return invoice;
}
```

---

## Step 7 — (Recommended) Add 3 unit tests

1. Invoice has many lines VAT 0 → **only 1 VAT-0 subtotal**, taxable amount = sum(LineExtensionAmount of VAT0 lines)

2. Invoice has many lines VAT 21 → **only 1 VAT-21 subtotal**

3. Invoice has both 21 + 0 → **2 subtotals only**

---

## ✅ Step coverage checklist (confirming everything)

* ✅ Summation rule (VAT 0 only) implemented
* ✅ Subtotal creation rule (VAT 0 printed once) implemented
* ✅ Mapping change to prevent duplicates (`taxTotal ignore`) included
* ✅ Correct place to set totals (group method) included
* ✅ Won’t break writer / batch logic
* ✅ Handles multiple invoice lines safely

---

If you paste the exact DTO getter names for:

* `InvoiceLine_cbc_LineExtensionAmount`
* VAT percentage field

…I’ll align the code 1:1 with your real class so you can copy/paste and compile immediately.
