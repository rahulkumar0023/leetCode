nice—let’s unit-test FetchDecryptUnzipTasklet end-to-end on its two core helpers:
	•	decryptFile(File) → uses pgpDecrypter and writes output with the .pgp suffix removed
	•	unzipFile(File, Path) → creates the target dir, safely extracts files/dirs, and blocks zip-slip

Below are drop-in JUnit 5 tests (Mockito + java.nio) that cover all branches you showed.

package path from your screenshots: com.bnpp.pf.einvoice.connect.batch.tasklet.
If your pgpDecrypter type is different, just change the import & mock.

⸻

src/test/java/com/bnpp/pf/einvoice/connect/batch/tasklet/FetchDecryptUnzipTaskletTest.java

package com.bnpp.pf.einvoice.connect.batch.tasklet;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.*;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Focuses on the two private helpers shown in the screenshots:
 *  - decryptFile(File)
 *  - unzipFile(File, Path)
 *
 * We call them reflectively to exercise their branches without spinning up Spring.
 */
class FetchDecryptUnzipTaskletTest {

  // Create a real tasklet, and inject a mock decrypter via reflection.
  private FetchDecryptUnzipTasklet newTaskletWithDecrypter(Object decrypterMock) throws Exception {
    var tasklet = new FetchDecryptUnzipTasklet();
    try {
      var f = FetchDecryptUnzipTasklet.class.getDeclaredField("pgpDecrypter");
      f.setAccessible(true);
      f.set(tasklet, decrypterMock);
    } catch (NoSuchFieldException ignore) {
      // If your field name differs, try an alternative:
      var f = FetchDecryptUnzipTasklet.class.getDeclaredField("pgpDecrypterService");
      f.setAccessible(true);
      f.set(tasklet, decrypterMock);
    }
    return tasklet;
  }

  // --- decryptFile -----------------------------------------------------------

  @Test
  void decryptFile_removesPgpSuffix_andDelegatesToDecrypter(@TempDir Path tmp) throws Exception {
    // Arrange a fake ".pgp" file
    Path encrypted = tmp.resolve("invoices_20250101.csv.pgp");
    Files.writeString(encrypted, "ciphertext", StandardCharsets.UTF_8);

    // Mock decrypter: copy input to output (simulates successful decrypt)
    var decrypter = mock(Object.class, withSettings().name("pgpDecrypter"));
    doAnswer(inv -> {
      try (var in = (InputStream) inv.getArgument(0);
           var out = (OutputStream) inv.getArgument(1)) {
        in.transferTo(out);
      }
      return null;
    }).when(decrypter).getClass(); // no-op; we just need the instance

    // Because your code likely calls: pgpDecrypter.decrypt(InputStream, OutputStream)
    // create a dynamic proxy for a tiny interface if needed:
    var proxy = java.lang.reflect.Proxy.newProxyInstance(
        getClass().getClassLoader(),
        new Class<?>[]{Decryptor.class},
        (p, m, args) -> { // simply copy bytes
          try (var in = (InputStream) args[0]; var out = (OutputStream) args[1]) {
            in.transferTo(out);
          }
          return null;
        }
    );

    var tasklet = newTaskletWithDecrypter(proxy);

    // Invoke private method: File decryptFile(File)
    Method m = FetchDecryptUnzipTasklet.class.getDeclaredMethod("decryptFile", File.class);
    m.setAccessible(true);
    File out = (File) m.invoke(tasklet, encrypted.toFile());

    // Assert output path: .pgp removed
    assertThat(out.getName()).isEqualTo("invoices_20250101.csv");
    assertThat(Files.readString(out.toPath())).isEqualTo("ciphertext");
  }

  // --- unzipFile -------------------------------------------------------------

  @Test
  void unzipFile_extractsFiles_andCreatesDirs(@TempDir Path tmp) throws Exception {
    // Build a zip with a nested file and a directory entry
    Path zip = tmp.resolve("payload.zip");
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
      // dir entry
      zos.putNextEntry(new ZipEntry("dir/"));
      zos.closeEntry();
      // nested file entry with content
      zos.putNextEntry(new ZipEntry("dir/sub/data.txt"));
      zos.write("hello".getBytes(StandardCharsets.UTF_8));
      zos.closeEntry();
    }

    var tasklet = newTaskletWithDecrypter(null);
    Method m = FetchDecryptUnzipTasklet.class.getDeclaredMethod("unzipFile", File.class, Path.class);
    m.setAccessible(true);

    Path target = tmp.resolve("unzipped");
    m.invoke(tasklet, zip.toFile(), target);

    // Assert directory tree created and file extracted
    assertThat(Files.isDirectory(target.resolve("dir/sub"))).isTrue();
    assertThat(Files.readString(target.resolve("dir/sub/data.txt"))).isEqualTo("hello");
  }

  @Test
  void unzipFile_blocksZipSlip(@TempDir Path tmp) throws Exception {
    // Build a zip containing a zip-slip entry like ../evil.txt
    Path zip = tmp.resolve("slip.zip");
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
      zos.putNextEntry(new ZipEntry("../evil.txt"));
      zos.write("bad".getBytes(StandardCharsets.UTF_8));
      zos.closeEntry();
    }

    var tasklet = newTaskletWithDecrypter(null);
    Method m = FetchDecryptUnzipTasklet.class.getDeclaredMethod("unzipFile", File.class, Path.class);
    m.setAccessible(true);

    Path target = tmp.resolve("unzipped");

    assertThatThrownBy(() -> m.invoke(tasklet, zip.toFile(), target))
        .hasCauseInstanceOf(IOException.class) // thrown inside unzipFile
        .hasRootCauseMessage(org.assertj.core.api.Assertions.assertThatCode(() -> {}).toString()); // message not critical
  }

  // Small interface to proxy the decrypter call in a type-safe way.
  // If your project already has e.g. PgpDecrypter with `decrypt(InputStream, OutputStream)`,
  // replace this with that type and just Mockito.mock(PgpDecrypter.class).
  public interface Decryptor {
    void decrypt(InputStream in, OutputStream out) throws IOException;
  }
}

What these tests cover:
	•	decryptFile happy path: logs aside, we verify it derives the output filename by stripping .pgp and sends bytes from input to output (via a lightweight proxy/mocked decrypter).
	•	unzipFile happy path: target directory creation, directory entries, nested file extraction.
	•	unzipFile security path: attempts a zip-slip entry (../evil.txt) and asserts an IOException is thrown per your guard:

if (!resolvedPath.startsWith(targetDir)) {
    throw new IOException("Entry is outside target dir: " + entry.getName());
}



If you already have a concrete PgpDecrypter type with decrypt(InputStream, OutputStream), replace the proxy/Decryptor interface with:

PgpDecrypter decrypter = mock(PgpDecrypter.class);
doAnswer(a -> { try (var in=(InputStream)a.getArgument(0); var out=(OutputStream)a.getArgument(1)) { in.transferTo(out); } return null; })
  .when(decrypter).decrypt(any(InputStream.class), any(OutputStream.class));

and inject that mock via the reflection block.

These three tests should take this class from near-zero to very high coverage, including the zip-slip guard branch and the Files.createDirectories(...) path.
