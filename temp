Got it ‚Äî this is a classic PEPPOL/UBL rule, and your understanding is 100% correct üëç
Let‚Äôs walk through it cleanly, step by step, and then I‚Äôll give you final code-style guidance you can drop into your mapper.

‚∏ª

Business rule (what must happen)

When AllowanceChargeIndicator = true in CSV:

1Ô∏è‚É£ InvoiceLine
	‚Ä¢	‚ùå DO NOT create an InvoiceLine
	‚Ä¢	‚ùå DO NOT include the amount in any line-level totals

2Ô∏è‚É£ LegalMonetaryTotal
	‚Ä¢	‚ùå DO NOT add amount to LineExtensionAmount
	‚Ä¢	‚úÖ ADD amount to AllowanceTotalAmount

3Ô∏è‚É£ Totals logic

Field	Should include allowance?
LineExtensionAmount	‚ùå No
AllowanceTotalAmount	‚úÖ Yes
TaxExclusiveAmount	Depends (usually Line ‚àí Allowance)
PayableAmount	Depends on your existing calculation

This aligns with PEPPOL BIS Billing 3.0.

‚∏ª

Where this logic belongs (important)

You must split logic in two places:
	1.	InvoiceLine creation
	2.	LegalMonetaryTotal aggregation

Do NOT try to ‚Äúfix‚Äù this only in totals ‚Äî that causes reconciliation errors.

‚∏ª

Step 1: Skip InvoiceLine when AllowanceChargeIndicator = true

CSV assumption

You have something like:

row.getAllowanceChargeIndicator()  // "true" / "false"

Mapper change (InvoiceLine)

default List<InvoiceLineType> toInvoiceLines(CsvInvoiceGroup group) {
    List<InvoiceLineType> lines = new ArrayList<>();

    for (CsvInvoiceDto row : group.getRows()) {

        if (Boolean.TRUE.equals(row.getAllowanceChargeIndicator())) {
            // Allowance ‚Üí NOT an invoice line
            continue;
        }

        InvoiceLineType line = buildInvoiceLine(row);
        lines.add(line);
    }

    return lines;
}

‚úÖ This guarantees:
	‚Ä¢	No allowance rows become invoice lines
	‚Ä¢	No accidental inclusion in line totals

‚∏ª

Step 2: Exclude allowance rows from LineExtensionAmount

Wherever you currently calculate LineExtensionAmount, change from:

‚ùå WRONG

sum += toAmount(row.getInvoiceLineCbcLineExtensionAmount());

‚úÖ CORRECT

if (!Boolean.TRUE.equals(row.getAllowanceChargeIndicator())) {
    sum = sum.add(toAmount(row.getInvoiceLineCbcLineExtensionAmount()));
}


‚∏ª

Step 3: Add Allowance rows to AllowanceTotalAmount

Calculation

private BigDecimal calculateAllowanceTotal(CsvInvoiceGroup group) {
    BigDecimal allowanceTotal = BigDecimal.ZERO;

    for (CsvInvoiceDto row : group.getRows()) {
        if (Boolean.TRUE.equals(row.getAllowanceChargeIndicator())) {
            allowanceTotal = allowanceTotal.add(
                toAmount(row.getInvoiceLineCbcLineExtensionAmount())
            );
        }
    }

    return allowanceTotal;
}


‚∏ª

Step 4: Map LegalMonetaryTotal correctly

default MonetaryTotalType toLegalMonetaryTotal(CsvInvoiceGroup group) {

    MonetaryTotalType total = new MonetaryTotalType();

    BigDecimal lineTotal = calculateLineExtensionAmount(group);
    BigDecimal allowanceTotal = calculateAllowanceTotal(group);

    // LineExtensionAmount (NO allowance rows)
    LineExtensionAmountType lineExt = new LineExtensionAmountType();
    lineExt.setCurrencyID("EUR");
    lineExt.setValue(lineTotal);
    total.setLineExtensionAmount(lineExt);

    // AllowanceTotalAmount
    if (allowanceTotal.compareTo(BigDecimal.ZERO) > 0) {
        AllowanceTotalAmountType allowanceAmt = new AllowanceTotalAmountType();
        allowanceAmt.setCurrencyID("EUR");
        allowanceAmt.setValue(allowanceTotal);
        total.setAllowanceTotalAmount(allowanceAmt);
    }

    return total;
}


‚∏ª

Resulting XML (correct PEPPOL output)

<cac:LegalMonetaryTotal>
  <cbc:LineExtensionAmount currencyID="EUR">100.00</cbc:LineExtensionAmount>
  <cbc:AllowanceTotalAmount currencyID="EUR">10.00</cbc:AllowanceTotalAmount>
</cac:LegalMonetaryTotal>

‚úî Allowance rows excluded from lines
‚úî Allowance correctly reflected in totals
‚úî PEPPOL compliant

‚∏ª

Common mistakes to avoid üö®

‚ùå Including allowance rows as InvoiceLine
‚ùå Adding allowance amounts into LineExtensionAmount
‚ùå Trying to ‚Äúsubtract later‚Äù instead of excluding early
‚ùå Mixing allowance logic into TaxSubtotal (wrong level)

‚∏ª

If you want next

I can:
	‚Ä¢	give you JUnit tests for this scenario
	‚Ä¢	verify TaxExclusiveAmount / PayableAmount logic
	‚Ä¢	show how this interacts with VAT 0 vs VAT 21
	‚Ä¢	or check credit note behavior (slightly different but related)

Just tell me üëç


xxxxxx====
Yep, let‚Äôs lock this in and give you ready-to-paste code.

I‚Äôll give you:
	1.	InvoiceBundle (new, Lombok)
	2.	Updated FetchDecryptUnzipTasklet (only changed parts, unzip logic kept)
	3.	Updated SkipLoggingListener (with bundle + read/process/write handling)
	4.	Step config snippet with the explicit casts to fix the ‚Äúlistener ambiguous‚Äù error

Adjust package names if they differ slightly in your project.

‚∏ª

1Ô∏è‚É£ InvoiceBundle.java (new)

package com.bnpp.pf.einvoice.connect.batch.model;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class InvoiceBundle {

    /**
     * Base name of the XML file (without .xml).
     * This must match what you store as "currentResourceBaseName"
     * in InvoiceBatchUtil.updateExecutionContext(Resource).
     */
    private final String baseName;

    /** COS key of the processed .zip.pgp file, e.g. processed/inv123.zip.pgp */
    private final String processedPgpKey;

    /** COS key of the processed .zip file, e.g. processed/inv123.zip */
    private final String processedZipKey;
}


‚∏ª

2Ô∏è‚É£ Updated FetchDecryptUnzipTasklet (only execute(‚Ä¶) + helper)

Keep your class, fields, extract/validate/getOutputPath exactly as you have them.
Replace your execute(...) with this version and add registerBundle(...) at the bottom of the class.

package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.storage.CosStorageService;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.springframework.batch.core.*;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

@Slf4j
public class FetchDecryptUnzipTasklet implements Tasklet, StepExecutionListener {

    // ... your existing fields: jobType, cosStorageService, pgpDecrypt, pathConfig, stepExecution ...

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }

    @Override
    @SuppressWarnings("unchecked")
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

        log.info("FetchDecryptUnzipTasklet started");

        try {
            // prepare bundle map in JOB execution context
            ExecutionContext jobCtx = stepExecution.getJobExecution().getExecutionContext();
            Map<String, InvoiceBundle> bundleMap =
                    (Map<String, InvoiceBundle>) jobCtx.get("invoiceBundles");
            if (bundleMap == null) {
                bundleMap = new HashMap<>();
                jobCtx.put("invoiceBundles", bundleMap);
            }

            List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
            if (encryptedFiles.isEmpty()) {
                log.info("No encrypted files found for jobType={}", jobType);
                return RepeatStatus.FINISHED;
            }

            for (File encrypted : encryptedFiles) {
                String encryptedName = encrypted.getName();
                log.info("Encrypted file name and job type: {} | {}", encryptedName, jobType);

                StringBuilder unzipBaseDir =
                        new StringBuilder(pathConfig.getUnzipped().getParent());

                try {
                    File decryptedZip;

                    if ("csv".equalsIgnoreCase(jobType) && encryptedName.contains("_csv")) {
                        stepExecution.getJobExecution().getExecutionContext()
                                     .put("hasCsv", Boolean.TRUE);
                        addProcessedKey(stepExecution, encryptedName);

                        decryptedZip = decryptFile(encrypted);
                        extract(decryptedZip.toPath(),
                                Paths.get(unzipBaseDir.append("/csv").toString()));

                        // CSV flow does not need bundle mapping

                    } else if ("xml".equalsIgnoreCase(jobType)
                            && encryptedName.toLowerCase().contains("_xml")) {

                        stepExecution.getJobExecution().getExecutionContext()
                                     .put("hasXml", Boolean.TRUE);
                        addProcessedKey(stepExecution, encryptedName);

                        decryptedZip = decryptFile(encrypted);
                        extract(decryptedZip.toPath(),
                                Paths.get(unzipBaseDir.append("/xml").toString()));

                        // XML flow: register mapping between XML base and COS keys
                        registerBundle(bundleMap, decryptedZip, encryptedName);

                    } else {
                        log.info("Job type and file type is NOT a match, skipping decrypt for {}",
                                 encryptedName);
                    }

                } catch (Exception bundleEx) {
                    log.error("Bundle failed for {} - moving to COS/failed. Error={}",
                              encryptedName, bundleEx.getMessage());

                    // 1) move .zip.pgp from processed -> failed
                    try {
                        String processedPgpKey = "processed/" + encryptedName;
                        String failedPgpKey    = "failed/"    + encryptedName;
                        cosStorageService.moveFile(processedPgpKey, failedPgpKey);
                    } catch (Exception ignore) {
                        log.warn("Failed to move encrypted file {} to failed", encryptedName);
                    }

                    // 2) upload decrypted .zip to failed (if exists locally)
                    try {
                        File zipFile = new File(encrypted.getParent(),
                                                encryptedName.replace(".pgp", ""));
                        if (zipFile.exists()) {
                            String failedZipKey = "failed/" + zipFile.getName();
                            cosStorageService.uploadFile(failedZipKey, zipFile);
                        }
                    } catch (Exception ignore) {
                        log.warn("Failed to upload decrypted zip for {} to failed", encryptedName);
                    }

                    // continue with next file; do NOT fail whole batch
                }
            }

        } catch (Exception e) {
            log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
            throw new InvoiceProcessingException(
                    "Error occurred while fetching encrypted files", e);
        }

        log.info("FetchDecryptUnzipTasklet completed");
        return RepeatStatus.FINISHED;
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ your decryptFile(), extract(), validateFile(), getOutputPath() stay unchanged ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private void registerBundle(Map<String, InvoiceBundle> bundleMap,
                                File decryptedZip,
                                String encryptedName) {
        try (ZipFile zip = ZipFile.builder()
                .setFile(decryptedZip)
                .setCharset(StandardCharsets.UTF_8)
                .get()) {

            Enumeration<ZipArchiveEntry> entries = zip.getEntries();
            while (entries.hasMoreElements()) {
                ZipArchiveEntry entry = entries.nextElement();
                if (entry.isDirectory()) {
                    continue;
                }

                String entryName = entry.getName();
                if (entryName == null || !entryName.toLowerCase().endsWith(".xml")) {
                    continue;
                }

                // xml base name without .xml
                String xmlFileName = Path.of(entryName).getFileName().toString();
                String base = xmlFileName.substring(0, xmlFileName.length() - 4);

                String processedPgpKey = "processed/" + encryptedName;
                String processedZipKey = "processed/" + encryptedName.replace(".pgp", "");

                InvoiceBundle bundle =
                        new InvoiceBundle(base, processedPgpKey, processedZipKey);
                bundleMap.put(base, bundle);

                log.info("Registered bundle: base={} pgpKey={} zipKey={}",
                         base, processedPgpKey, processedZipKey);
                return; // assume one XML per zip
            }

            log.warn("No XML entry found in zip {} - bundle not registered",
                     decryptedZip.getName());

        } catch (Exception e) {
            log.warn("Failed to register bundle for {}: {}", encryptedName, e.getMessage());
        }
    }
}


‚∏ª

3Ô∏è‚É£ Updated SkipLoggingListener.java

package com.bnpp.pf.einvoice.connect.batch.xml;

import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.storage.CosStorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.batch.core.step.skip.SkipListener;
import org.springframework.core.io.Resource;

import java.io.File;
import java.nio.file.Path;
import java.util.Collections;
import java.util.Map;

@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object>, StepExecutionListener {

    private final CosStorageService cosStorageService;

    private Map<String, InvoiceBundle> bundleMap = Collections.emptyMap();
    private StepExecution stepExecution;

    public SkipLoggingListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ StepExecutionListener ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    @Override
    @SuppressWarnings("unchecked")
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;

        Object mapObj = stepExecution.getJobExecution()
                                     .getExecutionContext()
                                     .get("invoiceBundles");

        if (mapObj instanceof Map) {
            this.bundleMap = (Map<String, InvoiceBundle>) mapObj;
        } else {
            this.bundleMap = Collections.emptyMap();
        }

        log.info("SkipLoggingListener loaded {} bundles from context", bundleMap.size());
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SkipListener ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    @Override
    public void onSkipInRead(Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        log.error("Skipped XML during read: {}", msg);

        if (stepExecution == null) {
            return;
        }

        // You already set this in InvoiceBatchUtil.updateExecutionContext(resource)
        String base = stepExecution.getExecutionContext()
                                   .getString("currentResourceBaseName", null);

        if (base == null) {
            log.warn("currentResourceBaseName not set; cannot move bundle on read skip");
            return;
        }

        handleSkipByBase("read", base, t);
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        String base = resolveBaseName(item);
        if (base == null) {
            String msg = (t != null) ? t.getMessage() : "unknown";
            log.error("Skipped XML during process but could not resolve base name: {}", msg);
            return;
        }
        handleSkipByBase("process", base, t);
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        String base = resolveBaseName(item);
        if (base == null) {
            String msg = (t != null) ? t.getMessage() : "unknown";
            log.error("Skipped XML during write but could not resolve base name: {}", msg);
            return;
        }
        handleSkipByBase("write", base, t);
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    private String resolveBaseName(Object item) {
        String name = null;

        if (item instanceof File f) {
            name = f.getName();
        } else if (item instanceof Path p) {
            name = p.getFileName().toString();
        } else if (item instanceof Resource r) {
            name = r.getFilename();
        }

        if (name == null) {
            return null;
        }

        String lower = name.toLowerCase();
        if (lower.endsWith(".xml")) {
            return name.substring(0, name.length() - 4); // strip .xml
        }
        return name;
    }

    private void handleSkipByBase(String phase, String base, Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        log.error("Skipped XML during {}: base={} - {}", phase, base, msg);

        InvoiceBundle bundle = bundleMap.get(base);
        if (bundle == null) {
            log.warn("No InvoiceBundle mapping found for base '{}'", base);
            return;
        }

        moveBundleToFailed(bundle);
    }

    private void moveBundleToFailed(InvoiceBundle bundle) {
        String processedPgpKey = bundle.getProcessedPgpKey();
        String processedZipKey = bundle.getProcessedZipKey();

        String failedPgpKey = processedPgpKey.replaceFirst("^processed/", "failed/");
        String failedZipKey  = processedZipKey.replaceFirst("^processed/", "failed/");

        try {
            cosStorageService.moveFile(processedPgpKey, failedPgpKey);
            log.info("Moved {} -> {}", processedPgpKey, failedPgpKey);
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedPgpKey, failedPgpKey, e.getMessage());
        }

        try {
            cosStorageService.moveFile(processedZipKey, failedZipKey);
            log.info("Moved {} -> {}", processedZipKey, failedZipKey);
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedZipKey, failedZipKey, e.getMessage());
        }
    }
}


‚∏ª

4Ô∏è‚É£ Step config: register listener with explicit casts

In your InvoiceBatchConfiguration (or similar), define the bean:

@Bean
public SkipLoggingListener skipLoggingListener(CosStorageService cosStorageService) {
    return new SkipLoggingListener(cosStorageService);
}

And in the XML step:

@Bean
public Step xmlInvoiceStep(StepBuilderFactory stepBuilderFactory,
                           UblXmlReader ublXmlReader,
                           ItemProcessor<Object, Object> xmlProcessor,
                           ItemWriter<Object> xmlWriter,
                           SkipLoggingListener skipLoggingListener) {

    return stepBuilderFactory.get("xmlInvoiceStep")
            .<Object, Object>chunk(10)
            .reader(ublXmlReader)
            .processor(xmlProcessor)
            .writer(xmlWriter)
            .faultTolerant()
            .skip(Exception.class)
            .skipLimit(Integer.MAX_VALUE)
            // avoid ambiguity: register under both interfaces explicitly
            .listener((SkipListener<Object, Object>) skipLoggingListener)
            .listener((StepExecutionListener) skipLoggingListener)
            .build();
}


‚∏ª

With these three pieces:
	‚Ä¢	decrypt/unzip failures ‚Üí .zip.pgp + .zip moved to failed/ in the tasklet
	‚Ä¢	XML read/process/write failures ‚Üí same bundle moved to failed/ via SkipLoggingListener
	‚Ä¢	good files behave as before

If you now hit any specific compile error, paste the message and I‚Äôll tweak that exact line.


-/-/‚Äî‚Äî
Got it ‚Äî with the **new rule** (`..._01.xml` and attachments `..._02.pdf`, etc.) you must **derive the ‚Äúbundle base‚Äù by removing the trailing `_<digits>` from the XML filename** (and also still support legacy `A.xml` + `A.pdf`).

Below is the **final updated class** (full code) and an **updated JUnit** that covers:

* new format: `A1_B123_multiplethings_01.xml` + `_02/_03/_999` attachments
* legacy: `A.xml` + `A.pdf`
* ‚Äúdon‚Äôt move any `.xml`‚Äù
* invalid inputs, missing source dir, deterministic IOException path, non-regular files
* uniqueIfExists branch

---

## SplitAttachmentMover.java (final)

```java
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

@Slf4j
@Component
@RequiredArgsConstructor
public class SplitAttachmentMover {

    private static final Pattern TRAILING_SEQ = Pattern.compile("(?i)_[0-9]+$");

    private final PathConfig pathConfig;

    /**
     * @param xmlBaseName can be:
     *  - legacy: "A" or "A.xml"
     *  - new:    "A1_B123_multiplethings_01" or "A1_B123_multiplethings_01.xml"
     * Attachment base will be derived by stripping extension and removing trailing _<digits>.
     */
    public List<Path> moveAttachments(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        if (shouldSkip(xmlBaseName, outputXmlFileName, targetDir)) {
            return List.of();
        }

        Path sourceDir = getSourceDir();
        if (!isValidSourceDir(sourceDir)) {
            return List.of();
        }

        String normalizedBase = normalizeAttachmentBase(xmlBaseName);
        if (normalizedBase == null || normalizedBase.isBlank()) {
            log.warn("Normalized attachment base is blank for xmlBaseName='{}'. Skipping attachment move.", xmlBaseName);
            return List.of();
        }

        String targetBase = stripExtension(Paths.get(outputXmlFileName).getFileName().toString());

        try {
            Files.createDirectories(targetDir);
            List<Path> moved = copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase);
            logResult(normalizedBase, moved);
            return moved;
        } catch (IOException ex) {
            log.error("Failed moving attachments for base '{}': {}", xmlBaseName, ex.getMessage(), ex);
            return List.of();
        }
    }

    private Path getSourceDir() {
        return pathConfig.getUnzipped().getXml();
    }

    private List<Path> copyMatchingAttachments(Path sourceDir,
                                               Path targetDir,
                                               String normalizedBase,
                                               String targetBase) throws IOException {

        List<Path> moved = new ArrayList<>();

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
            for (Path p : stream) {
                if (Files.isRegularFile(p)) {
                    String fileName = p.getFileName().toString();
                    if (isAttachmentForBase(fileName, normalizedBase)) {
                        Path copied = copySingleAttachment(p, fileName, normalizedBase, targetDir, targetBase);
                        moved.add(copied);
                    }
                }
            }
        }

        return moved;
    }

    /**
     * Matches:
     *  - New:    base_02.pdf, base_03.csv, base_999.jpeg ...
     *  - Legacy: base.pdf, base.jpeg, base.csv ...
     *  - Older legacy: base-2.pdf (optional support)
     *
     * Excludes:
     *  - any *.xml
     */
    private boolean isAttachmentForBase(String fileName, String normalizedBase) {
        if (fileName == null || fileName.isBlank() || normalizedBase == null || normalizedBase.isBlank()) {
            return false;
        }

        String lower = fileName.toLowerCase(Locale.ROOT);
        String base = normalizedBase.toLowerCase(Locale.ROOT);

        // never move xml files as attachments (covers base.xml and base_01.xml, etc.)
        if (lower.endsWith(".xml")) {
            return false;
        }

        // new: base_<digits>.<ext>
        if (lower.startsWith(base + "_")) {
            int i = base.length() + 1;
            if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
                return false;
            }
            while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
                i++;
            }
            return i < lower.length() && lower.charAt(i) == '.';
        }

        // legacy: base.<ext>
        if (lower.startsWith(base + ".")) {
            return true;
        }

        // older legacy: base-<digits>.<ext>
        if (lower.startsWith(base + "-")) {
            int i = base.length() + 1;
            if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
                return false;
            }
            while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
                i++;
            }
            return i < lower.length() && lower.charAt(i) == '.';
        }

        return false;
    }

    private Path copySingleAttachment(Path source,
                                      String fileName,
                                      String normalizedBase,
                                      Path targetDir,
                                      String targetBase) throws IOException {

        // We compute suffix from the ORIGINAL fileName using the original base length.
        // Works even if fileName has different casing. We just need matching length.
        int baseLen = normalizedBase.length();
        if (fileName.length() < baseLen) {
            return uniqueIfExists(targetDir.resolve(targetBase + "-" + fileName));
        }

        String suffix = fileName.substring(baseLen); // ".pdf" OR "_02.pdf" OR "-2.pdf" OR ".CSV"
        Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
        Files.copy(source, dest, StandardCopyOption.COPY_ATTRIBUTES);

        return dest;
    }

    private void logResult(String normalizedBase, List<Path> moved) {
        if (moved.isEmpty()) {
            log.debug("No attachments found for base '{}'", normalizedBase);
        } else {
            log.info("Moved {} attachment(s) for base '{}'", moved.size(), normalizedBase);
        }
    }

    private boolean shouldSkip(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        if (xmlBaseName == null || xmlBaseName.isBlank()) {
            log.warn("XML base name is blank. Skipping attachment move.");
            return true;
        }
        if (outputXmlFileName == null || outputXmlFileName.isBlank()) {
            log.warn("Output XML file name is blank. Skipping attachment move.");
            return true;
        }
        if (targetDir == null) {
            log.warn("Target directory is null. Skipping attachment move.");
            return true;
        }
        return false;
    }

    private boolean isValidSourceDir(Path sourceDir) {
        if (sourceDir == null || !Files.isDirectory(sourceDir)) {
            log.warn("Source directory is missing. Skipping attachment move.");
            return false;
        }
        return true;
    }

    /**
     * IMPORTANT:
     * - Strips extension
     * - Removes trailing _<digits> (new scheme where XML ends with _01)
     * Examples:
     *  - "X_01.xml" -> "x"
     *  - "A1_B123_multiplethings_01" -> "a1_b123_multiplethings"
     *  - "A.xml" -> "a"  (no change besides normalize)
     */
    private static String normalizeAttachmentBase(String xmlBaseNameOrFileName) {
        if (xmlBaseNameOrFileName == null) {
            return null;
        }
        String raw = Paths.get(xmlBaseNameOrFileName).getFileName().toString();
        String noExt = stripExtension(raw).trim();
        String noSeq = TRAILING_SEQ.matcher(noExt).replaceFirst("");
        return normalize(noSeq);
    }

    private static String stripExtension(String fileName) {
        int dot = fileName.lastIndexOf('.');
        return dot > 0 ? fileName.substring(0, dot) : fileName;
    }

    private static String normalize(String s) {
        return s == null ? null : s.toLowerCase(Locale.ROOT).trim();
    }

    private static Path uniqueIfExists(Path dest) {
        if (!Files.exists(dest)) {
            return dest;
        }

        String name = dest.getFileName().toString();
        String base = stripExtension(name);
        String ext = "";

        int dot = name.lastIndexOf('.');
        if (dot > 0) {
            ext = name.substring(dot);
        }

        Path dir = dest.getParent();
        int i = 2;
        Path candidate = dir.resolve(base + "-" + i + ext);
        while (Files.exists(candidate)) {
            i++;
            candidate = dir.resolve(base + "-" + i + ext);
        }
        return candidate;
    }
}
```

---

## SplitAttachmentMoverTest.java (final)

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    private Path sourceDir;
    private Path targetDir;

    private PathConfig pathConfig;
    private SplitAttachmentMover mover;

    @BeforeEach
    void setup() throws IOException {
        sourceDir = Files.createDirectory(tempDir.resolve("unzippedXml"));
        targetDir = Files.createDirectory(tempDir.resolve("out"));

        pathConfig = Mockito.mock(PathConfig.class);
        PathConfig.Unzipped unzipped = Mockito.mock(PathConfig.Unzipped.class);

        Mockito.when(pathConfig.getUnzipped()).thenReturn(unzipped);
        Mockito.when(unzipped.getXml()).thenReturn(sourceDir);

        mover = new SplitAttachmentMover(pathConfig);
    }

    @Test
    void moveAttachments_newXmlSuffix_baseDerivedAndCopiesAllMatching() throws Exception {
        write(sourceDir, "A1_B123_multiplethings_01.xml", "<xml/>");
        write(sourceDir, "A1_B123_multiplethings_02.pdf", "pdf2");
        write(sourceDir, "A1_B123_multiplethings_03.pdf", "pdf3");
        write(sourceDir, "A1_B123_multiplethings_04.csv", "csv4");
        write(sourceDir, "A1_B123_multiplethings_999.jpeg", "img");
        write(sourceDir, "OTHER_02.pdf", "nope");

        List<Path> moved = mover.moveAttachments(
                "A1_B123_multiplethings_01.xml",
                "NEWNAME_INV_123.xml",
                targetDir
        );

        assertEquals(4, moved.size());
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_02.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_03.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_04.csv")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_999.jpeg")));

        // xml should never be moved
        assertFalse(Files.exists(targetDir.resolve("NEWNAME_INV_123_01.xml")));
    }

    @Test
    void moveAttachments_legacyXmlAndLegacySinglePdf_isCopied() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT.pdf")));
    }

    @Test
    void moveAttachments_doesNotMoveAnyXmlEvenIfMatchesBase() throws Exception {
        write(sourceDir, "X_01.xml", "<xml/>");
        write(sourceDir, "X_02.xml", "<xml/>"); // should NOT be moved
        write(sourceDir, "X_02.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("X_01.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_02.pdf")));
        assertFalse(Files.exists(targetDir.resolve("OUT_02.xml")));
    }

    @Test
    void moveAttachments_ignoresNonRegularFiles() throws Exception {
        write(sourceDir, "A_01.xml", "<xml/>");
        Files.createDirectory(sourceDir.resolve("A_02.pdf")); // directory, not a file

        List<Path> moved = mover.moveAttachments("A_01.xml", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_createsUniqueNameIfTargetExists() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        // pre-create destination so uniqueIfExists triggers
        write(targetDir, "OUT.pdf", "existing");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-2.pdf")));
    }

    @Test
    void moveAttachments_returnsEmptyList_whenNoAttachmentsPresent() throws Exception {
        write(sourceDir, "A_01.xml", "<xml/>");

        List<Path> moved = mover.moveAttachments("A_01.xml", "OUT.xml", targetDir);

        assertNotNull(moved);
        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenInputsInvalid() {
        assertTrue(mover.moveAttachments(" ", "OUT.xml", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", " ", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "OUT.xml", null).isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenSourceDirMissing() throws Exception {
        // point sourceDir to a file (not directory)
        Path fileInsteadOfDir = write(tempDir, "notADir.txt", "x");
        PathConfig.Unzipped unzipped = pathConfig.getUnzipped();
        Mockito.when(unzipped.getXml()).thenReturn(fileInsteadOfDir);

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_handlesIOException_andDoesNotThrow() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        // deterministic IOException: pass a file path as targetDir so createDirectories/copy fails
        Path targetIsFile = write(tempDir, "targetFile", "x");

        assertDoesNotThrow(() -> {
            List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetIsFile);
            assertTrue(moved.isEmpty());
        });
    }

    @Test
    void moveAttachments_supportsOlderLegacyDashPattern() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-2.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-2.pdf")));
    }

    private static Path write(Path dir, String name, String content) throws IOException {
        Path p = dir.resolve(name);
        Files.writeString(p, content);
        return p;
    }
}
```

---

### What this fixes for your reported issue

* **Legacy** `A.xml + A.pdf` no longer gets skipped (it matches `base.<ext>` and we don‚Äôt require `_nn`).
* **New** `A1_B123_multiplethings_01.xml` correctly derives base `A1_B123_multiplethings` and moves `_02/_03/_999` attachments.
* **Never moves XML** as attachment (so you don‚Äôt accidentally copy `X_02.xml`).

If you want, paste your current **attachment mover integration point** (the place you call `moveAttachments`) and I‚Äôll point out why the PDF ‚Äúdisappeared‚Äù after the refactor (usually it‚Äôs either: wrong sourceDir path, wrong xmlBaseName passed, or you moved PDFs earlier than renaming logic and then the registry lookup can‚Äôt find them).





))---------
Got it ‚Äî with the new rule (..._01.xml and attachments ..._02.pdf, etc.) you must derive the ‚Äúbundle base‚Äù by removing the trailing _<digits> from the XML filename (and also still support legacy A.xml + A.pdf).

Below is the final updated class (full code) and an updated JUnit that covers:
	‚Ä¢	new format: A1_B123_multiplethings_01.xml + _02/_03/_999 attachments
	‚Ä¢	legacy: A.xml + A.pdf
	‚Ä¢	‚Äúdon‚Äôt move any .xml‚Äù
	‚Ä¢	invalid inputs, missing source dir, deterministic IOException path, non-regular files
	‚Ä¢	uniqueIfExists branch

‚∏ª

SplitAttachmentMover.java (final)

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

@Slf4j
@Component
@RequiredArgsConstructor
public class SplitAttachmentMover {

    private static final Pattern TRAILING_SEQ = Pattern.compile("(?i)_[0-9]+$");

    private final PathConfig pathConfig;

    /**
     * @param xmlBaseName can be:
     *  - legacy: "A" or "A.xml"
     *  - new:    "A1_B123_multiplethings_01" or "A1_B123_multiplethings_01.xml"
     * Attachment base will be derived by stripping extension and removing trailing _<digits>.
     */
    public List<Path> moveAttachments(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        if (shouldSkip(xmlBaseName, outputXmlFileName, targetDir)) {
            return List.of();
        }

        Path sourceDir = getSourceDir();
        if (!isValidSourceDir(sourceDir)) {
            return List.of();
        }

        String normalizedBase = normalizeAttachmentBase(xmlBaseName);
        if (normalizedBase == null || normalizedBase.isBlank()) {
            log.warn("Normalized attachment base is blank for xmlBaseName='{}'. Skipping attachment move.", xmlBaseName);
            return List.of();
        }

        String targetBase = stripExtension(Paths.get(outputXmlFileName).getFileName().toString());

        try {
            Files.createDirectories(targetDir);
            List<Path> moved = copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase);
            logResult(normalizedBase, moved);
            return moved;
        } catch (IOException ex) {
            log.error("Failed moving attachments for base '{}': {}", xmlBaseName, ex.getMessage(), ex);
            return List.of();
        }
    }

    private Path getSourceDir() {
        return pathConfig.getUnzipped().getXml();
    }

    private List<Path> copyMatchingAttachments(Path sourceDir,
                                               Path targetDir,
                                               String normalizedBase,
                                               String targetBase) throws IOException {

        List<Path> moved = new ArrayList<>();

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
            for (Path p : stream) {
                if (Files.isRegularFile(p)) {
                    String fileName = p.getFileName().toString();
                    if (isAttachmentForBase(fileName, normalizedBase)) {
                        Path copied = copySingleAttachment(p, fileName, normalizedBase, targetDir, targetBase);
                        moved.add(copied);
                    }
                }
            }
        }

        return moved;
    }

    /**
     * Matches:
     *  - New:    base_02.pdf, base_03.csv, base_999.jpeg ...
     *  - Legacy: base.pdf, base.jpeg, base.csv ...
     *  - Older legacy: base-2.pdf (optional support)
     *
     * Excludes:
     *  - any *.xml
     */
    private boolean isAttachmentForBase(String fileName, String normalizedBase) {
        if (fileName == null || fileName.isBlank() || normalizedBase == null || normalizedBase.isBlank()) {
            return false;
        }

        String lower = fileName.toLowerCase(Locale.ROOT);
        String base = normalizedBase.toLowerCase(Locale.ROOT);

        // never move xml files as attachments (covers base.xml and base_01.xml, etc.)
        if (lower.endsWith(".xml")) {
            return false;
        }

        // new: base_<digits>.<ext>
        if (lower.startsWith(base + "_")) {
            int i = base.length() + 1;
            if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
                return false;
            }
            while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
                i++;
            }
            return i < lower.length() && lower.charAt(i) == '.';
        }

        // legacy: base.<ext>
        if (lower.startsWith(base + ".")) {
            return true;
        }

        // older legacy: base-<digits>.<ext>
        if (lower.startsWith(base + "-")) {
            int i = base.length() + 1;
            if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
                return false;
            }
            while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
                i++;
            }
            return i < lower.length() && lower.charAt(i) == '.';
        }

        return false;
    }

    private Path copySingleAttachment(Path source,
                                      String fileName,
                                      String normalizedBase,
                                      Path targetDir,
                                      String targetBase) throws IOException {

        // We compute suffix from the ORIGINAL fileName using the original base length.
        // Works even if fileName has different casing. We just need matching length.
        int baseLen = normalizedBase.length();
        if (fileName.length() < baseLen) {
            return uniqueIfExists(targetDir.resolve(targetBase + "-" + fileName));
        }

        String suffix = fileName.substring(baseLen); // ".pdf" OR "_02.pdf" OR "-2.pdf" OR ".CSV"
        Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
        Files.copy(source, dest, StandardCopyOption.COPY_ATTRIBUTES);

        return dest;
    }

    private void logResult(String normalizedBase, List<Path> moved) {
        if (moved.isEmpty()) {
            log.debug("No attachments found for base '{}'", normalizedBase);
        } else {
            log.info("Moved {} attachment(s) for base '{}'", moved.size(), normalizedBase);
        }
    }

    private boolean shouldSkip(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        if (xmlBaseName == null || xmlBaseName.isBlank()) {
            log.warn("XML base name is blank. Skipping attachment move.");
            return true;
        }
        if (outputXmlFileName == null || outputXmlFileName.isBlank()) {
            log.warn("Output XML file name is blank. Skipping attachment move.");
            return true;
        }
        if (targetDir == null) {
            log.warn("Target directory is null. Skipping attachment move.");
            return true;
        }
        return false;
    }

    private boolean isValidSourceDir(Path sourceDir) {
        if (sourceDir == null || !Files.isDirectory(sourceDir)) {
            log.warn("Source directory is missing. Skipping attachment move.");
            return false;
        }
        return true;
    }

    /**
     * IMPORTANT:
     * - Strips extension
     * - Removes trailing _<digits> (new scheme where XML ends with _01)
     * Examples:
     *  - "X_01.xml" -> "x"
     *  - "A1_B123_multiplethings_01" -> "a1_b123_multiplethings"
     *  - "A.xml" -> "a"  (no change besides normalize)
     */
    private static String normalizeAttachmentBase(String xmlBaseNameOrFileName) {
        if (xmlBaseNameOrFileName == null) {
            return null;
        }
        String raw = Paths.get(xmlBaseNameOrFileName).getFileName().toString();
        String noExt = stripExtension(raw).trim();
        String noSeq = TRAILING_SEQ.matcher(noExt).replaceFirst("");
        return normalize(noSeq);
    }

    private static String stripExtension(String fileName) {
        int dot = fileName.lastIndexOf('.');
        return dot > 0 ? fileName.substring(0, dot) : fileName;
    }

    private static String normalize(String s) {
        return s == null ? null : s.toLowerCase(Locale.ROOT).trim();
    }

    private static Path uniqueIfExists(Path dest) {
        if (!Files.exists(dest)) {
            return dest;
        }

        String name = dest.getFileName().toString();
        String base = stripExtension(name);
        String ext = "";

        int dot = name.lastIndexOf('.');
        if (dot > 0) {
            ext = name.substring(dot);
        }

        Path dir = dest.getParent();
        int i = 2;
        Path candidate = dir.resolve(base + "-" + i + ext);
        while (Files.exists(candidate)) {
            i++;
            candidate = dir.resolve(base + "-" + i + ext);
        }
        return candidate;
    }
}


‚∏ª

SplitAttachmentMoverTest.java (final)

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    private Path sourceDir;
    private Path targetDir;

    private PathConfig pathConfig;
    private SplitAttachmentMover mover;

    @BeforeEach
    void setup() throws IOException {
        sourceDir = Files.createDirectory(tempDir.resolve("unzippedXml"));
        targetDir = Files.createDirectory(tempDir.resolve("out"));

        pathConfig = Mockito.mock(PathConfig.class);
        PathConfig.Unzipped unzipped = Mockito.mock(PathConfig.Unzipped.class);

        Mockito.when(pathConfig.getUnzipped()).thenReturn(unzipped);
        Mockito.when(unzipped.getXml()).thenReturn(sourceDir);

        mover = new SplitAttachmentMover(pathConfig);
    }

    @Test
    void moveAttachments_newXmlSuffix_baseDerivedAndCopiesAllMatching() throws Exception {
        write(sourceDir, "A1_B123_multiplethings_01.xml", "<xml/>");
        write(sourceDir, "A1_B123_multiplethings_02.pdf", "pdf2");
        write(sourceDir, "A1_B123_multiplethings_03.pdf", "pdf3");
        write(sourceDir, "A1_B123_multiplethings_04.csv", "csv4");
        write(sourceDir, "A1_B123_multiplethings_999.jpeg", "img");
        write(sourceDir, "OTHER_02.pdf", "nope");

        List<Path> moved = mover.moveAttachments(
                "A1_B123_multiplethings_01.xml",
                "NEWNAME_INV_123.xml",
                targetDir
        );

        assertEquals(4, moved.size());
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_02.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_03.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_04.csv")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_999.jpeg")));

        // xml should never be moved
        assertFalse(Files.exists(targetDir.resolve("NEWNAME_INV_123_01.xml")));
    }

    @Test
    void moveAttachments_legacyXmlAndLegacySinglePdf_isCopied() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT.pdf")));
    }

    @Test
    void moveAttachments_doesNotMoveAnyXmlEvenIfMatchesBase() throws Exception {
        write(sourceDir, "X_01.xml", "<xml/>");
        write(sourceDir, "X_02.xml", "<xml/>"); // should NOT be moved
        write(sourceDir, "X_02.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("X_01.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_02.pdf")));
        assertFalse(Files.exists(targetDir.resolve("OUT_02.xml")));
    }

    @Test
    void moveAttachments_ignoresNonRegularFiles() throws Exception {
        write(sourceDir, "A_01.xml", "<xml/>");
        Files.createDirectory(sourceDir.resolve("A_02.pdf")); // directory, not a file

        List<Path> moved = mover.moveAttachments("A_01.xml", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_createsUniqueNameIfTargetExists() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        // pre-create destination so uniqueIfExists triggers
        write(targetDir, "OUT.pdf", "existing");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-2.pdf")));
    }

    @Test
    void moveAttachments_returnsEmptyList_whenNoAttachmentsPresent() throws Exception {
        write(sourceDir, "A_01.xml", "<xml/>");

        List<Path> moved = mover.moveAttachments("A_01.xml", "OUT.xml", targetDir);

        assertNotNull(moved);
        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenInputsInvalid() {
        assertTrue(mover.moveAttachments(" ", "OUT.xml", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", " ", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "OUT.xml", null).isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenSourceDirMissing() throws Exception {
        // point sourceDir to a file (not directory)
        Path fileInsteadOfDir = write(tempDir, "notADir.txt", "x");
        PathConfig.Unzipped unzipped = pathConfig.getUnzipped();
        Mockito.when(unzipped.getXml()).thenReturn(fileInsteadOfDir);

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_handlesIOException_andDoesNotThrow() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        // deterministic IOException: pass a file path as targetDir so createDirectories/copy fails
        Path targetIsFile = write(tempDir, "targetFile", "x");

        assertDoesNotThrow(() -> {
            List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetIsFile);
            assertTrue(moved.isEmpty());
        });
    }

    @Test
    void moveAttachments_supportsOlderLegacyDashPattern() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-2.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-2.pdf")));
    }

    private static Path write(Path dir, String name, String content) throws IOException {
        Path p = dir.resolve(name);
        Files.writeString(p, content);
        return p;
    }
}


‚∏ª

What this fixes for your reported issue
	‚Ä¢	Legacy A.xml + A.pdf no longer gets skipped (it matches base.<ext> and we don‚Äôt require _nn).
	‚Ä¢	New A1_B123_multiplethings_01.xml correctly derives base A1_B123_multiplethings and moves _02/_03/_999 attachments.
	‚Ä¢	Never moves XML as attachment (so you don‚Äôt accidentally copy X_02.xml).

If you want, paste your current attachment mover integration point (the place you call moveAttachments) and I‚Äôll point out why the PDF ‚Äúdisappeared‚Äù after the refactor (usually it‚Äôs either: wrong sourceDir path, wrong xmlBaseName passed, or you moved PDFs earlier than renaming logic and then the registry lookup can‚Äôt find them).

‚Äî-
Got it ‚Äî with the new rule (..._01.xml and attachments ..._02.pdf, etc.) you must derive the ‚Äúbundle base‚Äù by removing the trailing _<digits> from the XML filename (and also still support legacy A.xml + A.pdf).

Below is the final updated class (full code) and an updated JUnit that covers:
	‚Ä¢	new format: A1_B123_multiplethings_01.xml + _02/_03/_999 attachments
	‚Ä¢	legacy: A.xml + A.pdf
	‚Ä¢	‚Äúdon‚Äôt move any .xml‚Äù
	‚Ä¢	invalid inputs, missing source dir, deterministic IOException path, non-regular files
	‚Ä¢	uniqueIfExists branch

‚∏ª

SplitAttachmentMover.java (final)

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

@Slf4j
@Component
@RequiredArgsConstructor
public class SplitAttachmentMover {

    private static final Pattern TRAILING_SEQ = Pattern.compile("(?i)_[0-9]+$");

    private final PathConfig pathConfig;

    /**
     * @param xmlBaseName can be:
     *  - legacy: "A" or "A.xml"
     *  - new:    "A1_B123_multiplethings_01" or "A1_B123_multiplethings_01.xml"
     * Attachment base will be derived by stripping extension and removing trailing _<digits>.
     */
    public List<Path> moveAttachments(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        if (shouldSkip(xmlBaseName, outputXmlFileName, targetDir)) {
            return List.of();
        }

        Path sourceDir = getSourceDir();
        if (!isValidSourceDir(sourceDir)) {
            return List.of();
        }

        String normalizedBase = normalizeAttachmentBase(xmlBaseName);
        if (normalizedBase == null || normalizedBase.isBlank()) {
            log.warn("Normalized attachment base is blank for xmlBaseName='{}'. Skipping attachment move.", xmlBaseName);
            return List.of();
        }

        String targetBase = stripExtension(Paths.get(outputXmlFileName).getFileName().toString());

        try {
            Files.createDirectories(targetDir);
            List<Path> moved = copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase);
            logResult(normalizedBase, moved);
            return moved;
        } catch (IOException ex) {
            log.error("Failed moving attachments for base '{}': {}", xmlBaseName, ex.getMessage(), ex);
            return List.of();
        }
    }

    private Path getSourceDir() {
        return pathConfig.getUnzipped().getXml();
    }

    private List<Path> copyMatchingAttachments(Path sourceDir,
                                               Path targetDir,
                                               String normalizedBase,
                                               String targetBase) throws IOException {

        List<Path> moved = new ArrayList<>();

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
            for (Path p : stream) {
                if (Files.isRegularFile(p)) {
                    String fileName = p.getFileName().toString();
                    if (isAttachmentForBase(fileName, normalizedBase)) {
                        Path copied = copySingleAttachment(p, fileName, normalizedBase, targetDir, targetBase);
                        moved.add(copied);
                    }
                }
            }
        }

        return moved;
    }

    /**
     * Matches:
     *  - New:    base_02.pdf, base_03.csv, base_999.jpeg ...
     *  - Legacy: base.pdf, base.jpeg, base.csv ...
     *  - Older legacy: base-2.pdf (optional support)
     *
     * Excludes:
     *  - any *.xml
     */
    private boolean isAttachmentForBase(String fileName, String normalizedBase) {
        if (fileName == null || fileName.isBlank() || normalizedBase == null || normalizedBase.isBlank()) {
            return false;
        }

        String lower = fileName.toLowerCase(Locale.ROOT);
        String base = normalizedBase.toLowerCase(Locale.ROOT);

        // never move xml files as attachments (covers base.xml and base_01.xml, etc.)
        if (lower.endsWith(".xml")) {
            return false;
        }

        // new: base_<digits>.<ext>
        if (lower.startsWith(base + "_")) {
            int i = base.length() + 1;
            if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
                return false;
            }
            while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
                i++;
            }
            return i < lower.length() && lower.charAt(i) == '.';
        }

        // legacy: base.<ext>
        if (lower.startsWith(base + ".")) {
            return true;
        }

        // older legacy: base-<digits>.<ext>
        if (lower.startsWith(base + "-")) {
            int i = base.length() + 1;
            if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
                return false;
            }
            while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
                i++;
            }
            return i < lower.length() && lower.charAt(i) == '.';
        }

        return false;
    }

    private Path copySingleAttachment(Path source,
                                      String fileName,
                                      String normalizedBase,
                                      Path targetDir,
                                      String targetBase) throws IOException {

        // We compute suffix from the ORIGINAL fileName using the original base length.
        // Works even if fileName has different casing. We just need matching length.
        int baseLen = normalizedBase.length();
        if (fileName.length() < baseLen) {
            return uniqueIfExists(targetDir.resolve(targetBase + "-" + fileName));
        }

        String suffix = fileName.substring(baseLen); // ".pdf" OR "_02.pdf" OR "-2.pdf" OR ".CSV"
        Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
        Files.copy(source, dest, StandardCopyOption.COPY_ATTRIBUTES);

        return dest;
    }

    private void logResult(String normalizedBase, List<Path> moved) {
        if (moved.isEmpty()) {
            log.debug("No attachments found for base '{}'", normalizedBase);
        } else {
            log.info("Moved {} attachment(s) for base '{}'", moved.size(), normalizedBase);
        }
    }

    private boolean shouldSkip(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        if (xmlBaseName == null || xmlBaseName.isBlank()) {
            log.warn("XML base name is blank. Skipping attachment move.");
            return true;
        }
        if (outputXmlFileName == null || outputXmlFileName.isBlank()) {
            log.warn("Output XML file name is blank. Skipping attachment move.");
            return true;
        }
        if (targetDir == null) {
            log.warn("Target directory is null. Skipping attachment move.");
            return true;
        }
        return false;
    }

    private boolean isValidSourceDir(Path sourceDir) {
        if (sourceDir == null || !Files.isDirectory(sourceDir)) {
            log.warn("Source directory is missing. Skipping attachment move.");
            return false;
        }
        return true;
    }

    /**
     * IMPORTANT:
     * - Strips extension
     * - Removes trailing _<digits> (new scheme where XML ends with _01)
     * Examples:
     *  - "X_01.xml" -> "x"
     *  - "A1_B123_multiplethings_01" -> "a1_b123_multiplethings"
     *  - "A.xml" -> "a"  (no change besides normalize)
     */
    private static String normalizeAttachmentBase(String xmlBaseNameOrFileName) {
        if (xmlBaseNameOrFileName == null) {
            return null;
        }
        String raw = Paths.get(xmlBaseNameOrFileName).getFileName().toString();
        String noExt = stripExtension(raw).trim();
        String noSeq = TRAILING_SEQ.matcher(noExt).replaceFirst("");
        return normalize(noSeq);
    }

    private static String stripExtension(String fileName) {
        int dot = fileName.lastIndexOf('.');
        return dot > 0 ? fileName.substring(0, dot) : fileName;
    }

    private static String normalize(String s) {
        return s == null ? null : s.toLowerCase(Locale.ROOT).trim();
    }

    private static Path uniqueIfExists(Path dest) {
        if (!Files.exists(dest)) {
            return dest;
        }

        String name = dest.getFileName().toString();
        String base = stripExtension(name);
        String ext = "";

        int dot = name.lastIndexOf('.');
        if (dot > 0) {
            ext = name.substring(dot);
        }

        Path dir = dest.getParent();
        int i = 2;
        Path candidate = dir.resolve(base + "-" + i + ext);
        while (Files.exists(candidate)) {
            i++;
            candidate = dir.resolve(base + "-" + i + ext);
        }
        return candidate;
    }
}


‚∏ª

SplitAttachmentMoverTest.java (final)

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    private Path sourceDir;
    private Path targetDir;

    private PathConfig pathConfig;
    private SplitAttachmentMover mover;

    @BeforeEach
    void setup() throws IOException {
        sourceDir = Files.createDirectory(tempDir.resolve("unzippedXml"));
        targetDir = Files.createDirectory(tempDir.resolve("out"));

        pathConfig = Mockito.mock(PathConfig.class);
        PathConfig.Unzipped unzipped = Mockito.mock(PathConfig.Unzipped.class);

        Mockito.when(pathConfig.getUnzipped()).thenReturn(unzipped);
        Mockito.when(unzipped.getXml()).thenReturn(sourceDir);

        mover = new SplitAttachmentMover(pathConfig);
    }

    @Test
    void moveAttachments_newXmlSuffix_baseDerivedAndCopiesAllMatching() throws Exception {
        write(sourceDir, "A1_B123_multiplethings_01.xml", "<xml/>");
        write(sourceDir, "A1_B123_multiplethings_02.pdf", "pdf2");
        write(sourceDir, "A1_B123_multiplethings_03.pdf", "pdf3");
        write(sourceDir, "A1_B123_multiplethings_04.csv", "csv4");
        write(sourceDir, "A1_B123_multiplethings_999.jpeg", "img");
        write(sourceDir, "OTHER_02.pdf", "nope");

        List<Path> moved = mover.moveAttachments(
                "A1_B123_multiplethings_01.xml",
                "NEWNAME_INV_123.xml",
                targetDir
        );

        assertEquals(4, moved.size());
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_02.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_03.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_04.csv")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123_999.jpeg")));

        // xml should never be moved
        assertFalse(Files.exists(targetDir.resolve("NEWNAME_INV_123_01.xml")));
    }

    @Test
    void moveAttachments_legacyXmlAndLegacySinglePdf_isCopied() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT.pdf")));
    }

    @Test
    void moveAttachments_doesNotMoveAnyXmlEvenIfMatchesBase() throws Exception {
        write(sourceDir, "X_01.xml", "<xml/>");
        write(sourceDir, "X_02.xml", "<xml/>"); // should NOT be moved
        write(sourceDir, "X_02.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("X_01.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_02.pdf")));
        assertFalse(Files.exists(targetDir.resolve("OUT_02.xml")));
    }

    @Test
    void moveAttachments_ignoresNonRegularFiles() throws Exception {
        write(sourceDir, "A_01.xml", "<xml/>");
        Files.createDirectory(sourceDir.resolve("A_02.pdf")); // directory, not a file

        List<Path> moved = mover.moveAttachments("A_01.xml", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_createsUniqueNameIfTargetExists() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        // pre-create destination so uniqueIfExists triggers
        write(targetDir, "OUT.pdf", "existing");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-2.pdf")));
    }

    @Test
    void moveAttachments_returnsEmptyList_whenNoAttachmentsPresent() throws Exception {
        write(sourceDir, "A_01.xml", "<xml/>");

        List<Path> moved = mover.moveAttachments("A_01.xml", "OUT.xml", targetDir);

        assertNotNull(moved);
        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenInputsInvalid() {
        assertTrue(mover.moveAttachments(" ", "OUT.xml", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", " ", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "OUT.xml", null).isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenSourceDirMissing() throws Exception {
        // point sourceDir to a file (not directory)
        Path fileInsteadOfDir = write(tempDir, "notADir.txt", "x");
        PathConfig.Unzipped unzipped = pathConfig.getUnzipped();
        Mockito.when(unzipped.getXml()).thenReturn(fileInsteadOfDir);

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_handlesIOException_andDoesNotThrow() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "pdf");

        // deterministic IOException: pass a file path as targetDir so createDirectories/copy fails
        Path targetIsFile = write(tempDir, "targetFile", "x");

        assertDoesNotThrow(() -> {
            List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetIsFile);
            assertTrue(moved.isEmpty());
        });
    }

    @Test
    void moveAttachments_supportsOlderLegacyDashPattern() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-2.pdf", "pdf");

        List<Path> moved = mover.moveAttachments("A.xml", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-2.pdf")));
    }

    private static Path write(Path dir, String name, String content) throws IOException {
        Path p = dir.resolve(name);
        Files.writeString(p, content);
        return p;
    }
}


‚∏ª

What this fixes for your reported issue
	‚Ä¢	Legacy A.xml + A.pdf no longer gets skipped (it matches base.<ext> and we don‚Äôt require _nn).
	‚Ä¢	New A1_B123_multiplethings_01.xml correctly derives base A1_B123_multiplethings and moves _02/_03/_999 attachments.
	‚Ä¢	Never moves XML as attachment (so you don‚Äôt accidentally copy X_02.xml).

If you want, paste your current attachment mover integration point (the place you call moveAttachments) and I‚Äôll point out why the PDF ‚Äúdisappeared‚Äù after the refactor (usually it‚Äôs either: wrong sourceDir path, wrong xmlBaseName passed, or you moved PDFs earlier than renaming logic and then the registry lookup can‚Äôt find them).

‚Äî‚Äî‚Äî
Got it ‚Äî this changes the concept of ‚Äúbase‚Äù.

Now the XML itself is indexed (X_01.xml), while attachments use the same prefix X_ but different indices (X_02.pdf, X_03.pdf, ‚Ä¶, X_999.jpeg).
So you must normalize the base from X_01 ‚Üí X and then match/copy everything starting with X_ (except any .xml).

Below are the exact changes to make in your SplitAttachmentMover.

‚∏ª

1) Add a ‚Äúbundle base‚Äù normalizer

private static String normalizeBundleBase(String xmlBaseName) {
    if (xmlBaseName == null) return null;
    // X_01 -> X, ABC_999 -> ABC
    return xmlBaseName.replaceFirst("(?i)_[0-9]+$", "");
}


‚∏ª

2) Update moveAttachments(...) to use normalized base for matching + suffix

Key change: compute normalizedBase = normalizeBundleBase(stripExtension(xmlBaseName)).toLowerCase()

public List<Path> moveAttachments(String xmlBaseName,
                                 String outputXmlFileName,
                                 Path targetDir) {

    if (shouldSkip(xmlBaseName, outputXmlFileName, targetDir)) {
        return List.of();
    }

    Path sourceDir = pathConfig.getUnzipped().getXml();
    if (!isValidSourceDir(sourceDir)) {
        return List.of();
    }

    // xmlBaseName may be "X_01" now -> normalize to "X"
    String normalizedBase = normalizeBundleBase(xmlBaseName);
    if (normalizedBase == null || normalizedBase.isBlank()) {
        log.warn("Normalized base is blank for xmlBaseName='{}'. Skipping attachment move.", xmlBaseName);
        return List.of();
    }
    normalizedBase = normalizedBase.toLowerCase(Locale.ROOT);

    String targetBase = stripExtension(Paths.get(outputXmlFileName).getFileName().toString());

    try {
        Files.createDirectories(targetDir);
        return copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase);
    } catch (IOException ex) {
        log.error("Failed moving attachments for base '{}': {}", xmlBaseName, ex.getMessage());
        return List.of();
    }
}


‚∏ª

3) Update copyMatchingAttachments(...) signature + suffix logic

You no longer use xmlBaseName for substring. Use normalizedBase length instead.

private List<Path> copyMatchingAttachments(Path sourceDir,
                                          Path targetDir,
                                          String normalizedBase,
                                          String targetBase) throws IOException {

    List<Path> moved = new ArrayList<>();

    try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
        for (Path p : stream) {
            if (!Files.isRegularFile(p)) {
                continue;
            }

            String fileName = p.getFileName().toString();
            if (!isAttachmentForBase(fileName, normalizedBase)) {
                continue;
            }

            Path copied = copySingleAttachment(p, fileName, normalizedBase, targetDir, targetBase);
            moved.add(copied);
        }
    }

    logResult(normalizedBase, moved);
    return moved;
}


‚∏ª

4) Update copySingleAttachment(...)

private Path copySingleAttachment(Path source,
                                 String fileName,
                                 String normalizedBase,
                                 Path targetDir,
                                 String targetBase) throws IOException {

    // keep original suffix: "_02.pdf", ".pdf", "-1.pdf", etc.
    String suffix = fileName.substring(normalizedBase.length());

    Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
    Files.copy(source, dest, StandardCopyOption.COPY_ATTRIBUTES);

    return dest;
}


‚∏ª

5) Update isAttachmentForBase(...) for new scheme

Important changes:
	‚Ä¢	Exclude any .xml (since xmls are not attachments now)
	‚Ä¢	Support:
	‚Ä¢	X_02.pdf (new)
	‚Ä¢	X.pdf (legacy)
	‚Ä¢	X-1.pdf (older legacy) if you still want it

private boolean isAttachmentForBase(String fileName, String normalizedBase) {
    if (fileName == null || fileName.isBlank() || normalizedBase == null || normalizedBase.isBlank()) {
        return false;
    }

    String lower = fileName.toLowerCase(Locale.ROOT);
    String base = normalizedBase.toLowerCase(Locale.ROOT);

    // Never treat ANY xml as attachment (important for X_01.xml, and possible other xmls)
    if (lower.endsWith(".xml")) {
        return false;
    }

    if (!lower.startsWith(base)) {
        return false;
    }

    int baseLen = base.length();
    if (lower.length() <= baseLen) {
        return false;
    }

    char sep = lower.charAt(baseLen);

    // New: X_02.pdf / X_999.jpeg
    if (sep == '_') {
        // must be digits after '_' (at least 1), then a dot later
        int i = baseLen + 1;
        if (i >= lower.length() || !Character.isDigit(lower.charAt(i))) {
            return false;
        }
        while (i < lower.length() && Character.isDigit(lower.charAt(i))) {
            i++;
        }
        return i < lower.length() && lower.charAt(i) == '.';
    }

    // Legacy: X.pdf
    if (sep == '.') {
        return true;
    }

    // Older legacy: X-1.pdf
    if (sep == '-') {
        return true;
    }

    return false;
}


‚∏ª

Test you must add (for this new naming)

Add one test like this:
	‚Ä¢	xmlBaseName = "X_01" (from stripExtension("X_01.xml"))
	‚Ä¢	attachments: X_02.pdf, X_03.pdf, X_04.csv, X_999.jpeg

Expected outputs: OUT_02.pdf, OUT_03.pdf, OUT_04.csv, OUT_999.jpeg

If you want, paste your current SplitAttachmentMover file (as text), and I‚Äôll return it as a single final class + the updated full JUnit class matching your exact package/imports.


=======
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.mockito.Mockito;

import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    private Path sourceDir;
    private Path targetDir;

    private PathConfig pathConfig;
    private SplitAttachmentMover mover;

    @BeforeEach
    void setup() throws Exception {
        sourceDir = Files.createDirectory(tempDir.resolve("unzippedXml"));
        targetDir = Files.createDirectory(tempDir.resolve("out"));

        pathConfig = Mockito.mock(PathConfig.class);
        PathConfig.Unzipped unzipped = Mockito.mock(PathConfig.Unzipped.class);

        when(pathConfig.getUnzipped()).thenReturn(unzipped);
        when(unzipped.getXml()).thenReturn(sourceDir);

        mover = new SplitAttachmentMover(pathConfig);
    }

    // -------------------------
    // Public API tests (moveAttachments)
    // -------------------------

    @Test
    void moveAttachments_copiesNewFormatAttachments_base_underscoreNN() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A_01.pdf", "pdf");
        write(sourceDir, "A_02.csv", "csv");
        write(sourceDir, "B_01.pdf", "other");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(2, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_01.pdf")));
        assertTrue(Files.exists(targetDir.resolve("OUT_02.csv")));
        assertFalse(Files.exists(targetDir.resolve("OUT.xml"))); // never copy xml as attachment
    }

    @Test
    void moveAttachments_supportsLegacy_baseDotExt_A_pdf() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A.pdf", "legacy");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT.pdf")));
    }

    @Test
    void moveAttachments_supportsOlderLegacy_baseDashNN_A_1_pdf() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-1.pdf", "olderLegacy");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-1.pdf")));
    }

    @Test
    void moveAttachments_skipsNonMatchingPrefix() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "X_01.pdf", "nope");
        write(sourceDir, "XA.pdf", "nope");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
        assertFalse(Files.exists(targetDir.resolve("OUT_01.pdf")));
        assertFalse(Files.exists(targetDir.resolve("OUTA.pdf")));
    }

    @Test
    void moveAttachments_ignoresNonRegularFiles() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        Files.createDirectory(sourceDir.resolve("A_01.pdf")); // directory named like attachment

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_createsUniqueNameIfTargetExists() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A_01.pdf", "pdf");

        // precreate output
        write(targetDir, "OUT_01.pdf", "existing");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT_01-2.pdf")));
    }

    @Test
    void moveAttachments_returnsEmpty_whenInputsInvalid() {
        assertTrue(mover.moveAttachments("", "OUT.xml", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "", targetDir).isEmpty());
        assertTrue(mover.moveAttachments("A", "OUT.xml", null).isEmpty());
    }

    @Test
    void moveAttachments_returnsEmpty_whenSourceDirMissing() throws Exception {
        // point sourceDir to a file instead of directory
        Path notADir = write(tempDir, "notADir.txt", "x");

        PathConfig.Unzipped unzipped = pathConfig.getUnzipped();
        when(unzipped.getXml()).thenReturn(notADir);

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_handlesIOException_whenTargetIsFile() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A_01.pdf", "pdf");

        Path targetIsFile = write(tempDir, "targetFile", "x");

        assertDoesNotThrow(() -> {
            List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetIsFile);
            assertTrue(moved.isEmpty());
        });
    }

    // -------------------------
    // Private method branch coverage (reflection)
    // This is needed because some branches are unreachable from filesystem iteration.
    // -------------------------

    @ParameterizedTest
    @CsvSource({
        // null/blank guards
        " ,A,false",
        "'',A,false",
        "A, ,false",
        "A,'',false",

        // xml itself must be false
        "A.xml,A,false",
        "a.XML,a,false",

        // prefix mismatch
        "B_01.pdf,A,false",

        // length <= baseLen branch (e.g., filename exactly base)
        "A,A,false",

        // separator not allowed: base followed by letter/number directly
        "A01.pdf,A,false",

        // allowed separators: '_', '.', '-'
        "A_01.pdf,A,true",
        "A.pdf,A,true",
        "A-1.pdf,A,true"
    })
    void isAttachmentForBase_privateMethodCoverage(String fileName, String base, boolean expected) throws Exception {
        boolean actual = invokeIsAttachmentForBase(fileName, base == null ? null : base.toLowerCase());
        assertEquals(expected, actual);
    }

    @Test
    void isAttachmentForBase_returnsFalse_whenFileNameDoesNotStartWithBase() throws Exception {
        assertFalse(invokeIsAttachmentForBase("XA.pdf", "a"));
        assertFalse(invokeIsAttachmentForBase("BA_01.pdf", "a"));
    }

    // -------------------------
    // Helpers
    // -------------------------

    private boolean invokeIsAttachmentForBase(String fileName, String normalizedBase) throws Exception {
        Method m = SplitAttachmentMover.class.getDeclaredMethod(
            "isAttachmentForBase", String.class, String.class
        );
        m.setAccessible(true);
        return (boolean) m.invoke(mover, fileName, normalizedBase);
    }

    private static Path write(Path dir, String name, String content) throws IOException {
        Path p = dir.resolve(name);
        Files.writeString(p, content);
        return p;
    }
}
