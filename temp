
Yes—totally. Here are two clean “pick wait by tier” options that match what you suggested. Paste one of these helpers and call it right after your CFT notify (before you move to processed/).

Option 1: Tier + linear after 5MB
	•	< 1 MB → 2 s
	•	1–<5 MB → 5 s
	•	≥ 5 MB → 2 s + 1 s per MB (capped)

import java.time.Duration;

private static final long MB = 1024L * 1024L;
private static final long MAX_WAIT_SEC = 10 * 60; // cap at 10 min (tune as needed)

public static Duration pickWaitByTier(long bytes) {
  if (bytes < 1 * MB) return Duration.ofSeconds(2);     // tiny
  if (bytes < 5 * MB) return Duration.ofSeconds(5);     // small

  long sizeMB = (long) Math.ceil((double) bytes / MB);
  long secs = 2 + sizeMB;                               // 2s base + 1s/MB
  if (secs > MAX_WAIT_SEC) secs = MAX_WAIT_SEC;         // safety cap
  return Duration.ofSeconds(secs);
}

Examples
	•	0.7 MB → 2 s
	•	3.2 MB → 5 s
	•	10 MB → 12 s
	•	120 MB → 122 s (~2m02s), capped if it exceeds MAX_WAIT_SEC

⸻

Option 2: Pure “1 second per MB” with a 2 s floor
	•	< 1 MB → 2 s
	•	≥ 1 MB → 2 s + 1 s per MB

public static Duration pickWaitPerMB(long bytes) {
  long sizeMB = (long) Math.ceil(bytes / (double) MB);
  long secs = (bytes < MB) ? 2 : 2 + sizeMB;            // 1MB→3s, 2MB→4s, ...
  if (secs > MAX_WAIT_SEC) secs = MAX_WAIT_SEC;
  return Duration.ofSeconds(secs);
}


⸻

How to use in your tasklet

long bytes = encryptedFile.length();
Duration wait = pickWaitByTier(bytes); // or pickWaitPerMB(bytes)
log.info("Payload size = {} bytes (~{} MB). Waiting {} before move.",
         bytes, Math.ceil(bytes / (double) MB), wait);
try { Thread.sleep(wait.toMillis()); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }

Tip: keep the cap (MAX_WAIT_SEC) so huge backlogs don’t block this step forever. If you later want even more safety, you can follow this wait with a quick HEAD check on the COS object before the move.

void zipEncryptUploadFiles(Path processedFile, String zipFilePrefix) throws IOException {
  Files.createDirectories(outputDir);

  // Step 1: Zip
  String zipFileName = zipFilePrefix + "_invoices_" + getCurrentDateTimeValue() + ".zip";
  File zipFile = outputDir.resolve(zipFileName).toFile();
  zipDirectory(processedFile, zipFile);

  // Step 2: Encrypt
  String encryptedFileName = zipFileName + ".pgp";
  File encryptedFile = outputDir.resolve(encryptedFileName).toFile();
  pgpEncrypt.encrypt(new FileInputStream(zipFile), new FileOutputStream(encryptedFile));
  log.info("Encrypted ZIP at: {}", encryptedFile.getAbsolutePath());

  // Step 3: Upload
  String key = "outgoing_e-invoice/" + encryptedFileName;
  cosStorageService.uploadFile(key, encryptedFile);
  log.info("Uploaded to COS: {}", key);

  // Step 4: Notify CFT (no waiting inside this method)
  log.info("CFT notify enabled: {}", cftEnabled);
  if (cftEnabled) {
    cftApiClient.notifyUpload(key, encryptedFileName); // returns 201 asynchronously
  }

  // ---- SIZE-BASED GRACE before moving to processed ----
  long bytes = encryptedFile.length();
  Duration grace = pickWaitByEstimate(bytes); // or pickWaitByTier(bytes)
  log.info("Payload size = {} bytes ({}). Grace wait before move = {}",
      bytes, human(bytes), grace);
  if (!grace.isZero()) {
    try { Thread.sleep(grace.toMillis()); } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
    }
  }

  // Step 5: Move to processed
  moveToProcessed(encryptedFileName, key);
}

// ---------- helpers (tweak thresholds to taste) ----------
private static Duration pickWaitByTier(long bytes) {
  long MB = 1024L * 1024L;
  if (bytes < 50 * MB)  return Duration.ZERO;           // <50MB: no wait
  if (bytes < 200 * MB) return Duration.ofSeconds(6);   // 50–200MB
  if (bytes < 1024 * MB)return Duration.ofSeconds(20);  // 200MB–1GB
  return Duration.ofMinutes(2);                         // 1GB+
}

private static Duration pickWaitByEstimate(long bytes) {
  // Replace 50 MB/s with your observed end-to-end throughput
  double assumedBps = 50 * 1024 * 1024d;
  double secs = 6 + 1.5 * (bytes / assumedBps);         // base + scaled wait
  long clamped = Math.max(0, Math.min((long)Math.ceil(secs), 2 * 60 * 60)); // cap 2h
  return Duration.ofSeconds(clamped);
}

private static String human(long bytes) {
  String[] u = {"B","KB","MB","GB","TB"};
  int i = 0; double v = bytes;
  while (v >= 1024 && i < u.length - 1) { v /= 1024; i++; }
  return String.format("%.1f %s", v, u[i]);
}
