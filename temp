Perfect ‚Äî since you‚Äôve **moved it to a util class and made it `static`**, here is a **clean, minimal, Sonar/Fortify-safe JUnit 5 test** you can drop straight in.

I‚Äôll assume:

* Class name: `InvoiceBatchUtil`
* Method signature:

```java
public static String sanitizeForFileName(String value)
```

---

## ‚úÖ JUnit 5 ‚Äì `InvoiceBatchUtilTest`

```java
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class InvoiceBatchUtilTest {

    @Test
    void shouldReturnUnknownWhenValueIsNull() {
        String result = InvoiceBatchUtil.sanitizeForFileName(null);
        assertEquals("unknown", result);
    }

    @Test
    void shouldReturnUnknownWhenValueIsBlank() {
        String result = InvoiceBatchUtil.sanitizeForFileName("   ");
        assertEquals("unknown", result);
    }

    @Test
    void shouldTrimAndReplaceWhitespaceWithUnderscore() {
        String result = InvoiceBatchUtil.sanitizeForFileName("  Big   Supplier  Name ");
        assertEquals("Big_Supplier_Name", result);
    }

    @Test
    void shouldReplaceForwardSlash() {
        String result = InvoiceBatchUtil.sanitizeForFileName("ABC/DEF");
        assertEquals("ABC_DEF", result);
    }

    @Test
    void shouldReplaceMultipleUnsafeCharactersWithSingleUnderscore() {
        String result = InvoiceBatchUtil.sanitizeForFileName("ACME / Finance : GmbH");
        assertEquals("ACME_Finance_GmbH", result);
    }

    @Test
    void shouldReplaceAllFileSystemUnsafeCharacters() {
        String result = InvoiceBatchUtil.sanitizeForFileName("A\\B:C*D?E\"F<G>H|I");
        assertEquals("A_B_C_D_E_F_G_H_I", result);
    }

    @Test
    void shouldLeaveSafeCharactersUntouched() {
        String result = InvoiceBatchUtil.sanitizeForFileName("Supplier-123_OK");
        assertEquals("Supplier-123_OK", result);
    }

    @Test
    void shouldHandleSingleCharacterInput() {
        String result = InvoiceBatchUtil.sanitizeForFileName("/");
        assertEquals("_", result);
    }
}
```

---

## üîê Why this test is **exactly right**

* ‚úÖ No Mockito (pure utility)
* ‚úÖ Covers **null**, **blank**, **whitespace**, **slashes**, **Windows chars**
* ‚úÖ Verifies collapsing to **single `_`**
* ‚úÖ Sonar clean (no unused vars, no magic)
* ‚úÖ Fortify-friendly (explicit untrusted input handling)

---

## üß† Mapping tests ‚Üí production risks

| Test               | Real-world failure it prevents |
| ------------------ | ------------------------------ |
| Null / blank       | NPEs in batch                  |
| Whitespace         | Broken COS keys                |
| `/`                | Accidental directories         |
| Windows chars      | Prod crash on Windows          |
| Multiple bad chars | Ugly / unstable filenames      |

---

## üìå Optional (but nice)

If you want **100% defensive**, you can add a length test later (e.g. truncate to 100 chars). But **do not add it unless required** ‚Äî your current logic is already production-grade.

If you want, next I can:

* wire this util into **both XML & PDF writers**
* add a **single parameterized test** instead of multiple ones
* check Sonar rule IDs this satisfies

Just say üëç


=======
Yep ‚Äî I can see exactly where the issue comes from in your `updateInvoiceName(...)`:

```java
supplierParty.replace(" ", "-")
...
invoiceFileName.replace("/", "-")
```

That only fixes **spaces** and **forward slashes**, but supplier names can contain lots of other filename-breaking characters (and multiple whitespaces).

## Minimal, clean fix in `XmlInvoiceWriter`

### 1) Add a small sanitizer (keep it local, Sonar/Fortify safe)

Add these imports:

```java
import java.util.regex.Pattern;
```

Add this near the bottom of the class:

```java
private static final Pattern UNSAFE_FILE_CHARS = Pattern.compile("[\\s\\\\/:*?\"<>|]+");

private String sanitizeForFileName(String value) {
    if (value == null) {
        return "unknown";
    }
    String trimmed = value.trim();
    if (trimmed.isEmpty()) {
        return "unknown";
    }
    return UNSAFE_FILE_CHARS.matcher(trimmed).replaceAll("_");
}
```

* Replaces **whitespace** + **/ \ : * ? " < > |** with `_`
* Collapses repeated unsafe chars into a single `_`
* Avoids weird folder creation
* Pattern is **precompiled** (Sonar-friendly)

---

### 2) Use it in your finance filename block (minimal change)

Replace this part:

```java
String supplierParty = invoiceBucketResolver.getSupplierName(invoice.getAccountingSupplierParty());
invoiceFileName = getCurrentDateTimeValue() + "_" +
        supplierParty.replace(" ", "-") +
        "_INV_" + invoiceFileName.replace("/", "-") + ".xml";
```

With this:

```java
String supplierPartyRaw = invoiceBucketResolver.getSupplierName(invoice.getAccountingSupplierParty());
String supplierParty = sanitizeForFileName(supplierPartyRaw);

String invoicePart = sanitizeForFileName(invoiceFileName);

invoiceFileName = getCurrentDateTimeValue() + "_" +
        supplierParty +
        "_INV_" + invoicePart + ".xml";
```

That‚Äôs it. You don‚Äôt need to touch the rest of the writer.

---

## Why this fixes your issue

* Supplier name like `ACME / Finance GmbH` becomes `ACME_Finance_GmbH`
* Invoice IDs containing `/` (common!) become safe too
* Works across Linux/Windows and avoids accidental directory nesting

---

If you want, paste the rest of `updateInvoiceName(...)` and I‚Äôll show the final full method with only these minimal edits applied (no refactor).

