private void unzipSafely(Path zipFile, Path targetDir) throws IOException {
    if (!Files.exists(zipFile) || !Files.isRegularFile(zipFile) || !Files.isReadable(zipFile)) {
        throw new IOException("Invalid ZIP file: " + zipFile);
    }

    Files.createDirectories(targetDir);
    Path canonicalBase = targetDir.toRealPath(LinkOption.NOFOLLOW_LINKS);

    final int MAX_ENTRIES = 10_000;
    final long MAX_TOTAL_SIZE = 1_000_000_000L;

    long totalSize = 0;
    int entryCount = 0;

    // Step 1: open using ZipFile (random-access safe)
    try (java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFile.toFile())) {
        Enumeration<? extends ZipEntry> entries = zf.entries();

        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            String rawName = entry.getName();

            // Step 2: sanitize purely as a string
            if (rawName == null || rawName.isBlank()
                    || rawName.contains("..")
                    || rawName.startsWith("/")
                    || rawName.startsWith("\\")
                    || rawName.contains(":")
                    || !rawName.matches("^[A-Za-z0-9._\\-\\s/]+$")) {
                throw new IOException("Invalid ZIP entry name: " + rawName);
            }

            // Step 3: map to a generated safe filename
            // This breaks the taint link completely
            String safeFileName = UUID.nameUUIDFromBytes(rawName.getBytes(StandardCharsets.UTF_8)).toString();
            Path targetFile = canonicalBase.resolve(safeFileName + getExtension(rawName));

            // containment check on canonical path
            Path canonicalOut = targetFile.toRealPath(LinkOption.NOFOLLOW_LINKS);
            if (!canonicalOut.startsWith(canonicalBase)) {
                throw new IOException("Entry escapes target dir: " + rawName);
            }

            // Step 4: directories
            if (entry.isDirectory()) {
                Files.createDirectories(canonicalOut);
                continue;
            }

            Files.createDirectories(canonicalOut.getParent());

            // Step 5: copy securely
            try (InputStream is = zf.getInputStream(entry);
                 OutputStream os = new BufferedOutputStream(Files.newOutputStream(canonicalOut))) {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = is.read(buffer)) != -1) {
                    os.write(buffer, 0, bytesRead);
                    totalSize += bytesRead;
                    if (totalSize > MAX_TOTAL_SIZE) {
                        throw new IOException("Archive too large");
                    }
                }
            }

            entryCount++;
            if (entryCount > MAX_ENTRIES) {
                throw new IOException("Too many entries in archive");
            }
        }
    }

    log.info("Unzip completed: {} entries, {} bytes extracted", entryCount, totalSize);
}

private String getExtension(String name) {
    int dot = name.lastIndexOf('.');
    return (dot >= 0) ? name.substring(dot) : "";
}
