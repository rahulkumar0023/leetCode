Nice, good to hear it‚Äôs working üéâ
Let‚Äôs add JUnit tests around the new behaviour.

I‚Äôll assume:

* Class name: `CFTApiClient`
* New public method:
  `notifyAndWaitForCompletion(String outPath, String fileName, Duration waitTime)`
* Internally it does:

  * POST ‚Üí get `idtu`
  * wait
  * GET (maybe second GET if first was `SENDING`)
  * retry the whole POST+wait+GET sequence **once** if final status is error
    (`CANCELLED`, `diagi != 0`, or still `SENDING`)

You already have:

* `RestTemplateBuilder restTemplateBuilder` mock
* `RestTemplate restTemplate` mock
* `ObjectMapper objectMapper` mock
* `CFTApiClient restApiClient` initialised via reflection (as in your screenshot)

We‚Äôll just **add new tests** to your existing `CFTApiClientTest`.
To avoid real `Thread.sleep`, we‚Äôll pass `Duration.ZERO` in tests.

---

## 1. Helpers for the tests

Add these helpers inside `CFTApiClientTest` (under your fields):

```java
private static final Duration NO_WAIT = Duration.ZERO;

private static TransferStatusResponse status(String idtu, String sentinel, int diagi, String diagnostic) {
    TransferStatusResponse s = new TransferStatusResponse();
    s.setIdtu(idtu);
    s.setSentinel(sentinel);
    s.setDiagi(diagi);
    s.setDiagnostic(diagnostic);
    return s;
}
```

---

## 2. Success ‚Äì first attempt, COMPLETED immediately

```java
@Test
void notifyAndWaitForCompletion_successOnFirstAttempt_completed() throws Exception {
    // given
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    // POST response body containing idtu
    String postBody = "{\"idtu\":\"idtu1\"}";
    ResponseEntity<String> postResponse =
            new ResponseEntity<>(postBody, HttpStatus.OK);

    // GET response body (we‚Äôll let ObjectMapper turn it into TransferStatusResponse)
    String getBody = "{\"idtu\":\"idtu1\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"ok\"}";
    ResponseEntity<String> getResponse =
            new ResponseEntity<>(getBody, HttpStatus.OK);

    // ObjectMapper: write request JSON
    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    // ObjectMapper: parse POST response (idtu)
    when(objectMapper.readTree(postBody))
            .thenReturn(new ObjectMapper().readTree(postBody));

    // ObjectMapper: parse GET response into TransferStatusResponse
    when(objectMapper.readValue(eq(getBody), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "COMPLETED", 0, "ok"));

    // RestTemplate: first call is POST, second is GET
    when(restTemplate.exchange(
            startsWith("baseUrl?"),  // your baseURL + query
            eq(HttpMethod.POST),
            any(HttpEntity.class),
            eq(String.class),
            any(Map.class))
    ).thenReturn(postResponse);

    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"),
            eq(HttpMethod.GET),
            isNull(),
            eq(String.class),
            any(Map.class))
    ).thenReturn(getResponse);

    // when / then ‚Äì should NOT throw
    assertThatCode(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    ).doesNotThrowAnyException();

    // verify 1 POST + 1 GET
    verify(restTemplate, times(1)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(1)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

## 3. Success ‚Äì first attempt: SENDING then COMPLETED

Here we simulate **two GET calls** in the same attempt: first `SENDING`, second `COMPLETED`.

```java
@Test
void notifyAndWaitForCompletion_successOnFirstAttempt_sendingThenCompleted() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    String postBody = "{\"idtu\":\"idtu1\"}";
    ResponseEntity<String> postResponse =
            new ResponseEntity<>(postBody, HttpStatus.OK);

    String getBody1 = "{\"idtu\":\"idtu1\",\"sentinel\":\"SENDING\",\"diagi\":0,\"diagnostic\":\"in progress\"}";
    String getBody2 = "{\"idtu\":\"idtu1\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"done\"}";

    ResponseEntity<String> getResponse1 =
            new ResponseEntity<>(getBody1, HttpStatus.OK);
    ResponseEntity<String> getResponse2 =
            new ResponseEntity<>(getBody2, HttpStatus.OK);

    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    when(objectMapper.readTree(postBody))
            .thenReturn(new ObjectMapper().readTree(postBody));

    when(objectMapper.readValue(eq(getBody1), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "SENDING", 0, "in progress"));

    when(objectMapper.readValue(eq(getBody2), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "COMPLETED", 0, "done"));

    // POST once, GET twice in order
    when(restTemplate.exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST),
            any(HttpEntity.class), eq(String.class), any(Map.class))
    ).thenReturn(postResponse);

    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET),
            isNull(), eq(String.class), any(Map.class))
    ).thenReturn(getResponse1, getResponse2);

    assertThatCode(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    ).doesNotThrowAnyException();

    verify(restTemplate, times(1)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

## 4. Retry ‚Äì first attempt CANCELLED, second attempt COMPLETED

This checks that:

* we do **two POSTs** and **two GETs**,
* final result is success (no exception).

```java
@Test
void notifyAndWaitForCompletion_retryAfterCancelled_thenSuccess() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    // First attempt
    String postBody1 = "{\"idtu\":\"idtu1\"}";
    String getBody1 = "{\"idtu\":\"idtu1\",\"sentinel\":\"CANCELLED\",\"diagi\":5,\"diagnostic\":\"cancelled\"}";

    ResponseEntity<String> postResponse1 =
            new ResponseEntity<>(postBody1, HttpStatus.OK);
    ResponseEntity<String> getResponse1 =
            new ResponseEntity<>(getBody1, HttpStatus.OK);

    // Second attempt
    String postBody2 = "{\"idtu\":\"idtu2\"}";
    String getBody2 = "{\"idtu\":\"idtu2\",\"sentinel\":\"COMPLETED\",\"diagi\":0,\"diagnostic\":\"ok on retry\"}";

    ResponseEntity<String> postResponse2 =
            new ResponseEntity<>(postBody2, HttpStatus.OK);
    ResponseEntity<String> getResponse2 =
            new ResponseEntity<>(getBody2, HttpStatus.OK);

    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    // POST parse
    when(objectMapper.readTree(postBody1))
            .thenReturn(new ObjectMapper().readTree(postBody1));
    when(objectMapper.readTree(postBody2))
            .thenReturn(new ObjectMapper().readTree(postBody2));

    // GET parse
    when(objectMapper.readValue(eq(getBody1), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "CANCELLED", 5, "cancelled"));
    when(objectMapper.readValue(eq(getBody2), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu2", "COMPLETED", 0, "ok on retry"));

    // POST calls in order (attempt 1, then 2)
    when(restTemplate.exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST),
            any(HttpEntity.class), eq(String.class), any(Map.class))
    ).thenReturn(postResponse1, postResponse2);

    // GET calls in order (one per attempt)
    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET),
            isNull(), eq(String.class), any(Map.class))
    ).thenReturn(getResponse1, getResponse2);

    assertThatCode(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    ).doesNotThrowAnyException();

    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

## 5. Final failure ‚Äì both attempts error ‚áí exception (batch will fail)

This ensures `notifyAndWaitForCompletion` throws, which, if you don‚Äôt catch it in the tasklet, will make your Spring Batch job fail.

```java
@Test
void notifyAndWaitForCompletion_throwsWhenBothAttemptsFail() throws Exception {
    String outPath = "out/path/file.pgp";
    String fileName = "file.pgp";

    String postBody1 = "{\"idtu\":\"idtu1\"}";
    String getBody1  = "{\"idtu\":\"idtu1\",\"sentinel\":\"CANCELLED\",\"diagi\":5,\"diagnostic\":\"first fail\"}";

    String postBody2 = "{\"idtu\":\"idtu2\"}";
    String getBody2  = "{\"idtu\":\"idtu2\",\"sentinel\":\"CANCELLED\",\"diagi\":7,\"diagnostic\":\"second fail\"}";

    ResponseEntity<String> postResponse1 =
            new ResponseEntity<>(postBody1, HttpStatus.OK);
    ResponseEntity<String> postResponse2 =
            new ResponseEntity<>(postBody2, HttpStatus.OK);

    ResponseEntity<String> getResponse1 =
            new ResponseEntity<>(getBody1, HttpStatus.OK);
    ResponseEntity<String> getResponse2 =
            new ResponseEntity<>(getBody2, HttpStatus.OK);

    when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"fname\":\"" + outPath + "\",\"pname\":\"" + fileName + "\",\"sync\":\"YES\"}");

    when(objectMapper.readTree(postBody1))
            .thenReturn(new ObjectMapper().readTree(postBody1));
    when(objectMapper.readTree(postBody2))
            .thenReturn(new ObjectMapper().readTree(postBody2));

    when(objectMapper.readValue(eq(getBody1), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu1", "CANCELLED", 5, "first fail"));
    when(objectMapper.readValue(eq(getBody2), eq(TransferStatusResponse.class)))
            .thenReturn(status("idtu2", "CANCELLED", 7, "second fail"));

    when(restTemplate.exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST),
            any(HttpEntity.class), eq(String.class), any(Map.class))
    ).thenReturn(postResponse1, postResponse2);

    when(restTemplate.exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET),
            isNull(), eq(String.class), any(Map.class))
    ).thenReturn(getResponse1, getResponse2);

    assertThatThrownBy(() ->
            restApiClient.notifyAndWaitForCompletion(outPath, fileName, NO_WAIT)
    )
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("FAILED after retry");

    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl?"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class), any(Map.class));
    verify(restTemplate, times(2)).exchange(
            startsWith("baseUrl/transfers"), eq(HttpMethod.GET), isNull(), eq(String.class), any(Map.class));
}
```

---

### How this ties to batch failure

You don‚Äôt need a special Spring Batch test for failure: as long as your tasklet just calls:

```java
cftApiClient.notifyAndWaitForCompletion(...);
```

and doesn‚Äôt catch the `IllegalStateException`, the **step will fail**, and Spring Batch will mark the **job FAILED**.

So these unit tests:

* Prove the new logic (SENDING + double GET, retry once on CANCELLED/diagi‚â†0).
* Confirm that in the ‚Äúboth attempts fail‚Äù case, an exception is thrown ‚Üí which is exactly what you want to cause the batch to fail.
---------------=-=-=-=-=--------=-=-=-=-----------------







Right, that clarifies it:

* First GET after the wait returned `SENDING`,
* but the *real* outcome of the transfer later was **FAILED**,
* so you **must not** treat `SENDING` as success.
* You want: **POST ‚Üí wait ‚Üí GET ‚Üí if SENDING, wait again ‚Üí GET again**.
  Then decide success/failure from that final GET.

We can do this with **very small changes** to what we already designed:
üëâ at most **2 GETs per POST**, and still **one POST retry max**.

---

## 1. Updated logic per attempt (conceptually)

For *each* attempt (initial and retry):

1. `POST /transfers` ‚Üí get `idtu`
2. `sleep(waitTime)` (your size-based wait)
3. `GET /transfers/{idtu}` ‚Üí `status1`
4. If `status1.sentinel == SENDING` (and `diagi == 0`):

   * `sleep(waitTime)` **again**
   * `GET /transfers/{idtu}` ‚Üí `status2`
   * use `status2` as the **final status for this attempt**
5. Now look at final status:

   * If `sentinel = CANCELLED` **or** `diagi != 0` ‚Üí this attempt = **error**
   * If `sentinel = SENDING` again ‚Üí treat as **error** (it never finished in our window)
   * Otherwise (`COMPLETED`, `PRE_PROC`, etc. with `diagi == 0`) ‚Üí **success**

If the first attempt is an error ‚Üí **one more attempt** (POST+wait+GET(+optional second GET)).

---

## 2. Minimal code changes

I‚Äôll show only the **two places** to change compared to the previous version:

### 2.1. `doSingleAttempt`: add a *second* GET if first returns SENDING

```java
private TransferStatusResponse doSingleAttempt(String outPath,
                                               String fileName,
                                               Duration waitTime,
                                               int attempt) {
    try {
        // 1) POST
        String idtu = triggerTransferOnce(outPath, fileName, attempt);

        // 2) first WAIT
        if (!waitTime.isZero() && !waitTime.isNegative()) {
            log.info("Waiting {} ms before first status GET for idtu={}", waitTime.toMillis(), idtu);
            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before first CFT GET", e);
            }
        }

        // 3) first GET
        TransferStatusResponse status = getTransferStatus(idtu);
        log.info("First CFT status for idtu={} sentinel={} diagi={} diagnostic={}",
                 idtu, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

        // 4) If still SENDING, wait once more and GET again
        if ("SENDING".equalsIgnoreCase(status.getSentinel())
                && status.getDiagi() == 0) {

            log.info("CFT status is SENDING after first wait. Waiting {} ms again and re-checking...",
                     waitTime.toMillis());

            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before second CFT GET", e);
            }

            status = getTransferStatus(idtu);
            log.info("Second CFT status for idtu={} sentinel={} diagi={} diagnostic={}",
                     idtu, status.getSentinel(), status.getDiagi(), status.getDiagnostic());
        }

        // final status for this attempt
        return status;

    } catch (Exception ex) {
        throw new IllegalStateException("CFT POST/GET attempt " + attempt + " failed for file " + fileName, ex);
    }
}
```

So now:

* Each attempt does **one or two GETs**:

  * 1st GET after the wait
  * A **second** GET only if the first said `SENDING`

---

### 2.2. `isErrorStatus`: treat final `SENDING` as error

Previously we only treated `CANCELLED` and `diagi != 0` as error.
Now we also say: ‚Äúif it‚Äôs still SENDING after the second check ‚Üí treat as error‚Äù.

```java
private boolean isErrorStatus(TransferStatusResponse status) {
    String sentinel = status.getSentinel();
    int diagi = status.getDiagi();

    log.info("Final CFT status for decision: idtu={} sentinel={} diagi={} diagnostic={}",
             status.getIdtu(), sentinel, diagi, status.getDiagnostic());

    // business error conditions:
    // - CANCELLED
    // - any diagi != 0
    // - still SENDING after two waits (never reached a final state)
    if ("CANCELLED".equalsIgnoreCase(sentinel)
            || diagi != 0
            || "SENDING".equalsIgnoreCase(sentinel)) {
        return true;
    }

    // PRE_PROC, COMPLETED, etc. with diagi == 0 => OK
    return false;
}
```

**Why treat SENDING as error here?**

* At this point we‚Äôve already:

  * waited `waitTime`, did GET1 (SENDING),
  * waited another `waitTime`, did GET2, still SENDING.
* If it‚Äôs *still* SENDING, we don‚Äôt want to declare success.
  It‚Äôs safer to treat this as ‚Äúdid not finish ‚Üí error‚Äù so we either:

  * retry the POST once, or
  * fail the job, rather than silently saying ‚ÄúOK‚Äù while the transfer actually fails.

---

## 3. The retry logic itself stays the same

We keep the same `notifyAndWaitForCompletion` from before:

```java
public void notifyAndWaitForCompletion(String outPath,
                                       String fileName,
                                       Duration waitTime) {

    // FIRST attempt
    TransferStatusResponse status = doSingleAttempt(outPath, fileName, waitTime, 1);

    if (!isErrorStatus(status)) {
        log.info("CFT transfer SUCCESS on first attempt for file {} (sentinel={}, diagi={})",
                 fileName, status.getSentinel(), status.getDiagi());
        return;
    }

    log.warn("CFT transfer ERROR on first attempt for file {} ‚Äì sentinel={} diagi={} diagnostic={}. Retrying once...",
             fileName, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

    // SECOND (and last) attempt
    TransferStatusResponse status2 = doSingleAttempt(outPath, fileName, waitTime, 2);

    if (isErrorStatus(status2)) {
        throw new IllegalStateException(
                String.format("CFT transfer FAILED after retry for file %s. Last status: sentinel=%s diagi=%d diagnostic=%s",
                              fileName,
                              status2.getSentinel(),
                              status2.getDiagi(),
                              status2.getDiagnostic()));
    }

    log.info("CFT transfer SUCCESS on second attempt for file {} (sentinel={}, diagi={})",
             fileName, status2.getSentinel(), status2.getDiagi());
}
```

And your tasklet still just does:

```java
if (cftEnabled) {
    long bytes = encryptedFile.length();
    Duration waitTime = pickWaitByTier(bytes, waittime); // your ‚Äú6s + per MB‚Äù logic
    log.info("Payload size={} bytes. Using waitTime={} before CFT status checks.", bytes, waitTime);
    cftApiClient.notifyAndWaitForCompletion(key, encryptedFileName, waitTime);
}
```

---

## 4. What this fixes for your ‚ÄúSENDING but actually failed‚Äù case

With these tweaks:

* First `POST‚Üíwait‚ÜíGET` returns `SENDING` ‚Üí **not accepted** as final.
* We:

  * wait **again** for the same `waitTime`,
  * do a **second GET**,
  * now we see the true final state (e.g. `CANCELLED`, or `diagi != 0`).
* That final `CANCELLED` / error now:

  * marks the attempt as error,
  * triggers the **second POST attempt**, or
  * fails the job after the second attempt.

So you don‚Äôt falsely treat that initial `SENDING` as success anymore.

If you want, you can tell me roughly what your typical waitTime is (e.g. ‚Äú6s + 1s per MB‚Äù) and we could decide if the second wait should be the same, or a fixed small extra (say 5s). But the structure above already matches exactly what you described.
===================-=-=-==-=---------

Gotcha, that makes sense now üëç

You want a *much simpler* flow:

> **POST ‚Üí wait (size-based) ‚Üí single GET**
> If GET says `CANCELLED` (or error) ‚Üí do **one more** `POST ‚Üí wait ‚Üí GET`.
> No polling loop, no multiple GETs.

Also: `sentinel = PRE_PROC` should *not* be treated as a failure.

Let‚Äôs do this step by step and keep the code small and readable.

---

## 1. Desired behavior (in words)

For each file:

1. **First attempt**

   1. Call `POST /transfers` (your existing notify)
      ‚Æï response contains `idtu`.
   2. Wait for your **size-based duration** (e.g. `6s + X per MB`).
   3. Call **one** `GET /transfers/{idtu}`.
   4. Interpret result:

      * If `sentinel == "CANCELLED"` **or** `diagi != 0` ‚Üí treat as *error*.
      * Any other `sentinel` (`COMPLETED`, `PRE_PROC`, `SENDING`, ‚Ä¶) with `diagi == 0` ‚Üí treat as **success**.

2. **If first attempt is error** (`CANCELLED` or `diagi != 0`)
   ‚ûú Do **one more full attempt**:

   * `POST` again (new `idtu`)
   * wait again
   * `GET` once
   * If still error ‚Üí throw exception ‚Üí batch step fails.

So:

* ‚úÖ No multiple GETs per attempt (exactly one).
* ‚úÖ GET happens **only after** the wait.
* ‚úÖ `PRE_PROC` is considered OK as long as `diagi == 0`.
* ‚úÖ At most **2 POSTs** per file (initial + 1 retry).

---

## 2. DTO for GET `/transfers/{idtu}`

```java
public class TransferStatusResponse {

    private String idtu;
    private String sentinel;   // e.g. "COMPLETED", "PRE_PROC", "SENDING", "CANCELLED"
    private int diagi;         // 0 = OK
    private String diagnostic; // descriptive text

    // getters and setters
}
```

Adjust field names with `@JsonProperty` if needed.

---

## 3. Helper: GET status once

In your `CftApiClient`:

```java
private TransferStatusResponse getTransferStatus(String idtu) {
    String url = baseURL + "/transfers/{idtu}";   // adjust if needed

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("idtu", idtu);

    ResponseEntity<String> response =
            restTemplate.exchange(url, HttpMethod.GET, null, String.class, uriVariables);

    log.info("CFT GET status for idtu={} -> {}", idtu, response.getStatusCode());
    log.debug("CFT GET body: {}", response.getBody());

    try {
        return objectMapper.readValue(response.getBody(), TransferStatusResponse.class);
    } catch (Exception e) {
        throw new IllegalStateException("Failed to parse CFT status for idtu=" + idtu, e);
    }
}
```

---

## 4. Helper: POST once and return `idtu`

This is basically your current POST, wrapped:

```java
private String triggerTransferOnce(String outPath, String fileName, int attempt) throws Exception {
    String apiUrl = baseURL + "?part={part}&idtf={idtf}";

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);

    Map<String, String> requestBody = new HashMap<>();
    requestBody.put("fname", outPath);
    requestBody.put("pname", fileName);
    requestBody.put("sync", "YES");

    String jsonPayload = objectMapper.writeValueAsString(requestBody);
    HttpEntity<String> requestEntity = new HttpEntity<>(jsonPayload, headers);

    Map<String, String> uriVariables = new HashMap<>();
    uriVariables.put("part", destPART);
    uriVariables.put("idtf", destIDF);

    log.info("Sending CFT POST attempt {} to: {}", attempt, apiUrl);
    log.info("Headers: {}", headers);
    log.info("Body   : {}", requestBody);

    ResponseEntity<String> response =
            restTemplate.exchange(apiUrl, HttpMethod.POST, requestEntity,
                                  String.class, uriVariables);

    log.info("CFT POST attempt {} status: {}", attempt, response.getStatusCode());
    log.info("CFT POST attempt {} body  : {}", attempt, response.getBody());

    JsonNode root = objectMapper.readTree(response.getBody());
    String idtu = root.path("idtu").asText(null);   // adjust field name if needed

    if (idtu == null || idtu.isEmpty()) {
        throw new IllegalStateException("CFT POST response did not contain idtu (attempt " + attempt + ")");
    }

    return idtu;
}
```

---

## 5. Helper: evaluate if this status is an **error**

You said: *‚Äúretry POST request once again in case of error if (`sentinel = CANCELLED` or `diagi != 0`)‚Äù*.

```java
private boolean isErrorStatus(TransferStatusResponse status) {
    String sentinel = status.getSentinel();
    int diagi = status.getDiagi();

    // log always, for visibility
    log.info("CFT status: idtu={} sentinel={} diagi={} diagnostic={}",
             status.getIdtu(), sentinel, diagi, status.getDiagnostic());

    // Only treat CANCELLED or diagi != 0 as errors
    if ("CANCELLED".equalsIgnoreCase(sentinel) || diagi != 0) {
        return true;
    }

    // PRE_PROC, COMPLETED, SENDING with diagi==0 are considered OK
    return false;
}
```

So your `PRE_PROC` case with `diagi == 0` becomes **success** ‚úÖ

---

## 6. Single attempt: POST ‚Üí wait ‚Üí GET ‚Üí decide

```java
private TransferStatusResponse doSingleAttempt(String outPath,
                                               String fileName,
                                               Duration waitTime,
                                               int attempt) {
    try {
        // 1) POST
        String idtu = triggerTransferOnce(outPath, fileName, attempt);

        // 2) WAIT based on file size (you pass this in)
        if (!waitTime.isZero() && !waitTime.isNegative()) {
            log.info("Waiting {} ms before status GET for idtu={}", waitTime.toMillis(), idtu);
            try {
                Thread.sleep(waitTime.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException("Interrupted while waiting before CFT GET", e);
            }
        }

        // 3) GET once
        TransferStatusResponse status = getTransferStatus(idtu);
        return status;

    } catch (Exception ex) {
        throw new IllegalStateException("CFT POST/GET attempt " + attempt + " failed for file " + fileName, ex);
    }
}
```

Note: **GET is now called only after the wait**, exactly as you asked.

---

## 7. Public method: retry POST+WAIT+GET once on error

```java
public void notifyAndWaitForCompletion(String outPath,
                                       String fileName,
                                       Duration waitTime) {

    // FIRST attempt
    TransferStatusResponse status = doSingleAttempt(outPath, fileName, waitTime, 1);

    if (!isErrorStatus(status)) {
        // OK: sentinel != CANCELLED and diagi == 0 (COMPLETED, PRE_PROC, SENDING, etc.)
        log.info("CFT transfer considered SUCCESS on first attempt for file {} (sentinel={}, diagi={})",
                 fileName, status.getSentinel(), status.getDiagi());
        return;
    }

    // We are in the error scenario: CANCELLED or diagi != 0
    log.warn("CFT transfer ERROR on first attempt for file {} ‚Äì sentinel={} diagi={} diagnostic={}. Retrying once...",
             fileName, status.getSentinel(), status.getDiagi(), status.getDiagnostic());

    // SECOND (and last) attempt
    TransferStatusResponse status2 = doSingleAttempt(outPath, fileName, waitTime, 2);

    if (isErrorStatus(status2)) {
        // still error ‚Üí fail the batch
        throw new IllegalStateException(
                String.format("CFT transfer FAILED after retry for file %s. Last status: sentinel=%s diagi=%d diagnostic=%s",
                              fileName,
                              status2.getSentinel(),
                              status2.getDiagi(),
                              status2.getDiagnostic()));
    }

    log.info("CFT transfer considered SUCCESS on second attempt for file {} (sentinel={}, diagi={})",
             fileName, status2.getSentinel(), status2.getDiagi());
}
```

---

## 8. How your tasklet calls it

Back in `PackageAndUploadFilesTasklet`, you already compute a wait based on file size.

Where you had:

```java
if (cftEnabled) {
    // old: notifyUpload(...) + Thread.sleep(...) here
}
```

Change to:

```java
if (cftEnabled) {
    long bytes = encryptedFile.length();
    Duration waitTime = pickWaitByTier(bytes, waittime);  // your existing size-based logic

    log.info("Payload size={} bytes. Using waitTime={} before CFT status GET.", bytes, waitTime);
    cftApiClient.notifyAndWaitForCompletion(key, encryptedFileName, waitTime);
}
```

---

### Summary

* We removed the polling loop and **multiple GETs**.
* We now strictly do: **POST ‚Üí wait ‚Üí GET once**.
* We only treat `sentinel = CANCELLED` or `diagi != 0` as error ‚Üí triggers a **second full attempt** (POST+wait+GET).
* `sentinel = PRE_PROC` with `diagi == 0` is treated as **success**, same for `COMPLETED`, `SENDING`, etc.
* GET is **only** called after your size-based wait.

If you paste a sample actual GET JSON (with `PRE_PROC`), I can double-check the field names so you don‚Äôt get parsing surprises.
