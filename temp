Below is a **final, copy-paste JUnit 5 test class** that drives your `moveAttachments(...)` method to **high line + branch coverage** (typically ~90%+), while staying Sonar-friendly (no excessive `continue/break` concerns in tests, and no Mockito `eq()`).

It covers:

✅ happy path (multiple attachments + different extensions)
✅ case-insensitive matching
✅ ignores the XML itself
✅ ignores non-regular files
✅ `uniqueIfExists(...)` path when destination already exists
✅ early returns (blank args / null targetDir / missing sourceDir)
✅ exception branch deterministically (targetDir is a file → `createDirectories` fails)

> Assumption: your production class is `SplitAttachmentMover` and it has `PathConfig pathConfig`, and `pathConfig.getUnzipped().getXml()` returns the source folder for unzipped XML+attachments (as in your screenshots).

---

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class SplitAttachmentMoverTest {

    @TempDir
    Path tempDir;

    private Path sourceDir;
    private Path targetDir;

    private PathConfig pathConfig;
    private SplitAttachmentMover mover;

    @BeforeEach
    void setUp() throws IOException {
        sourceDir = Files.createDirectory(tempDir.resolve("unzippedXml"));
        targetDir = Files.createDirectory(tempDir.resolve("out"));

        // Mockito mock PathConfig + Unzipped to point to our @TempDir sourceDir
        pathConfig = Mockito.mock(PathConfig.class);
        PathConfig.Unzipped unzipped = Mockito.mock(PathConfig.Unzipped.class);

        Mockito.when(pathConfig.getUnzipped()).thenReturn(unzipped);
        Mockito.when(unzipped.getXml()).thenReturn(sourceDir);

        mover = new SplitAttachmentMover(pathConfig);
    }

    @Test
    void moveAttachments_copiesMultipleMatchingAttachments_andRenamesToOutputBase() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-1.pdf", "pdf1");
        write(sourceDir, "A-2.jpeg", "img2");
        write(sourceDir, "B-1.pdf", "other");

        List<Path> moved = mover.moveAttachments("A", "NEWNAME_INV_123.xml", targetDir);

        assertEquals(2, moved.size());
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123-1.pdf")));
        assertTrue(Files.exists(targetDir.resolve("NEWNAME_INV_123-2.jpeg")));
        assertFalse(Files.exists(targetDir.resolve("NEWNAME_INV_123-1.pdf-2")));
        assertFalse(Files.exists(targetDir.resolve("B-1.pdf")));
    }

    @Test
    void moveAttachments_matchesCaseInsensitive() throws Exception {
        write(sourceDir, "a.XML", "<xml/>");
        write(sourceDir, "A-1.PDF", "pdf");

        List<Path> moved = mover.moveAttachments("a", "out.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("out-1.PDF")));
    }

    @Test
    void moveAttachments_ignoresNonRegularFiles() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        Files.createDirectory(sourceDir.resolve("A-1.pdf")); // directory, not a file

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_createsUniqueNameIfTargetExists() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-1.pdf", "pdf");

        // pre-create destination to force uniqueIfExists()
        write(targetDir, "OUT-1.pdf", "existing");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertEquals(1, moved.size());
        assertTrue(Files.exists(targetDir.resolve("OUT-1-2.pdf")));
    }

    @Test
    void moveAttachments_returnsEmptyList_whenNoAttachmentsPresent() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertNotNull(moved);
        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenInputsInvalid() throws Exception {
        // blank xmlBaseName
        List<Path> moved1 = mover.moveAttachments(" ", "OUT.xml", targetDir);
        assertTrue(moved1.isEmpty());

        // blank outputXmlFileName
        List<Path> moved2 = mover.moveAttachments("A", " ", targetDir);
        assertTrue(moved2.isEmpty());

        // null targetDir
        List<Path> moved3 = mover.moveAttachments("A", "OUT.xml", null);
        assertTrue(moved3.isEmpty());
    }

    @Test
    void moveAttachments_returnsEmptyList_whenSourceDirMissing() throws Exception {
        // Point sourceDir to a non-directory (file) to hit "sourceDir missing" branch
        Path fileInsteadOfDir = write(tempDir, "notADir.txt", "x");
        PathConfig.Unzipped unzipped = pathConfig.getUnzipped();
        Mockito.when(unzipped.getXml()).thenReturn(fileInsteadOfDir);

        List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetDir);

        assertTrue(moved.isEmpty());
    }

    @Test
    void moveAttachments_handlesIOException_andDoesNotThrow() throws Exception {
        write(sourceDir, "A.xml", "<xml/>");
        write(sourceDir, "A-1.pdf", "pdf");

        // deterministic IOException: pass a path that is a FILE as targetDir
        Path targetIsFile = write(tempDir, "targetFile", "x");

        assertDoesNotThrow(() -> {
            List<Path> moved = mover.moveAttachments("A", "OUT.xml", targetIsFile);
            assertTrue(moved.isEmpty());
        });
    }

    private static Path write(Path dir, String name, String content) throws IOException {
        Path p = dir.resolve(name);
        Files.writeString(p, content);
        return p;
    }
}
```

---

### Notes (so it compiles in your project)

* Replace `PathConfig.Unzipped` with the **actual nested/inner type** you have (from your codebase).
  If it’s a separate class (e.g., `UnzippedConfig`), just adjust the mock type accordingly.
* The tests don’t use `eq()` anywhere.

If you paste your `PathConfig` (just the signatures of `getUnzipped()` and the type it returns), I can tailor the mocks so this compiles **exactly** with your classes without you editing anything.
