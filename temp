Here’s a clean, copy-pasteable version of the final “bundle + skip listener” setup that’s in AC_1_Dec, with all the pieces you need in one place.

I’m **not** touching your existing CSV reader / XML writer / PathConfig / CosStorageService / PGPDecrypt logic. Where you already have an implementation (decrypt, unzip, validate), I just call your existing methods.

---

## 1. Bundle model

```java
// package com.bnpp.pf.einvoice.connect.batch.model;

import java.io.File;
import java.nio.file.Path;

public class InvoiceBundle {

    private final String baseName;             // e.g. invoice_123
    private final File pgpFile;               // local .zip.pgp
    private final File zipFile;               // local .zip
    private final Path xmlPath;               // extracted XML
    private final Path pdfPath;               // extracted PDF
    private final String processedPgpCosKey;  // processed/<file>.zip.pgp in COS

    public InvoiceBundle(String baseName,
                         File pgpFile,
                         File zipFile,
                         Path xmlPath,
                         Path pdfPath,
                         String processedPgpCosKey) {
        this.baseName = baseName;
        this.pgpFile = pgpFile;
        this.zipFile = zipFile;
        this.xmlPath = xmlPath;
        this.pdfPath = pdfPath;
        this.processedPgpCosKey = processedPgpCosKey;
    }

    public String getBaseName() {
        return baseName;
    }

    public File getPgpFile() {
        return pgpFile;
    }

    public File getZipFile() {
        return zipFile;
    }

    public Path getXmlPath() {
        return xmlPath;
    }

    public Path getPdfPath() {
        return pdfPath;
    }

    public String getProcessedPgpCosKey() {
        return processedPgpCosKey;
    }
}
```

---

## 2. FetchDecryptUnzipTasklet – EARLY extraction + register bundles

This replaces the `execute` of your existing `FetchDecryptUnzipTasklet`.
Keep your existing `decryptFile(...)`, `extract(...)`, `validateFile(...)` bodies.

```java
// package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.batch.cos.CosProcessedContextSupport;
import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.config.PathConfig;
import com.bnpp.pf.einvoice.connect.service.CosStorageService;
import com.bnpp.pf.einvoice.connect.service.PGPDecrypt;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

@Component
@StepScope
public class FetchDecryptUnzipTasklet
        implements Tasklet, StepExecutionListener, CosProcessedContextSupport {

    private final CosStorageService cosStorageService;
    private final PGPDecrypt pgpDecrypt;
    private final PathConfig pathConfig;

    private StepExecution stepExecution;

    @Value("#{jobParameters['jobType'] ?: 'xml'}")
    private String jobType; // "xml" or "csv"

    // COS prefix where processed PGP files live, adapt if needed
    private final String processedPrefix = "processed/";

    public FetchDecryptUnzipTasklet(CosStorageService cosStorageService,
                                    PGPDecrypt pgpDecrypt,
                                    PathConfig pathConfig) {
        this.cosStorageService = cosStorageService;
        this.pgpDecrypt = pgpDecrypt;
        this.pathConfig = pathConfig;
    }

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        // 1. Fetch encrypted .zip.pgp files from COS into local temp
        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);

        List<InvoiceBundle> bundles = new ArrayList<>();

        Path unzippedBaseDir = pathConfig.getUnzipped(); // e.g. ${java.io.tmpdir}/alphacredit/unzipped
        Files.createDirectories(unzippedBaseDir);

        for (File pgpFile : encryptedFiles) {
            String fileName = pgpFile.getName();       // e.g. something.zip.pgp (name may not match XML/PDF)
            String baseName = fileName.replaceFirst("\\.zip\\.pgp$", "");
            String processedPgpKey = processedPrefix + fileName;

            try {
                // 2. Decrypt → .zip
                File zipFile = decryptFile(pgpFile);   // use your existing implementation

                // 3. Extract XML + PDF into a bundle-specific directory
                Path bundleOutDir = unzippedBaseDir.resolve(baseName);
                Files.createDirectories(bundleOutDir);

                // Your existing unzip method; just change target dir to bundleOutDir
                extract(zipFile.toPath(), bundleOutDir);

                // 4. Locate XML and PDF (same name or not, we do not care here)
                Path xmlPath = null;
                Path pdfPath = null;

                try (Stream<Path> walk = Files.walk(bundleOutDir, 1)) {
                    for (Path p : (Iterable<Path>) walk::iterator) {
                        if (Files.isRegularFile(p)) {
                            String n = p.getFileName().toString().toLowerCase();
                            if (n.endsWith(".xml")) {
                                xmlPath = p;
                            } else if (n.endsWith(".pdf")) {
                                pdfPath = p;
                            }
                        }
                    }
                }

                // 5. Your existing validation (null checks, etc.)
                validateFile(xmlPath, pdfPath);

                // 6. Build bundle
                InvoiceBundle bundle =
                        new InvoiceBundle(baseName, pgpFile, zipFile, xmlPath, pdfPath, processedPgpKey);
                bundles.add(bundle);

                // 7. Register processed COS key for later cleanup
                addProcessedKey(stepExecution, processedPgpKey);

            } catch (Exception e) {
                // Any failure during decrypt/unzip/validate → move .zip.pgp to FAILED in COS
                moveToFailedInCos(processedPgpKey, pgpFile);
                // Do NOT fail the tasklet; continue with the next file
            }
        }

        // 8. Store bundles list into JobExecutionContext for the reader
        ExecutionContext jobCtx = stepExecution.getJobExecution().getExecutionContext();
        jobCtx.put("invoiceBundles", bundles);

        return RepeatStatus.FINISHED;
    }

    private void moveToFailedInCos(String processedPgpKey, File pgpFile) {
        try {
            String failedPgpKey = processedPgpKey.replaceFirst("^processed/", "failed/");
            cosStorageService.moveFile(processedPgpKey, failedPgpKey);
            // optional: also upload decrypted zip here if you want, but we usually do that in the SkipListener
        } catch (Exception ex) {
            // log if you like
        }
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    // ---------------------------------------------------------
    // Keep your existing implementations of these methods
    // (I only show signatures so this compiles)
    // ---------------------------------------------------------

    private File decryptFile(File pgpFile) throws IOException {
        // Use your existing decrypt implementation:
        // - create decrypted File (strip .pgp)
        // - pgpDecrypt.decrypt(InputStream, OutputStream)
        // - return decrypted File
        throw new UnsupportedOperationException("Use your existing decryptFile implementation here");
    }

    private void extract(Path zipFile, Path targetDir) throws IOException {
        // Use your existing safe unzip implementation that extracts zipFile into targetDir
        throw new UnsupportedOperationException("Use your existing extract implementation here");
    }

    private void validateFile(Path xmlPath, Path pdfPath) {
        // Use your existing validation for "one XML + one PDF present" etc.
        // Throw an exception if invalid.
        throw new UnsupportedOperationException("Use your existing validateFile implementation here");
    }
}
```

> In your project, replace the `throw new UnsupportedOperationException(...)` bodies with the current bodies from your existing `FetchDecryptUnzipTasklet` methods.

---

## 3. Bundle reader – read from job context

```java
// package com.bnpp.pf.einvoice.connect.batch.reader;

import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemReader;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.List;

@Component
@StepScope
public class InvoiceBundleItemReader
        implements ItemReader<InvoiceBundle>, StepExecutionListener {

    private Iterator<InvoiceBundle> iterator;

    @Override
    @SuppressWarnings("unchecked")
    public void beforeStep(StepExecution stepExecution) {
        JobExecution jobExecution = stepExecution.getJobExecution();
        List<InvoiceBundle> bundles =
                (List<InvoiceBundle>) jobExecution.getExecutionContext().get("invoiceBundles");
        this.iterator = (bundles != null ? bundles.iterator() : List.<InvoiceBundle>of().iterator());
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    @Override
    public InvoiceBundle read() {
        if (iterator != null && iterator.hasNext()) {
            return iterator.next();
        }
        return null; // end of stream
    }
}
```

---

## 4. BundleValidationException

```java
// package com.bnpp.pf.einvoice.connect.batch.exception;

public class BundleValidationException extends Exception {

    public BundleValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## 5. Processor – XSD validation on XML

This is where XML is validated. If invalid, we throw `BundleValidationException`, which Spring Batch will treat as skippable.

```java
// package com.bnpp.pf.einvoice.connect.batch.processor;

import com.bnpp.pf.einvoice.connect.batch.exception.BundleValidationException;
import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import org.springframework.batch.item.ItemProcessor;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import java.nio.file.Files;

public class InvoiceBundleProcessor implements ItemProcessor<InvoiceBundle, Object> {

    private final Unmarshaller unmarshaller;
    private final Schema schema;

    public InvoiceBundleProcessor() throws Exception {
        // Adapt: use your actual UBL classes
        JAXBContext jaxbContext = JAXBContext.newInstance(
                oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class,
                oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class
        );
        this.unmarshaller = jaxbContext.createUnmarshaller();

        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
        // Adjust XSD location to your setup
        this.schema = sf.newSchema(getClass().getResource("/xsd/UBL-Invoice-2.1.xsd"));
        this.unmarshaller.setSchema(schema);
    }

    @Override
    public Object process(InvoiceBundle bundle) throws Exception {
        try (var in = Files.newInputStream(bundle.getXmlPath())) {
            // XSD validation happens because schema is attached to unmarshaller
            Object ubl = unmarshaller.unmarshal(new StreamSource(in));
            // You can return InvoiceType / CreditNoteType or map to your DTO if writer expects something else.
            return ubl;
        } catch (Exception e) {
            // Tell Spring Batch to skip this bundle
            throw new BundleValidationException("XML validation failed for " + bundle.getBaseName(), e);
        }
    }
}
```

---

## 6. SkipListener – move .zip.pgp + .zip to FAILED on skip

This is the piece you were focusing on: **based on the item** (the bundle) we move the COS files when the processor fails (invalid XML). The item is **never null** in `onSkipInProcess`.

```java
// package com.bnpp.pf.einvoice.connect.batch.listener;

import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.service.CosStorageService;
import org.springframework.batch.core.SkipListener;

import java.io.File;

public class InvoiceBundleSkipListener implements SkipListener<InvoiceBundle, Object> {

    private final CosStorageService cosStorageService;
    private final String failedPrefix = "failed/"; // adjust if needed

    public InvoiceBundleSkipListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        // nothing – no item available here, so we cannot know which file to move
    }

    @Override
    public void onSkipInProcess(InvoiceBundle bundle, Throwable t) {
        // XML invalid → move both .zip.pgp + decrypted .zip to FAILED
        try {
            String processedPgpKey = bundle.getProcessedPgpCosKey();
            String failedPgpKey = processedPgpKey.replaceFirst("^processed/", failedPrefix);

            // Move PGP in COS: processed/<file>.zip.pgp → failed/<file>.zip.pgp
            cosStorageService.moveFile(processedPgpKey, failedPgpKey);

            // Also upload the decrypted zip to FAILED
            File zipFile = bundle.getZipFile();
            if (zipFile != null && zipFile.exists()) {
                cosStorageService.uploadFile(failedPrefix, zipFile); // FAILED/<zipFile.getName()>
            }

        } catch (Exception ex) {
            // log if you want, but do not fail the batch
        }
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        // optional – you can log here if you want
    }
}
```

Note: this does not depend on XML/PDF file names matching the `.zip.pgp`. We always move the COS object for the PGP using the key recorded in the bundle.

---

## 7. Step configuration – wire everything together

Finally, the step that consumes bundles:

```java
// package com.bnpp.pf.einvoice.connect.batch.config;

import com.bnpp.pf.einvoice.connect.batch.exception.BundleValidationException;
import com.bnpp.pf.einvoice.connect.batch.listener.InvoiceBundleSkipListener;
import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.batch.processor.InvoiceBundleProcessor;
import com.bnpp.pf.einvoice.connect.batch.reader.InvoiceBundleItemReader;
import com.bnpp.pf.einvoice.connect.service.CosStorageService;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemWriter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
public class BundleProcessingStepConfig {

    @Bean
    public InvoiceBundleProcessor invoiceBundleProcessor() throws Exception {
        return new InvoiceBundleProcessor();
    }

    @Bean
    public Step processBundlesStep(JobRepository jobRepository,
                                   PlatformTransactionManager transactionManager,
                                   InvoiceBundleItemReader bundleReader,
                                   InvoiceBundleProcessor bundleProcessor,
                                   ItemWriter<Object> xmlWriter,      // your existing XML writer
                                   CosStorageService cosStorageService) {

        return new StepBuilder("processBundlesStep", jobRepository)
                .<InvoiceBundle, Object>chunk(10, transactionManager)
                .reader(bundleReader)
                .processor(bundleProcessor)
                .writer(xmlWriter)
                .faultTolerant()
                .skip(BundleValidationException.class)
                .skipLimit(Integer.MAX_VALUE)
                .listener(new InvoiceBundleSkipListener(cosStorageService))
                .build();
    }
}
```

You then plug `processBundlesStep` into your job (instead of directly reading XML files from the unzip directory).

---

If you paste these classes in and swap the three `UnsupportedOperationException` bodies with your existing decrypt / unzip / validate logic, you’ll have:

* early decrypt + unzip
* per-bundle identity (so `item` in the listener tells you exactly which COS keys to move)
* skip-on-XML-failure with `.zip.pgp` + `.zip` moved to `failed/`
* your existing writer untouched.


------------------df-dfd-fd-fd-----
Here’s how I’d adapt your existing FetchDecryptUnzipTasklet without touching the Fortify-fixed extract(...) logic.
I’ll keep your unzip code as is and only add the minimal lines for:
	•	per-file “bundle failed → move .zip.pgp + .zip to COS/failed”
	•	still using your safe extract(...), validateFile(...), getOutputPath(...).

I’ll show the whole class so you can copy–paste, and I’ll mark only the new/changed bits with // NEW comments.

@Slf4j
public class FetchDecryptUnzipTasklet implements Tasklet, StepExecutionListener {

    @Value("#{jobParameters['jobType']}")
    private String jobType;

    private final CosStorageService cosStorageService;
    private final PGPDecrypt pgpDecrypt;
    private final PathConfig pathConfig;

    private StepExecution stepExecution;

    public FetchDecryptUnzipTasklet(CosStorageService cosStorageService,
                                    PGPDecrypt pgpDecrypt,
                                    PathConfig pathConfig) {
        this.cosStorageService = cosStorageService;
        this.pgpDecrypt = pgpDecrypt;
        this.pathConfig = pathConfig;
    }

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution,
                                ChunkContext chunkContext) {
        log.info("FetchDecryptUnzipTasklet started");

        try {
            List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
            if (encryptedFiles.isEmpty()) {
                log.info("No encrypted files found for jobType={}", jobType);
                return RepeatStatus.FINISHED;
            }

            for (File encrypted : encryptedFiles) {
                String encryptedName = encrypted.getName();
                log.info("Encrypted file name and job type: {} | {}", encryptedName, jobType);

                // base dir already Fortify-fixed in your PathConfig
                StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

                try {
                    // ─────────────────────────────────────────────
                    //  PER-BUNDLE TRY/CATCH – if *anything* fails,
                    //  we move .zip.pgp + .zip to COS/failed
                    // ─────────────────────────────────────────────
                    File decryptedZip;

                    if ("csv".equals(jobType) && encryptedName.contains("_csv")) {
                        stepExecution.getJobExecution().getExecutionContext().put("hasCsv", Boolean.TRUE);
                        addProcessedKey(stepExecution, encryptedName);         // optional if you track keys
                        decryptedZip = decryptFile(encrypted);
                        extract(decryptedZip.toPath(),
                                Paths.get(unzipBaseDir.append("/csv").toString()));

                    } else if ("xml".equals(jobType)
                            && encryptedName.toLowerCase().contains("_xml")) {

                        stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                        addProcessedKey(stepExecution, encryptedName);         // optional if you track keys
                        decryptedZip = decryptFile(encrypted);
                        extract(decryptedZip.toPath(),
                                Paths.get(unzipBaseDir.append("/xml").toString()));

                    } else {
                        log.info("Job type and file type is NOT a match, skipping decrypt for {}", encryptedName);
                        continue;
                    }

                } catch (Exception bundleEx) {  // NEW – per-file failure
                    log.error("Bundle failed for {} - moving to COS/failed. Error={}",
                              encryptedName, bundleEx.getMessage());

                    // 1) move original .zip.pgp from processed → failed
                    try {
                        String sourceKey = "processed/" + encryptedName;   // same key you used when fetching
                        String failedKey  = "failed/" + encryptedName;
                        cosStorageService.moveFile(sourceKey, failedKey);
                    } catch (Exception ignored) {
                        log.warn("Failed to move encrypted file {} to failed", encryptedName);
                    }

                    // 2) also upload decrypted .zip to failed (if it exists locally)
                    try {
                        File zipFile = new File(encrypted.getParent(),
                                                encryptedName.replace(".pgp", ""));
                        if (zipFile.exists()) {
                            String failedZipKey = "failed/" + zipFile.getName();
                            cosStorageService.uploadFile(failedZipKey, zipFile);
                        }
                    } catch (Exception ignored) {
                        log.warn("Failed to upload decrypted zip for {} to failed", encryptedName);
                    }

                    // continue with next file – we do NOT fail the whole batch
                }
            }

        } catch (Exception e) {
            log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
            throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
        }

        log.info("FetchDecryptUnzipTasklet completed");
        return RepeatStatus.FINISHED;
    }

    // ─────────────────────────────────────────────────────
    //  Your existing decryptFile(...) – unchanged
    // ─────────────────────────────────────────────────────
    private File decryptFile(File encryptedFile) throws IOException {
        log.info("Decrypt file started");
        log.info("Decrypting file: {}", encryptedFile.getAbsolutePath());

        File decrypted = new File(
                encryptedFile.getParentFile(),
                encryptedFile.getName().replace(".pgp", "")
        );

        pgpDecrypt.decrypt(new FileInputStream(encryptedFile),
                           new FileOutputStream(decrypted));

        log.info("Decrypt file completed: {}", decrypted.getName());
        return decrypted;
    }

    // ─────────────────────────────────────────────────────
    //  Your Fortify-fixed extract(...) – kept AS IS
    // ─────────────────────────────────────────────────────
    public static void extract(Path zipFile, Path targetDir) throws IOException {

        validateFile(zipFile, targetDir); // your existing validation

        Files.createDirectories(targetDir);
        Path canonicalTarget = targetDir.toRealPath(LinkOption.NOFOLLOW_LINKS);

        final int MAX_ENTRIES      = 10_000;
        final long MAX_ENTRY_SIZE  = 100_000_000L; // 100 MB per file
        final long MAX_TOTAL_SIZE  = 1_000_000_000L; // 1 GB total

        long totalSize = 0L;
        int entryCount = 0;

        try (ZipFile zip = ZipFile.builder()
                .setFile(zipFile.toFile())
                .setCharset(StandardCharsets.UTF_8)
                .get()) {

            Enumeration<ZipArchiveEntry> entries = zip.getEntries();

            while (entries.hasMoreElements()) {
                ZipArchiveEntry entry = entries.nextElement();
                if (entry.isDirectory()) {
                    continue;
                }

                Path outputPath = getOutputPath(entry, canonicalTarget);
                Files.createDirectories(outputPath.getParent());

                long entryBytes = 0L;
                int bytesRead;
                byte[] buffer = new byte[4096];

                try (InputStream is = zip.getInputStream(entry);
                     OutputStream os = new BufferedOutputStream(
                             Files.newOutputStream(outputPath,
                                                   StandardOpenOption.CREATE,
                                                   StandardOpenOption.TRUNCATE_EXISTING))) {

                    while ((bytesRead = is.read(buffer)) != -1) {
                        os.write(buffer, 0, bytesRead);
                        entryBytes += bytesRead;
                    }

                    if (entryBytes > MAX_ENTRY_SIZE) {
                        throw new InvoiceProcessingException("Entry too large: " + entry.getName());
                    }
                    if (totalSize + entryBytes > MAX_TOTAL_SIZE) {
                        throw new InvoiceProcessingException("Archive too large");
                    }
                }

                totalSize += entryBytes;
                entryCount++;

                if (entryCount > MAX_ENTRIES) {
                    throw new InvoiceProcessingException("Too many entries in archive");
                }

                log.info("Extracted {} ({} bytes)", entry.getName(), entryBytes);
            }
        }

        log.info("Extraction completed: {} entries, {} bytes total", entryCount, totalSize);
    }

    // your existing validateFile(...) – unchanged
    private static void validateFile(Path zipFile, Path targetDir) {
        if (zipFile == null || targetDir == null) {
            throw new InvoiceProcessingException("Invalid arguments: zipFile or targetDir is null");
        }
        if (!Files.isReadable(zipFile) || !Files.isRegularFile(zipFile)) {
            throw new InvoiceProcessingException("ZIP file not found or not readable: " + zipFile);
        }
    }

    // your existing getOutputPath(...) – unchanged
    static Path getOutputPath(ZipArchiveEntry entry, Path canonicalTarget) {
        String name = entry.getName() == null ? null
                : entry.getName().replace('\\', '/');

        if (name == null || name.isBlank()
                || name.contains("..")
                || name.startsWith("/")
                || name.startsWith("\\")) {
            throw new InvoiceProcessingException("Unsafe entry name: " + name);
        }

        Path outputPath = canonicalTarget.resolve(name).normalize();
        if (!outputPath.startsWith(canonicalTarget)) {
            throw new InvoiceProcessingException("Entry escapes target directory: " + name);
        }
        return outputPath;
    }
}

What this gives you
	•	Fortify-safe unzip: extract, validateFile, getOutputPath are exactly your hardened version.
	•	Per-file failure handling:
	•	If decrypt or extract fails → we do not fail the batch.
	•	We move processed/<name>.zip.pgp to failed/<name>.zip.pgp.
	•	We also upload local <name>.zip to failed/<name>.zip if it exists.
	•	Good bundles continue: good files still decrypt + extract and flow into your existing XML / credit-note pipeline.

If you paste your exact field names for pathConfig.getUnzipped() or your COS key prefixes are slightly different, just adjust the "processed/" / "failed/" strings, but the structure above will drop straight into your current class.





------------------////----------fdd-f----------
Here’s a clean, copy-pasteable version of the final “bundle + skip listener” setup that’s in AC_1_Dec, with all the pieces you need in one place.

I’m **not** touching your existing CSV reader / XML writer / PathConfig / CosStorageService / PGPDecrypt logic. Where you already have an implementation (decrypt, unzip, validate), I just call your existing methods.

---

## 1. Bundle model

```java
// package com.bnpp.pf.einvoice.connect.batch.model;

import java.io.File;
import java.nio.file.Path;

public class InvoiceBundle {

    private final String baseName;             // e.g. invoice_123
    private final File pgpFile;               // local .zip.pgp
    private final File zipFile;               // local .zip
    private final Path xmlPath;               // extracted XML
    private final Path pdfPath;               // extracted PDF
    private final String processedPgpCosKey;  // processed/<file>.zip.pgp in COS

    public InvoiceBundle(String baseName,
                         File pgpFile,
                         File zipFile,
                         Path xmlPath,
                         Path pdfPath,
                         String processedPgpCosKey) {
        this.baseName = baseName;
        this.pgpFile = pgpFile;
        this.zipFile = zipFile;
        this.xmlPath = xmlPath;
        this.pdfPath = pdfPath;
        this.processedPgpCosKey = processedPgpCosKey;
    }

    public String getBaseName() {
        return baseName;
    }

    public File getPgpFile() {
        return pgpFile;
    }

    public File getZipFile() {
        return zipFile;
    }

    public Path getXmlPath() {
        return xmlPath;
    }

    public Path getPdfPath() {
        return pdfPath;
    }

    public String getProcessedPgpCosKey() {
        return processedPgpCosKey;
    }
}
```

---

## 2. FetchDecryptUnzipTasklet – EARLY extraction + register bundles

This replaces the `execute` of your existing `FetchDecryptUnzipTasklet`.
Keep your existing `decryptFile(...)`, `extract(...)`, `validateFile(...)` bodies.

```java
// package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.batch.cos.CosProcessedContextSupport;
import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.config.PathConfig;
import com.bnpp.pf.einvoice.connect.service.CosStorageService;
import com.bnpp.pf.einvoice.connect.service.PGPDecrypt;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

@Component
@StepScope
public class FetchDecryptUnzipTasklet
        implements Tasklet, StepExecutionListener, CosProcessedContextSupport {

    private final CosStorageService cosStorageService;
    private final PGPDecrypt pgpDecrypt;
    private final PathConfig pathConfig;

    private StepExecution stepExecution;

    @Value("#{jobParameters['jobType'] ?: 'xml'}")
    private String jobType; // "xml" or "csv"

    // COS prefix where processed PGP files live, adapt if needed
    private final String processedPrefix = "processed/";

    public FetchDecryptUnzipTasklet(CosStorageService cosStorageService,
                                    PGPDecrypt pgpDecrypt,
                                    PathConfig pathConfig) {
        this.cosStorageService = cosStorageService;
        this.pgpDecrypt = pgpDecrypt;
        this.pathConfig = pathConfig;
    }

    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        // 1. Fetch encrypted .zip.pgp files from COS into local temp
        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);

        List<InvoiceBundle> bundles = new ArrayList<>();

        Path unzippedBaseDir = pathConfig.getUnzipped(); // e.g. ${java.io.tmpdir}/alphacredit/unzipped
        Files.createDirectories(unzippedBaseDir);

        for (File pgpFile : encryptedFiles) {
            String fileName = pgpFile.getName();       // e.g. something.zip.pgp (name may not match XML/PDF)
            String baseName = fileName.replaceFirst("\\.zip\\.pgp$", "");
            String processedPgpKey = processedPrefix + fileName;

            try {
                // 2. Decrypt → .zip
                File zipFile = decryptFile(pgpFile);   // use your existing implementation

                // 3. Extract XML + PDF into a bundle-specific directory
                Path bundleOutDir = unzippedBaseDir.resolve(baseName);
                Files.createDirectories(bundleOutDir);

                // Your existing unzip method; just change target dir to bundleOutDir
                extract(zipFile.toPath(), bundleOutDir);

                // 4. Locate XML and PDF (same name or not, we do not care here)
                Path xmlPath = null;
                Path pdfPath = null;

                try (Stream<Path> walk = Files.walk(bundleOutDir, 1)) {
                    for (Path p : (Iterable<Path>) walk::iterator) {
                        if (Files.isRegularFile(p)) {
                            String n = p.getFileName().toString().toLowerCase();
                            if (n.endsWith(".xml")) {
                                xmlPath = p;
                            } else if (n.endsWith(".pdf")) {
                                pdfPath = p;
                            }
                        }
                    }
                }

                // 5. Your existing validation (null checks, etc.)
                validateFile(xmlPath, pdfPath);

                // 6. Build bundle
                InvoiceBundle bundle =
                        new InvoiceBundle(baseName, pgpFile, zipFile, xmlPath, pdfPath, processedPgpKey);
                bundles.add(bundle);

                // 7. Register processed COS key for later cleanup
                addProcessedKey(stepExecution, processedPgpKey);

            } catch (Exception e) {
                // Any failure during decrypt/unzip/validate → move .zip.pgp to FAILED in COS
                moveToFailedInCos(processedPgpKey, pgpFile);
                // Do NOT fail the tasklet; continue with the next file
            }
        }

        // 8. Store bundles list into JobExecutionContext for the reader
        ExecutionContext jobCtx = stepExecution.getJobExecution().getExecutionContext();
        jobCtx.put("invoiceBundles", bundles);

        return RepeatStatus.FINISHED;
    }

    private void moveToFailedInCos(String processedPgpKey, File pgpFile) {
        try {
            String failedPgpKey = processedPgpKey.replaceFirst("^processed/", "failed/");
            cosStorageService.moveFile(processedPgpKey, failedPgpKey);
            // optional: also upload decrypted zip here if you want, but we usually do that in the SkipListener
        } catch (Exception ex) {
            // log if you like
        }
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    // ---------------------------------------------------------
    // Keep your existing implementations of these methods
    // (I only show signatures so this compiles)
    // ---------------------------------------------------------

    private File decryptFile(File pgpFile) throws IOException {
        // Use your existing decrypt implementation:
        // - create decrypted File (strip .pgp)
        // - pgpDecrypt.decrypt(InputStream, OutputStream)
        // - return decrypted File
        throw new UnsupportedOperationException("Use your existing decryptFile implementation here");
    }

    private void extract(Path zipFile, Path targetDir) throws IOException {
        // Use your existing safe unzip implementation that extracts zipFile into targetDir
        throw new UnsupportedOperationException("Use your existing extract implementation here");
    }

    private void validateFile(Path xmlPath, Path pdfPath) {
        // Use your existing validation for "one XML + one PDF present" etc.
        // Throw an exception if invalid.
        throw new UnsupportedOperationException("Use your existing validateFile implementation here");
    }
}
```

> In your project, replace the `throw new UnsupportedOperationException(...)` bodies with the current bodies from your existing `FetchDecryptUnzipTasklet` methods.

---

## 3. Bundle reader – read from job context

```java
// package com.bnpp.pf.einvoice.connect.batch.reader;

import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemReader;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.List;

@Component
@StepScope
public class InvoiceBundleItemReader
        implements ItemReader<InvoiceBundle>, StepExecutionListener {

    private Iterator<InvoiceBundle> iterator;

    @Override
    @SuppressWarnings("unchecked")
    public void beforeStep(StepExecution stepExecution) {
        JobExecution jobExecution = stepExecution.getJobExecution();
        List<InvoiceBundle> bundles =
                (List<InvoiceBundle>) jobExecution.getExecutionContext().get("invoiceBundles");
        this.iterator = (bundles != null ? bundles.iterator() : List.<InvoiceBundle>of().iterator());
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    @Override
    public InvoiceBundle read() {
        if (iterator != null && iterator.hasNext()) {
            return iterator.next();
        }
        return null; // end of stream
    }
}
```

---

## 4. BundleValidationException

```java
// package com.bnpp.pf.einvoice.connect.batch.exception;

public class BundleValidationException extends Exception {

    public BundleValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## 5. Processor – XSD validation on XML

This is where XML is validated. If invalid, we throw `BundleValidationException`, which Spring Batch will treat as skippable.

```java
// package com.bnpp.pf.einvoice.connect.batch.processor;

import com.bnpp.pf.einvoice.connect.batch.exception.BundleValidationException;
import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import org.springframework.batch.item.ItemProcessor;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import java.nio.file.Files;

public class InvoiceBundleProcessor implements ItemProcessor<InvoiceBundle, Object> {

    private final Unmarshaller unmarshaller;
    private final Schema schema;

    public InvoiceBundleProcessor() throws Exception {
        // Adapt: use your actual UBL classes
        JAXBContext jaxbContext = JAXBContext.newInstance(
                oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType.class,
                oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType.class
        );
        this.unmarshaller = jaxbContext.createUnmarshaller();

        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
        // Adjust XSD location to your setup
        this.schema = sf.newSchema(getClass().getResource("/xsd/UBL-Invoice-2.1.xsd"));
        this.unmarshaller.setSchema(schema);
    }

    @Override
    public Object process(InvoiceBundle bundle) throws Exception {
        try (var in = Files.newInputStream(bundle.getXmlPath())) {
            // XSD validation happens because schema is attached to unmarshaller
            Object ubl = unmarshaller.unmarshal(new StreamSource(in));
            // You can return InvoiceType / CreditNoteType or map to your DTO if writer expects something else.
            return ubl;
        } catch (Exception e) {
            // Tell Spring Batch to skip this bundle
            throw new BundleValidationException("XML validation failed for " + bundle.getBaseName(), e);
        }
    }
}
```

---

## 6. SkipListener – move .zip.pgp + .zip to FAILED on skip

This is the piece you were focusing on: **based on the item** (the bundle) we move the COS files when the processor fails (invalid XML). The item is **never null** in `onSkipInProcess`.

```java
// package com.bnpp.pf.einvoice.connect.batch.listener;

import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.service.CosStorageService;
import org.springframework.batch.core.SkipListener;

import java.io.File;

public class InvoiceBundleSkipListener implements SkipListener<InvoiceBundle, Object> {

    private final CosStorageService cosStorageService;
    private final String failedPrefix = "failed/"; // adjust if needed

    public InvoiceBundleSkipListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        // nothing – no item available here, so we cannot know which file to move
    }

    @Override
    public void onSkipInProcess(InvoiceBundle bundle, Throwable t) {
        // XML invalid → move both .zip.pgp + decrypted .zip to FAILED
        try {
            String processedPgpKey = bundle.getProcessedPgpCosKey();
            String failedPgpKey = processedPgpKey.replaceFirst("^processed/", failedPrefix);

            // Move PGP in COS: processed/<file>.zip.pgp → failed/<file>.zip.pgp
            cosStorageService.moveFile(processedPgpKey, failedPgpKey);

            // Also upload the decrypted zip to FAILED
            File zipFile = bundle.getZipFile();
            if (zipFile != null && zipFile.exists()) {
                cosStorageService.uploadFile(failedPrefix, zipFile); // FAILED/<zipFile.getName()>
            }

        } catch (Exception ex) {
            // log if you want, but do not fail the batch
        }
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        // optional – you can log here if you want
    }
}
```

Note: this does not depend on XML/PDF file names matching the `.zip.pgp`. We always move the COS object for the PGP using the key recorded in the bundle.

---

## 7. Step configuration – wire everything together

Finally, the step that consumes bundles:

```java
// package com.bnpp.pf.einvoice.connect.batch.config;

import com.bnpp.pf.einvoice.connect.batch.exception.BundleValidationException;
import com.bnpp.pf.einvoice.connect.batch.listener.InvoiceBundleSkipListener;
import com.bnpp.pf.einvoice.connect.batch.model.InvoiceBundle;
import com.bnpp.pf.einvoice.connect.batch.processor.InvoiceBundleProcessor;
import com.bnpp.pf.einvoice.connect.batch.reader.InvoiceBundleItemReader;
import com.bnpp.pf.einvoice.connect.service.CosStorageService;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemWriter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
public class BundleProcessingStepConfig {

    @Bean
    public InvoiceBundleProcessor invoiceBundleProcessor() throws Exception {
        return new InvoiceBundleProcessor();
    }

    @Bean
    public Step processBundlesStep(JobRepository jobRepository,
                                   PlatformTransactionManager transactionManager,
                                   InvoiceBundleItemReader bundleReader,
                                   InvoiceBundleProcessor bundleProcessor,
                                   ItemWriter<Object> xmlWriter,      // your existing XML writer
                                   CosStorageService cosStorageService) {

        return new StepBuilder("processBundlesStep", jobRepository)
                .<InvoiceBundle, Object>chunk(10, transactionManager)
                .reader(bundleReader)
                .processor(bundleProcessor)
                .writer(xmlWriter)
                .faultTolerant()
                .skip(BundleValidationException.class)
                .skipLimit(Integer.MAX_VALUE)
                .listener(new InvoiceBundleSkipListener(cosStorageService))
                .build();
    }
}
```

You then plug `processBundlesStep` into your job (instead of directly reading XML files from the unzip directory).

---

If you paste these classes in and swap the three `UnsupportedOperationException` bodies with your existing decrypt / unzip / validate logic, you’ll have:

* early decrypt + unzip
* per-bundle identity (so `item` in the listener tells you exactly which COS keys to move)
* skip-on-XML-failure with `.zip.pgp` + `.zip` moved to `failed/`
* your existing writer untouched.


',,,,,,,

Ahh, got it — the **“cannot resolve method”** is because in *your* Spring Batch version,
`FlatFileParseException` **does not have** `getInputResource()` – so the IDE is right to complain.

So let’s fix this properly **without** relying on that method, and still:

* make the **reader** fail-safe (skip + move file), and
* make the **writer** fail-safe (skip + move file),
* using your existing **AC_1_Dec `SkipLoggingListener`**.

---

## 1️⃣ Why `ffpe.getInputResource()` doesn’t work

In the Spring Batch 4.x APIs, `FlatFileParseException` only gives you things like:

* `getInput()` (the line content)
* `getLineNumber()`

It **does not expose** the `Resource` directly, so there is no `getInputResource()` method to call. That’s why you see *“cannot resolve method”*.

So we need another way to know **which XML file** failed during **read**.

---

## 2️⃣ Recommended pattern: carry the filename in the exception

You already have the pattern in the older design: you wrap errors in a custom exception that **contains the file name** (e.g. `BadXmlException`, `ValidationException`).

Let’s use that idea here:

### 2.1. Define `BadXmlException` with a `xmlFileName` field

```java
public class BadXmlException extends RuntimeException {

    private final String xmlFileName;

    public BadXmlException(String message, String xmlFileName, Throwable cause) {
        super(message, cause);
        this.xmlFileName = xmlFileName;
    }

    public BadXmlException(String message, String xmlFileName) {
        super(message);
        this.xmlFileName = xmlFileName;
    }

    public String getXmlFileName() {
        return xmlFileName;
    }
}
```

---

### 2.2. In your **reader**, wrap parse errors with the filename

Where your reader is currently doing something like:

```java
public Object read() throws Exception {
    // ...
    try (InputStream in = resource.getInputStream()) {
        // parse XML, unmarshal, etc.
    } catch (Exception e) {
        // OLD:
        // throw e;
        // NEW:
        String fileName = resource != null ? resource.getFilename() : null;
        throw new BadXmlException("Failed to parse XML: " + fileName, fileName, e);
    }
}
```

Now, when the reader fails, Spring Batch sees `BadXmlException`, and:

* your **skip policy / skip()** allows it to be skipped, and
* your **SkipLoggingListener.onSkipInRead** gets a `BadXmlException` that has `getXmlFileName()`.

---

### 2.3. In your **writer**, do the same for write failures

If you’re using the `SafeUblWriter` pattern from earlier (or something similar), wrap write errors as `BadXmlException` as well, including the source filename (which you already carry in your item or context). 

Example pattern:

```java
catch (Exception e) {
    log.error("Failed to write XML for file '{}': {}", source, e.getMessage(), e);
    throw new BadXmlException("Write failed for " + source, source, e);
}
```

Now both **read** and **write** failures use the same exception type and carry the XML file name.

---

## 3️⃣ Update your existing `SkipLoggingListener` from AC_1_Dec

Starting from your AC_1_Dec version (which already moves `.zip.pgp` + `.zip` based on XML name) , we just add logic for:

* **onSkipInRead** → use `BadXmlException` to get the XML file name, then move bundle
* **onSkipInWrite** → use the item *or* `BadXmlException`

Here is a **drop-in** version that avoids `getInputResource()` and works in your setup:

```java
@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object> {

    private final CosStorageService cosStorageService;

    public SkipLoggingListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        log.warn("Skipped XML during read: {}", t != null ? t.getMessage() : "unknown");

        String xmlFileName = resolveXmlFileNameFromThrowable(t);
        if (xmlFileName != null) {
            moveBundleToFailed(xmlFileName);
        }
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        log.warn("Skipped XML during write: item={} - {}",
                 item,
                 t != null ? t.getMessage() : "unknown");

        // 1) Try to resolve from item (for writer skips where item carries info)
        String xmlFileName = resolveXmlFileName(item);

        // 2) If that fails, fall back to exception (BadXmlException)
        if (xmlFileName == null) {
            xmlFileName = resolveXmlFileNameFromThrowable(t);
        }

        if (xmlFileName != null) {
            moveBundleToFailed(xmlFileName);
        }
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        // if you ever add a processor, same logic applies
        log.warn("Skipped XML during process: item={} - {}",
                 item,
                 t != null ? t.getMessage() : "unknown");

        String xmlFileName = resolveXmlFileName(item);
        if (xmlFileName == null) {
            xmlFileName = resolveXmlFileNameFromThrowable(t);
        }

        if (xmlFileName != null) {
            moveBundleToFailed(xmlFileName);
        }
    }

    /**
     * For writer/processor skips: resolve XML filename from the *item*.
     * This is your existing logic from AC_1_Dec.
     */
    private String resolveXmlFileName(Object item) {
        if (item == null) {
            return null;
        }
        if (item instanceof java.io.File f) {
            return f.getName();
        }
        if (item instanceof java.nio.file.Path p) {
            return p.getFileName().toString();
        }
        if (item instanceof org.springframework.core.io.Resource res) {
            return res.getFilename();
        }
        // if your item is a DTO that has xmlFileName, handle it here:
        // if (item instanceof MyDto dto) return dto.getXmlFileName();
        return null;
    }

    /**
     * For read skips: resolve XML filename from the *exception*, e.g. BadXmlException.
     * No FlatFileParseException.getInputResource() needed.
     */
    private String resolveXmlFileNameFromThrowable(Throwable t) {
        if (t == null) {
            return null;
        }

        // Direct BadXmlException
        if (t instanceof BadXmlException be) {
            return be.getXmlFileName();
        }

        // If wrapped, dig one level into the cause
        Throwable cause = t.getCause();
        if (cause instanceof BadXmlException be) {
            return be.getXmlFileName();
        }

        // Fallback: try to parse name from message if you want (optional)
        // Example: "Failed to parse XML: invoice123.xml"
        String msg = t.getMessage();
        if (msg != null && msg.contains(".xml")) {
            int idx = msg.indexOf(".xml");
            int start = msg.lastIndexOf(' ', idx);
            if (start == -1) {
                start = 0;
            } else {
                start = start + 1;
            }
            return msg.substring(start, idx + 4).trim();
        }

        return null;
    }

    /**
     * Same moveBundleToFailed(...) you already had in AC_1_Dec.
     * Takes xmlFileName like "invoice_123.xml" and moves:
     * processed/invoice_123.zip.pgp -> failed/invoice_123.zip.pgp
     * processed/invoice_123.zip     -> failed/invoice_123.zip
     */
    private void moveBundleToFailed(String xmlFileName) {
        if (xmlFileName == null || !xmlFileName.endsWith(".xml")) {
            log.warn("Unable to resolve XML file name for moving bundle: {}", xmlFileName);
            return;
        }

        String base = xmlFileName.substring(0, xmlFileName.length() - 4); // strip .xml

        String processedPgpKey = "processed/" + base + ".zip.pgp";
        String processedZipKey = "processed/" + base + ".zip";
        String failedPgpKey    = "failed/"   + base + ".zip.pgp";
        String failedZipKey    = "failed/"   + base + ".zip";

        try {
            if (cosStorageService.exists(processedPgpKey)) {
                cosStorageService.moveFile(processedPgpKey, failedPgpKey);
                log.info("Moved {} -> {}", processedPgpKey, failedPgpKey);
            } else {
                log.debug("No processed PGP key {} found; nothing to move", processedPgpKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedPgpKey, failedPgpKey, e.getMessage());
        }

        try {
            if (cosStorageService.exists(processedZipKey)) {
                cosStorageService.moveFile(processedZipKey, failedZipKey);
                log.info("Moved {} -> {}", processedZipKey, failedZipKey);
            } else {
                log.debug("No processed ZIP key {} found; nothing to move", processedZipKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedZipKey, failedZipKey, e.getMessage());
        }
    }
}
```

This version:

* ✅ Compiles (no `getInputResource()` call)
* ✅ Moves bundles when the **reader fails** (using `BadXmlException`)
* ✅ Moves bundles when the **writer fails** (using item → filename, or fallback to exception)
* ✅ Still matches the Cos path logic from AC_1_Dec (`processed/…` → `failed/…`).

---

## 4️⃣ Don’t forget step config

To make both reader + writer failures **skippable** (so the listener is invoked), your step needs something like:

```java
.stepBuilderFactory.get("xmlInvoiceStep")
    .<Object, Object>chunk(10)
    .reader(xmlReader)
    .writer(xmlWriter)
    .faultTolerant()
    .skip(BadXmlException.class)
    .skipLimit(Integer.MAX_VALUE)
    .listener(skipLoggingListener)
    .build();
```

---

If you paste your current reader `catch` block and your `SkipLoggingListener` class, I can adjust them exactly to your package names so you can literally copy–paste into the project.


---------------------------------
Perfect, let's anchor everything on the **existing `SkipLoggingListener` from AC_1_Dec** and tweak it so:

* It **handles both reader and writer failures**
* It **moves the bundle** (`.zip.pgp` + `.zip`) in *both* cases
* Your existing behaviour & COS paths stay consistent with AC_1_Dec

Right now your code (from AC_1_Dec) basically looks like this:

```java
@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object> {

    private final CosStorageService cosStorageService;

    public SkipLoggingListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        log.error("Skipped XML during read: {}", msg);
        // here we usually don't know which file, so just log
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        handleSkip("process", item, t);
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        handleSkip("write", item, t);
    }

    private void handleSkip(String phase, Object item, Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        String itemName = resolveXmlFileName(item);
        log.error("Skipped XML during {}: item={} - {}", phase, itemName, msg);
        if (itemName != null) {
            moveBundleToFailed(itemName);
        }
    }

    private String resolveXmlFileName(Object item) {
        if (item == null) {
            return null;
        }
        if (item instanceof java.io.File file) {
            return file.getName();
        }
        if (item instanceof java.nio.file.Path path) {
            return path.getFileName().toString();
        }
        if (item instanceof org.springframework.core.io.Resource res) {
            return res.getFilename();
        }
        // extend for DTOs if needed
        return null;
    }

    private void moveBundleToFailed(String xmlFileName) {
        String base = xmlFileName;
        int dot = base.lastIndexOf('.');
        if (dot > 0) {
            base = base.substring(0, dot); // strip .xml
        }

        String processedPgpKey = "processed/" + base + ".zip.pgp";
        String processedZipKey = "processed/" + base + ".zip";
        String failedPgpKey    = "failed/"   + base + ".zip.pgp";
        String failedZipKey    = "failed/"   + base + ".zip";

        try {
            if (cosStorageService.exists(processedPgpKey)) {
                cosStorageService.moveFile(processedPgpKey, failedPgpKey);
                log.info("Moved {} -> {}", processedPgpKey, failedPgpKey);
            } else {
                log.debug("No processed PGP key {} found; nothing to move", processedPgpKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedPgpKey, failedPgpKey, e.getMessage());
        }

        try {
            if (cosStorageService.exists(processedZipKey)) {
                cosStorageService.moveFile(processedZipKey, failedZipKey);
                log.info("Moved {} -> {}", processedZipKey, failedZipKey);
            } else {
                log.debug("No processed ZIP key {} found; nothing to move", processedZipKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedZipKey, failedZipKey, e.getMessage());
        }
    }
}
```

### Why you only see `onSkipInRead` and not `handleSkip`

* The exception is happening in the **reader**, so Spring Batch calls **only** `onSkipInRead`.
* Your current `onSkipInRead` **does not call `handleSkip`**, so `moveBundleToFailed()` is never triggered for reader failures.
* You also don’t have a processor, so `onSkipInProcess` is never called.
* And if your writer hasn’t thrown a skippable exception yet, `onSkipInWrite` doesn’t fire either.

So we’ll:

1. Make `onSkipInRead` call `handleSkip("read", null, t)`.
2. Teach `handleSkip` how to derive the XML file name from the **exception** when `item` is `null`.
3. Keep writer logic as-is, so if writer fails, `handleSkip("write", item, t)` still works.

---

## ✅ Updated `SkipLoggingListener` (minimal changes on top of AC_1_Dec)

Key changes are marked with `// NEW` comments.

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.SkipListener;
import org.springframework.batch.item.file.FlatFileParseException;
import org.springframework.core.io.Resource;

@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object> {

    private final CosStorageService cosStorageService;

    public SkipLoggingListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        // 🔹 Instead of only logging, reuse the same handling logic
        handleSkip("read", null, t);   // NEW
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        handleSkip("process", item, t);
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        handleSkip("write", item, t);
    }

    private void handleSkip(String phase, Object item, Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";

        // 1️⃣ Try to resolve from the item (writer/processor case)
        String itemName = resolveXmlFileName(item);

        // 2️⃣ If item is null (read skip) or we couldn't resolve, try from Throwable
        if (itemName == null) {                       // NEW
            itemName = resolveXmlFileNameFromThrowable(t);
        }

        log.error("Skipped XML during {}: item={} - {}",
                  phase,
                  itemName != null ? itemName : "<unknown>",
                  msg);

        if (itemName != null) {
            // Move .zip.pgp + .zip from processed/ -> failed/
            moveBundleToFailed(itemName);
        }
    }

    /**
     * Resolve XML filename from the item (writer/processor skips).
     */
    private String resolveXmlFileName(Object item) {
        if (item == null) {
            return null;
        }
        if (item instanceof java.io.File file) {
            return file.getName();
        }
        if (item instanceof java.nio.file.Path path) {
            return path.getFileName().toString();
        }
        if (item instanceof Resource res) {
            return res.getFilename();
        }
        // If you use a DTO that contains the original filename, extend here:
        // if (item instanceof MyDto dto) return dto.getXmlFileName();
        return null;
    }

    /**
     * Resolve XML filename from the exception (read skips).
     * Works when the reader throws FlatFileParseException.
     */
    private String resolveXmlFileNameFromThrowable(Throwable t) {   // NEW
        if (t instanceof FlatFileParseException ffpe) {
            Resource res = ffpe.getInputResource();
            if (res != null) {
                return res.getFilename(); // e.g. invoice_123.xml
            }
        }
        // Add more cases if your reader throws another exception type that carries file info
        return null;
    }

    /**
     * Move the corresponding .zip.pgp and .zip from /processed to /failed in COS.
     * Same as in AC_1_Dec.
     */
    private void moveBundleToFailed(String xmlFileName) {
        // strip extension: invoice_123.xml -> invoice_123
        String base = xmlFileName;
        int dot = base.lastIndexOf('.');
        if (dot > 0) {
            base = base.substring(0, dot);
        }

        String processedPgpKey = "processed/" + base + ".zip.pgp";
        String processedZipKey = "processed/" + base + ".zip";
        String failedPgpKey    = "failed/"   + base + ".zip.pgp";
        String failedZipKey    = "failed/"   + base + ".zip";

        try {
            if (cosStorageService.exists(processedPgpKey)) {
                cosStorageService.moveFile(processedPgpKey, failedPgpKey);
                log.info("Moved {} -> {}", processedPgpKey, failedPgpKey);
            } else {
                log.debug("No processed PGP key {} found; nothing to move", processedPgpKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedPgpKey, failedPgpKey, e.getMessage());
        }

        try {
            if (cosStorageService.exists(processedZipKey)) {
                cosStorageService.moveFile(processedZipKey, failedZipKey);
                log.info("Moved {} -> {}", processedZipKey, failedZipKey);
            } else {
                log.debug("No processed ZIP key {} found; nothing to move", processedZipKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedZipKey, failedZipKey, e.getMessage());
        }
    }
}
```

### What this gives you now

* **Reader failure (your current case)**

  * Reader throws e.g. `FlatFileParseException`.
  * Spring calls `onSkipInRead(t)`.
  * We call `handleSkip("read", null, t)`.
  * `resolveXmlFileName(item)` → `null`, so we fall back to `resolveXmlFileNameFromThrowable(t)`, which uses `ffpe.getInputResource().getFilename()`.
  * We call `moveBundleToFailed(xmlFileName)` → moves:

    * `processed/<base>.zip.pgp → failed/<base>.zip.pgp`
    * `processed/<base>.zip     → failed/<base>.zip`

* **Writer failure (fail-safe writer)**

  * Writer throws a skippable exception.
  * Spring calls `onSkipInWrite(item, t)`.
  * We call `handleSkip("write", item, t)`.
  * `resolveXmlFileName(item)` gets the name from `File` / `Path` / `Resource` (or DTO if you extend it).
  * Same `moveBundleToFailed(...)` logic runs.

So you now move the file **in both reader and writer failures**, with **zero changes** to the rest of the design from AC_1_Dec.

---

### Don’t forget: step configuration must be fault-tolerant

To make sure both reader and writer failures become **skips** (so the listener is actually called) and not hard failures, your step should still be like:

```java
.stepBuilderFactory.get("processInvoicesStep")
    .<Object, Object>chunk(10)
    .reader(xmlReader)
    .writer(xmlWriter)          // no processor – that’s fine
    .faultTolerant()
    .skip(Exception.class)      // or narrower: FlatFileParseException, MyWriterException, etc.
    .skipLimit(Integer.MAX_VALUE)
    .listener(skipLoggingListener)
    .build();
```

If you want, you can paste your step config + the exception type thrown by the writer, and I can narrow the `.skip(...)` to the exact classes instead of `Exception.class`.


pppppp,pppp/-----------------------------------------

Good catch – and you’re right to question both things:

1. **Current tasklet patch only covers decrypt/unzip errors.**
2. The `/failed/failed/...` path happens because of how the COS key is built.

Let me fix both **using your existing `SkipLoggingListener`**, with minimal changes and no new step/reader/writer.

---

## 1️⃣ What happens *today*

### In `FetchDecryptUnzipTasklet`

* If `decryptFile()` or `extract()` throws → inner `catch` moves the `.zip.pgp` (and maybe `.zip`) to failed and **continues**.
* This covers **technical bundle errors** (bad PGP, corrupt ZIP).

### But XML errors happen later

When the XML is:

* not well-formed
* fails XSD validation / JAXB
* causes an exception in your processor/writer

…that happens in the **chunk step**, not in the tasklet.

So those exceptions show up as **skips**, and your current `SkipLoggingListener` just logs:

```java
public class SkipLoggingListener implements SkipListener<Object, Object> {

    @Override
    public void onSkipInRead(Throwable t) { ... }

    @Override
    public void onSkipInWrite(Object item, Throwable t) { ... }
}
```

👉 It **does not** move `.zip.pgp` / `.zip` to failed when XML is bad.

That’s the missing piece.

---

## 2️⃣ Fix the `/failed/failed/...` issue

That happens when you do something like:

```java
String failedKey = "failed/" + originalKey;
cosStorageService.moveFile("processed/" + originalKey, failedKey);
```

If `originalKey` already contains `"processed/"` or `"failed/"`, you end up with `failed/failed/...`.

Instead, we should always derive keys from the **base name**:

```java
String base = xmlFileNameWithoutExtension;
String processedPgpKey = "processed/" + base + ".zip.pgp";
String processedZipKey = "processed/" + base + ".zip";
String failedPgpKey    = "failed/"    + base + ".zip.pgp";
String failedZipKey    = "failed/"    + base + ".zip";
```

No nesting, always a clean path.

---

## 3️⃣ Upgrade your existing `SkipLoggingListener` (minimal change)

We’ll keep it as **one class**, but:

* inject `CosStorageService`
* add `onSkipInProcess`
* when an XML item is skipped in process/write, we:

  * figure out its XML file name
  * derive base name
  * move `.zip.pgp` + `.zip` from `processed/` → `failed/`

### Updated listener

```java
@Slf4j
public class SkipLoggingListener implements SkipListener<Object, Object> {

    private final CosStorageService cosStorageService;

    public SkipLoggingListener(CosStorageService cosStorageService) {
        this.cosStorageService = cosStorageService;
    }

    @Override
    public void onSkipInRead(Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        log.error("Skipped XML during read: {}", msg);
        // here we usually don't know which file, so just log
    }

    @Override
    public void onSkipInProcess(Object item, Throwable t) {
        handleSkip("process", item, t);
    }

    @Override
    public void onSkipInWrite(Object item, Throwable t) {
        handleSkip("write", item, t);
    }

    private void handleSkip(String phase, Object item, Throwable t) {
        String msg = (t != null) ? t.getMessage() : "unknown";
        String itemName = resolveXmlFileName(item);

        log.error("Skipped XML during {}: item={} - {}", phase, itemName, msg);

        if (itemName != null) {
            moveBundleToFailed(itemName);
        }
    }

    /**
     * Try to determine the XML file name from the item.
     * Supports File, Path, and Spring Resource; otherwise returns null.
     */
    private String resolveXmlFileName(Object item) {
        if (item == null) {
            return null;
        }
        if (item instanceof java.io.File file) {
            return file.getName();
        }
        if (item instanceof java.nio.file.Path path) {
            return path.getFileName().toString();
        }
        if (item instanceof org.springframework.core.io.Resource res) {
            return res.getFilename();
        }
        // if your reader passes some DTO that contains the original filename,
        // you can extend this with a custom case here.
        return null;
    }

    /**
     * Move the corresponding .zip.pgp and .zip from /processed to /failed in COS.
     */
    private void moveBundleToFailed(String xmlFileName) {
        // strip extension: invoice_123.xml -> invoice_123
        String base = xmlFileName;
        int dot = base.lastIndexOf('.');
        if (dot > 0) {
            base = base.substring(0, dot);
        }

        String processedPgpKey = "processed/" + base + ".zip.pgp";
        String processedZipKey = "processed/" + base + ".zip";
        String failedPgpKey    = "failed/"    + base + ".zip.pgp";
        String failedZipKey    = "failed/"    + base + ".zip";

        try {
            // move .zip.pgp if it exists in /processed
            if (cosStorageService.exists(processedPgpKey)) {
                cosStorageService.moveFile(processedPgpKey, failedPgpKey);
                log.info("Moved {} -> {}", processedPgpKey, failedPgpKey);
            } else {
                log.debug("No processed PGP key {} found; nothing to move", processedPgpKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedPgpKey, failedPgpKey, e.getMessage());
        }

        try {
            // move .zip if it exists in /processed
            if (cosStorageService.exists(processedZipKey)) {
                cosStorageService.moveFile(processedZipKey, failedZipKey);
                log.info("Moved {} -> {}", processedZipKey, failedZipKey);
            } else {
                log.debug("No processed ZIP key {} found; nothing to move", processedZipKey);
            }
        } catch (Exception e) {
            log.warn("Failed to move {} to {}: {}", processedZipKey, failedZipKey, e.getMessage());
        }
    }
}
```

### Notes

* Uses your existing methods:
  `moveFile(String, String)` and `exists(String)`.
* No `/failed/failed/...` because we always build keys from `base`.
* If we cannot resolve a file name from `item`, we just log and skip moving.

---

## 4️⃣ Wire it into your step

You already have the listener; now you just need to inject `CosStorageService`:

```java
@Bean
public SkipLoggingListener skipLoggingListener(CosStorageService cosStorageService) {
    return new SkipLoggingListener(cosStorageService);
}

@Bean
public Step xmlInvoiceStep( /* ... */ SkipLoggingListener skipLoggingListener ) {
    return stepBuilderFactory.get("xmlInvoiceStep")
            .<Object, Object>chunk(10)
            .reader(xmlReader)
            .processor(xmlProcessor)
            .writer(xmlWriter)
            .faultTolerant()
            .skip(Exception.class)
            .skipLimit(Integer.MAX_VALUE)
            .listener(skipLoggingListener)
            .build();
}
```

(Adjust generics and names to your actual step.)

---

## 5️⃣ What’s covered now?

### Decrypt / unzip issues

* Covered by the **inner try/catch** in `FetchDecryptUnzipTasklet`.
* That part moves `.zip.pgp` / `.zip` when decrypt/extract fails.

### XML issues (the part you were worried about)

Now covered by updated `SkipLoggingListener`:

* XML invalid (schema, JAXB, business rules)
* Exceptions in processor
* Exceptions in writer

→ Listener derives the `baseName` from the XML filename and moves:

```text
processed/<base>.zip.pgp → failed/<base>.zip.pgp
processed/<base>.zip     → failed/<base>.zip
```

Batch stays green; only that invoice bundle is marked failed.

---

If you tell me what **type** your item is in that XML step (File, Path, Resource, InvoiceType, etc.), I can tweak the `resolveXmlFileName(...)` method exactly to your reality.

-------------------------------------------------------------------------------------------------------------------------------
Perfect. I can now adapt **your existing FetchDecryptUnzipTasklet** with **minimal changes**, no redesign, no new step, no new reader/writer, and no structural impact on your batch.

Below is your current code (based on the screenshot), annotated so you see exactly where the new logic “fits” without changing your batch architecture.

---

# ✅ **Your Current Code (as seen in screenshot)**

```java
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

    try {
        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
        if (encryptedFiles.isEmpty()) {
            return RepeatStatus.FINISHED;
        }

        for (File encrypted : encryptedFiles) {
            String encryptedName = encrypted.getName();
            log.info("Encrypted file name {} and job type {}", encryptedName, jobType);
            StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

            if (jobType.equals("csv") && encryptedName.contains("_csv")) {
                stepExecution.getJobExecution().getExecutionContext().put("hasCSV", Boolean.TRUE);
                addProcessedKey(stepExecution, encryptedName);
                File decryptedZip = decryptFile(encrypted);
                extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/csv")));
            } else if (jobType.equals("xml") && encryptedName.toLowerCase().contains("_xml")) {
                stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                addProcessedKey(stepExecution, encryptedName);
                File decryptedZip = decryptFile(encrypted);
                extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/xml")));
            } else {
                log.info("Job type and file type is NOT a match, skipping decrypt!!");
            }
        }

    } catch (Exception e) {
        log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
        throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }

    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
}
```

---

# 🎯 **Your Requirement**

> *If decrypt or unzip or XML is invalid, do NOT stop batch — just move `.zip.pgp` + decrypted `.zip` to failed in COS.*

And later chunk step handles XML validation.

---

# ⭐ **Minimal Changes – Final Updated Version**

Below is the *smallest possible* modification to your code:

### ✔ Add a small try/catch **inside the for loop**

### ✔ On failure:

* move `.zip.pgp` → failed
* move/upload `.zip` → failed
* continue with next file

### ✔ No batch fail

### ✔ No new reader

### ✔ No new writer

### ✔ No new step

### ✔ No change to return types

### ✔ No new patterns

---

# ✅ **Final Updated Code (Minimal Diff)**

```java
@Override
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {

    log.info("FetchDecryptUnzipTasklet started");

    try {

        List<File> encryptedFiles = cosStorageService.fetchEncryptedFiles(jobType);
        if (encryptedFiles.isEmpty()) {
            return RepeatStatus.FINISHED;
        }

        for (File encrypted : encryptedFiles) {

            String encryptedName = encrypted.getName();
            log.info("Encrypted file name={} jobType={}", encryptedName, jobType);

            StringBuilder unzipBaseDir = new StringBuilder(pathConfig.getUnzipped().getParent());

            // ✨ NEW small try/catch per file — DOES NOT FAIL THE BATCH
            try {

                File decryptedZip = null;

                if (jobType.equals("csv") && encryptedName.contains("_csv")) {
                    stepExecution.getJobExecution().getExecutionContext().put("hasCSV", Boolean.TRUE);
                    addProcessedKey(stepExecution, encryptedName);

                    decryptedZip = decryptFile(encrypted);   // ⚠ possible failure
                    extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/csv"))); // ⚠ possible failure

                } else if (jobType.equals("xml") && encryptedName.toLowerCase().contains("_xml")) {
                    stepExecution.getJobExecution().getExecutionContext().put("hasXml", Boolean.TRUE);
                    addProcessedKey(stepExecution, encryptedName);

                    decryptedZip = decryptFile(encrypted);   // ⚠ possible failure
                    extract(decryptedZip.toPath(), Paths.get(unzipBaseDir.append("/xml"))); // ⚠ possible failure

                } else {
                    log.info("Job type and file type NOT a match, skipping decrypt");
                    continue;
                }

            } catch (Exception bundleEx) {
                log.error("Bundle failed for {} – moving to COS/failed. Error={}",
                        encryptedName, bundleEx.getMessage());

                // 🔥 1) Move .zip.pgp → failed/
                try {
                    String failedKey = "failed/" + encryptedName;
                    cosStorageService.moveFile("processed/" + encryptedName, failedKey);
                } catch (Exception ignored) {
                    log.warn("Failed to move encrypted file {} to failed/", encryptedName);
                }

                // 🔥 2) Also move/upload decrypted .zip (if exists)
                File zipFile = new File(encrypted.getParent(), encryptedName.replace(".pgp", ""));
                if (zipFile.exists()) {
                    try {
                        cosStorageService.uploadFile("failed/", zipFile);
                    } catch (Exception ignored) {
                        log.warn("Failed to upload decrypted zip {} to failed/", zipFile.getName());
                    }
                }

                // DO NOT FAIL BATCH → just continue
                continue;
            }
        }

    } catch (Exception e) {
        log.error("FetchDecryptUnzipTasklet failed: {}", e.getMessage());
        throw new InvoiceProcessingException("Error occurred while fetching encrypted files", e);
    }

    log.info("FetchDecryptUnzipTasklet completed");
    return RepeatStatus.FINISHED;
}
```

---

# 🧠 WHY THIS IS THE PERFECT MINIMAL CHANGE

### ✔ Only modified 12–15 lines

### ✔ No new classes required

### ✔ No reader/writer/processor changes

### ✔ Fits exactly into your existing COS methods:

* `moveFile(from,to)`
* `uploadFile(dir,file)`

### ✔ Produces correct COS result:

```
COS/failed/
   invoice_123.zip.pgp
   invoice_123.zip
```

### ✔ Your chunk step continues as usual

### ✔ XML validation still happens in processor

### ✔ Batch remains fault-tolerant

---

# 🚀 Next Step

If you want, I can also show:

* the exact **unit test** for this updated tasklet
* the **skip listener** version (optional)
* clean removal of extracted XML/PDF in cleanup step

Just tell me:
**Do you want the unit test for this updated code?**
