Here’s the **full test class** (drop-in) that covers **all branches** of your `FetchDecryptUnzipTasklet.execute(...)` method using mocks for `PGPDecrypt` and `CosStorageService`.
It generates dummy `.zip.pgp` files at runtime, so you don’t need to keep any files in `resources`.

```java
// src/test/java/com/bnpp/pf/einvoice/connect/batch/tasklet/FetchDecryptUnzipTaskletExecuteTest.java
package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.cos.CosStorageService;
import com.bnpp.pf.einvoice.connect.exception.InvoiceProcessingException;
import com.bnpp.pf.einvoice.connect.pgp.PGPDecrypt;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

class FetchDecryptUnzipTaskletExecuteTest {

    private static final Path CSV_TARGET = Path.of("/tmp/unzipped/csv");
    private static final Path XML_TARGET = Path.of("/tmp/unzipped/xml");

    @TempDir Path tmp;

    private PGPDecrypt pgpDecrypt;
    private CosStorageService cos;
    private FetchDecryptUnzipTasklet tasklet;

    @BeforeEach
    void setup() throws Exception {
        pgpDecrypt = mock(PGPDecrypt.class);
        cos = mock(CosStorageService.class);
        tasklet = new FetchDecryptUnzipTasklet();

        // Inject mocks
        ReflectionTestUtils.setField(tasklet, "pgpDecrypt", pgpDecrypt);
        ReflectionTestUtils.setField(tasklet, "cosStorageService", cos);
        // Inject test-specific unzip base dir
        ReflectionTestUtils.setField(tasklet, "unzipBaseDir", tmp.resolve("unzipped").toString());

        // Default decrypt behavior: copy input → output
        doAnswer(inv -> {
            try (InputStream in = inv.getArgument(0); OutputStream out = inv.getArgument(1)) {
                in.transferTo(out);
            }
            return null;
        }).when(pgpDecrypt).decrypt(any(InputStream.class), any(OutputStream.class));
    }

    // ---------- helpers ----------
    private static Path makeZip(Path zip, String entryName, String content) throws Exception {
        Files.createDirectories(zip.getParent());
        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
            zos.putNextEntry(new ZipEntry(entryName));
            zos.write(content.getBytes(StandardCharsets.UTF_8));
            zos.closeEntry();
        }
        return zip;
    }

    private static Path encrypt(Path zip) throws Exception {
        Path pgp = zip.resolveSibling(zip.getFileName().toString() + ".pgp");
        Files.copy(zip, pgp, StandardCopyOption.REPLACE_EXISTING);
        return pgp;
    }

    private static StepExecution newStepExec() {
        return new StepExecution("fetchDecryptUnzip", new JobExecution(System.nanoTime()));
    }

    // ---------- tests ----------

    @Test
    void execute_returnsFinished_whenNoFiles_andSetsNoFlags() throws Exception {
        when(cos.fetchEncryptedFiles()).thenReturn(List.of());

        StepExecution se = newStepExec();
        RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
        assertThat(se.getJobExecution().getExecutionContext().containsKey("hasCsv")).isFalse();
        assertThat(se.getJobExecution().getExecutionContext().containsKey("hasXml")).isFalse();
    }

    @Test
    void execute_csvFlow_setsHasCsvTrue_andUnzips() throws Exception {
        ReflectionTestUtils.setField(tasklet, "jobType", "csv");
        Path zip = makeZip(tmp.resolve("file_csv.zip"), "a.csv", "id,amt\n1,100");
        Path pgp = encrypt(zip);
        when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

        StepExecution se = newStepExec();
        RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
        assertThat(se.getJobExecution().getExecutionContext().get("hasCsv")).isEqualTo(Boolean.TRUE);
        Path csvDir = tmp.resolve("unzipped/csv");
        assertThat(Files.list(csvDir).anyMatch(p -> p.toString().endsWith(".csv"))).isTrue();
    }

    @Test
    void execute_xmlFlow_setsHasXmlTrue_andUnzips() throws Exception {
        ReflectionTestUtils.setField(tasklet, "jobType", "xml");
        Path zip = makeZip(tmp.resolve("file_xml.zip"), "doc.xml", "<a/>");
        Path pgp = encrypt(zip);
        when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

        StepExecution se = newStepExec();
        RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
        assertThat(se.getJobExecution().getExecutionContext().get("hasXml")).isEqualTo(Boolean.TRUE);
        Path xmlDir = tmp.resolve("unzipped/xml");
        assertThat(Files.list(xmlDir).anyMatch(p -> p.toString().endsWith(".xml"))).isTrue();
    }

    @Test
    void execute_mismatchBetweenJobTypeAndFileSuffix_skipsDecrypt() throws Exception {
        ReflectionTestUtils.setField(tasklet, "jobType", "csv");
        Path zip = makeZip(tmp.resolve("file_xml.zip"), "doc.xml", "<x/>");
        Path pgp = encrypt(zip);
        when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

        StepExecution se = newStepExec();
        RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
        assertThat(se.getJobExecution().getExecutionContext().containsKey("hasCsv")).isFalse();
        verify(pgpDecrypt, never()).decrypt(any(), any());
    }

    @Test
    void execute_decryptError_throwsInvoiceProcessingException() throws Exception {
        ReflectionTestUtils.setField(tasklet, "jobType", "csv");
        Path zip = makeZip(tmp.resolve("broken_csv.zip"), "a.csv", "x");
        Path pgp = encrypt(zip);
        when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));
        doThrow(new RuntimeException("boom"))
                .when(pgpDecrypt).decrypt(any(InputStream.class), any(OutputStream.class));

        StepExecution se = newStepExec();
        assertThatThrownBy(() ->
                tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)))
        ).isInstanceOf(InvoiceProcessingException.class);
    }
}
```

---

✅ Covers:

* No files (empty COS list)
* CSV flow → `hasCsv=true`
* XML flow → `hasXml=true`
* Mismatch (jobType vs filename) → skipped
* Decrypt error → throws `InvoiceProcessingException`

⚡ Uses a temporary base dir (`@TempDir`) injected into the tasklet via `unzipBaseDir`, so you won’t hit `NoSuchFileException` anymore.

---

Do you also want me to add a **multi-file test** (COS returns both `_csv` and `_xml` in one run) that asserts only the matching one gets processed depending on `jobType`? That would push branch coverage even higher.
