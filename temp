Gotcha — if Fortify in your pipeline ignores code comments (and even the PGP one didn’t work), you’ve likely got **code-based suppressions disabled**. So we need a version Fortify will accept **purely by code structure**.

Below are two Fortify-clean patterns that avoid the flagged `resolve()` usage on untrusted data.

# Option A (Safest & simplest): **Flatten** entries (no subdirs)

If you don’t need to preserve directory structure inside the ZIP, just extract files into the target folder using **only the basename**. Fortify is happy because you never resolve a user-controlled path.

```java
private void unzipFile(File zipFile, Path targetDir) throws IOException {
    Path destRoot = targetDir.toRealPath(java.nio.file.LinkOption.NOFOLLOW_LINKS);
    java.nio.file.Files.createDirectories(destRoot);

    try (java.util.zip.ZipInputStream zis =
             new java.util.zip.ZipInputStream(new java.io.FileInputStream(zipFile))) {

        java.util.zip.ZipEntry entry;
        while ((entry = zis.getNextEntry()) != null) {

            // take only the filename; drop any path
            String baseName = java.nio.file.Paths.get(entry.getName())
                    .getFileName().toString();

            // reject empty or suspicious names
            if (baseName.isBlank() || baseName.equals(".") || baseName.equals("..")) {
                throw new IOException("Invalid ZIP entry name: " + entry.getName());
            }

            java.nio.file.Path dest = destRoot.resolve(baseName).normalize();

            if (entry.isDirectory()) {
                java.nio.file.Files.createDirectories(dest);
            } else {
                java.nio.file.Files.createDirectories(dest.getParent());
                try (java.io.OutputStream out = java.nio.file.Files.newOutputStream(
                        dest,
                        java.nio.file.StandardOpenOption.CREATE_NEW)) {
                    zis.transferTo(out);
                }
            }
        }
    }
}
```

# Option B (Preserve subdirs): **Segment-by-segment validation**

We validate each path component first, then resolve **sanitized segments one by one** (Fortify sees validation *before* each `resolve`).

```java
private void unzipFile(File zipFile, Path targetDir) throws IOException {
    Path destRoot = targetDir.toRealPath(java.nio.file.LinkOption.NOFOLLOW_LINKS);
    java.nio.file.Files.createDirectories(destRoot);

    try (java.util.zip.ZipInputStream zis =
             new java.util.zip.ZipInputStream(new java.io.FileInputStream(zipFile))) {

        java.util.zip.ZipEntry entry;
        while ((entry = zis.getNextEntry()) != null) {
            String raw = entry.getName().replace('\\', '/');

            // quick rejects: absolute paths & parent traversal markers
            if (raw.startsWith("/") || raw.matches("(?i)^[a-z]:.*")) {
                throw new IOException("Absolute path in ZIP entry: " + raw);
            }

            // build destination path by resolving only validated segments
            Path dest = destRoot;
            for (String seg : raw.split("/")) {
                if (seg.isEmpty() || ".".equals(seg) || "..".equals(seg)) {
                    throw new IOException("Path traversal segment in ZIP entry: " + raw);
                }
                // resolve *after* validation of the segment -> Fortify-friendly
                dest = dest.resolve(seg);
            }
            dest = dest.normalize();

            // boundary check (defense-in-depth)
            if (!dest.startsWith(destRoot)) {
                throw new IOException("ZIP entry escapes target dir: " + raw);
            }

            if (entry.isDirectory()) {
                java.nio.file.Files.createDirectories(dest);
            } else {
                java.nio.file.Files.createDirectories(dest.getParent());
                try (java.io.OutputStream out = java.nio.file.Files.newOutputStream(
                        dest,
                        java.nio.file.StandardOpenOption.CREATE_NEW)) {
                    zis.transferTo(out);
                }
            }
        }
    }
}
```

### Why these pass Fortify

* We **don’t** call `resolve()` on an untrusted whole path.
* Every segment is **validated before** it’s used.
* We still do the final `startsWith(destRoot)` boundary check.

---

### About the PGP suppression not working

That confirms your Fortify run doesn’t honor inline suppressions. If you ever need to suppress (after securing code), the two supported routes are:

* Mark **Not an Issue** with justification in **SSC/Audit Workbench**, or
* Use Fortify’s **security annotations JAR** (if your org enables it) to add `@SuppressSecurityIssue(...)` — otherwise it’s ignored.

If you want, paste your whole `unzipFile()` and I’ll return it fully rewritten with one of the patterns above, matching your logging and error handling style.
