@ExtendWith(MockitoExtension.class)
class InvoiceJobSchedulerTest {

    @Mock private JobLauncher jobLauncher;
    @Mock private Job xmlInvoiceJob;
    @Mock private Job csvInvoiceJob;
    @Mock private SchedulerConfig schedulerConfig;

    private InvoiceJobScheduler scheduler;

    @BeforeEach
    void setup() {
        scheduler = new InvoiceJobScheduler(jobLauncher, xmlInvoiceJob, csvInvoiceJob, schedulerConfig);
    }

    @Test
    void shouldRunXmlInvoiceJob() throws Exception {
        when(jobLauncher.run(any(Job.class), any(JobParameters.class)))
            .thenReturn(mock(JobExecution.class));

        scheduler.xmlInvoiceJobScheduler();

        // Verify correct job and parameter
        verify(jobLauncher, times(1))
            .run(eq(xmlInvoiceJob), argThat(p -> "xml".equals(p.getString("jobType"))));
    }

    @Test
    void shouldRunCsvInvoiceJob() throws Exception {
        when(jobLauncher.run(any(Job.class), any(JobParameters.class)))
            .thenReturn(mock(JobExecution.class));

        scheduler.csvInvoiceJobScheduler();

        verify(jobLauncher, times(1))
            .run(eq(csvInvoiceJob), argThat(p -> "csv".equals(p.getString("jobType"))));
    }

    @Test
    void shouldThrowInvoiceProcessingExceptionWhenRunFails() throws Exception {
        when(jobLauncher.run(any(Job.class), any(JobParameters.class)))
            .thenThrow(new JobExecutionAlreadyRunningException("Already running"));

        assertThatThrownBy(() -> scheduler.runJob(xmlInvoiceJob, "xmlInvoiceJob"))
            .isInstanceOf(InvoiceProcessingException.class)
            .hasMessageContaining("Failed to launch");

        verify(jobLauncher).run(any(Job.class), any(JobParameters.class));
    }
}
