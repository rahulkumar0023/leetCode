Below is **drop-in JUnit 5 coverage** for the code in your screenshot:

* `toCreditNoteTypeGroup(...)` branch behavior:

  * when `AllowanceChargeCbcChargeIndicator` is **false** ‚Üí creates **CreditNoteLine**
  * when **true** ‚Üí **skips** line and calls `createAllowanceCharge(...)`
* `createAllowanceCharge(...)` behavior:

  * sets `LegalMonetaryTotal.AllowanceTotalAmount` only when `LegalMonetaryTotalCbcAllowanceAmount` is present
  * always appends `toAllowanceChargeList(row)` results into `creditNoteType.getAllowanceCharge()`

I‚Äôve written these in the same style as your existing `CsvInvoiceMapperTest` (no Mockito, no `eq()`, uses your generated `CsvInvoiceMapperImpl`).

---

## ‚úÖ Add these tests to `CsvInvoiceMapperTest`

```java
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class CsvInvoiceMapperTest {

    private final CsvInvoiceMapper mapper = new CsvInvoiceMapperImpl();

    @Test
    void toCreditNoteTypeGroup_whenIndicatorFalse_addsCreditLine_andDoesNotAddAllowanceCharge() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-1", new ArrayList<>());
        CsvInvoiceDto line = new CsvInvoiceDto();
        line.setInvoiceLineCbcId("1");
        line.setAllowanceChargeCbcChargeIndicator("false");
        line.setInvoiceLineCbcLineExtensionAmount("10.00");
        line.setInvoiceLineCbcVATPercentage("21");

        group.getRows().add(line);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        assertThat(credit.getCreditNoteLine()).hasSize(1);
        assertThat(credit.getAllowanceCharge()).isEmpty();
    }

    @Test
    void toCreditNoteTypeGroup_whenIndicatorTrue_skipsCreditLine_andCreatesAllowanceCharge_andSetsAllowanceTotal() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-2", new ArrayList<>());

        CsvInvoiceDto allowanceRow = new CsvInvoiceDto();
        allowanceRow.setInvoiceLineCbcId("1");
        allowanceRow.setAllowanceChargeCbcChargeIndicator("true");

        // triggers allowancetotalamount set
        allowanceRow.setLegalMonetaryTotalCbcAllowanceAmount("15.00");

        // triggers charge build in toAllowanceChargeList(row)
        allowanceRow.setAllowanceChargeCbcAmount("15.00");
        allowanceRow.setBaseAmountCbcCurrencyId("EUR");
        allowanceRow.setAllowanceChargeCbcChargeReason("Discount");

        group.getRows().add(allowanceRow);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        // because indicator true => else branch => no credit line created
        assertThat(credit.getCreditNoteLine()).isEmpty();

        // allowance total set
        assertThat(credit.getLegalMonetaryTotal()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getCurrencyID()).isEqualTo("EUR");
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getValue())
                .isEqualByComparingTo(new BigDecimal("15.00"));

        // allowanceCharge list populated from toAllowanceChargeList(row)
        assertThat(credit.getAllowanceCharge()).hasSize(1);
    }

    @Test
    void toCreditNoteTypeGroup_whenIndicatorTrue_andAllowanceAmountMissing_doesNotSetAllowanceTotal_butStillAddsAllowanceCharge() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-3", new ArrayList<>());

        CsvInvoiceDto allowanceRow = new CsvInvoiceDto();
        allowanceRow.setInvoiceLineCbcId("1");
        allowanceRow.setAllowanceChargeCbcChargeIndicator("true");

        // allowance total is NOT set when this is empty/null
        allowanceRow.setLegalMonetaryTotalCbcAllowanceAmount(null);

        // but charge list is still added
        allowanceRow.setAllowanceChargeCbcAmount("10.00");
        allowanceRow.setBaseAmountCbcCurrencyId("EUR");

        group.getRows().add(allowanceRow);

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        assertThat(credit.getCreditNoteLine()).isEmpty();

        // allowance total should remain unset
        assertThat(credit.getLegalMonetaryTotal()).isNotNull();
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount()).isNull();

        // but allowance charge should still be present
        assertThat(credit.getAllowanceCharge()).hasSize(1);
    }

    @Test
    void toCreditNoteTypeGroup_mixedRows_createsCreditLinesForNonAllowanceRows_andAllowanceChargeForAllowanceRow() {
        CsvInvoiceGroup group = new CsvInvoiceGroup("CN-4", new ArrayList<>());

        CsvInvoiceDto normal1 = new CsvInvoiceDto();
        normal1.setInvoiceLineCbcId("1");
        normal1.setAllowanceChargeCbcChargeIndicator("false");
        normal1.setInvoiceLineCbcLineExtensionAmount("100.00");
        normal1.setInvoiceLineCbcVATPercentage("21");

        CsvInvoiceDto allowance = new CsvInvoiceDto();
        allowance.setInvoiceLineCbcId("2");
        allowance.setAllowanceChargeCbcChargeIndicator("true");
        allowance.setLegalMonetaryTotalCbcAllowanceAmount("5.00");
        allowance.setAllowanceChargeCbcAmount("5.00");
        allowance.setBaseAmountCbcCurrencyId("EUR");

        CsvInvoiceDto normal2 = new CsvInvoiceDto();
        normal2.setInvoiceLineCbcId("3");
        normal2.setAllowanceChargeCbcChargeIndicator("false");
        normal2.setInvoiceLineCbcLineExtensionAmount("50.00");
        normal2.setInvoiceLineCbcVATPercentage("0");

        group.getRows().addAll(List.of(normal1, allowance, normal2));

        CreditNoteType credit = mapper.toCreditNoteTypeGroup(group);

        // only the two non-allowance rows become credit lines
        assertThat(credit.getCreditNoteLine()).hasSize(2);

        // allowance row becomes allowance charge
        assertThat(credit.getAllowanceCharge()).hasSize(1);

        // allowance total set from allowance row
        assertThat(credit.getLegalMonetaryTotal().getAllowanceTotalAmount().getValue())
                .isEqualByComparingTo("5.00");

        // tax totals computed once at end
        assertThat(credit.getTaxTotal()).isNotEmpty();
    }
}
```

---

## Notes (why these tests match your implementation)

* Your code uses:

  ```java
  boolean allowanceChargeIndicator =
      Boolean.parseBoolean(row.getAllowanceChargeCbcChargeIndicator());
  if (!allowanceChargeIndicator) { add line } else { createAllowanceCharge(...) }
  ```

  So `"true"` ‚Üí allowance branch, `"false"` ‚Üí line branch.

* `createAllowanceCharge` sets `AllowanceTotalAmount` only if the string is non-empty, and always:

  ```java
  allowanceCharge.addAll(toAllowanceChargeList(row));
  ```

These tests assert exactly those behaviors.

---

If you paste the **exact package name** and confirm whether your group constructor is `new CsvInvoiceGroup("id", new ArrayList<>())` (as shown in your earlier tests), I can tailor the imports/types so it compiles 100% without any tweaking.




------------


Yep ‚Äî your current `SplitAttachmentMover` is **very close**, but one detail in the rename logic is what breaks the ‚Äúkeep number on XML but not duplicate it on attachments‚Äù requirement.

### ‚úÖ What you want

Given:

```
A_01.xml   (output XML)
A_02.pdf
A_03.pdf
A_04.jpg
A_05.csv
```

When copying attachments for `A_01.xml`, the copied files should remain:

```
A_02.pdf, A_03.pdf, A_04.jpg, A_05.csv
```

**Not**:

```
A_01_02.pdf, A_01_03.pdf, ...
```

---

## Why it happens in your current code

In `moveAttachments()` you compute:

* `normalizedBase = normalizeAttachmentBase(xmlBaseName)`  ‚úÖ (becomes `"a"`)
* `targetBase = stripExtension(outputXmlFileName)` ‚úÖ (becomes `"A_01"`)

Then in `copySingleAttachment()` you do:

```java
String suffix = fileName.substring(baseLen);   // "_02.pdf"
Path dest = targetDir.resolve(targetBase + suffix); // "A_01" + "_02.pdf"
```

So it becomes: **`A_01_02.pdf`** ‚ùå

---

# ‚úÖ Minimal change you need

### 1) Compute a *targetPrefixWithoutSeq* (e.g. `"A"`) once in `moveAttachments()`

Add this next to `targetBase`:

```java
String targetFileName = Paths.get(outputXmlFileName).getFileName().toString();
String targetNoExt = stripExtension(targetFileName).trim();
String targetPrefix = stripTrailingSeqRaw(targetNoExt);   // "A" from "A_01"
```

Where `stripTrailingSeqRaw()` removes the last `_<digits>` **without lowercasing**:

```java
private static String stripTrailingSeqRaw(String s) {
    if (s == null) {
        return null;
    }
    int us = s.lastIndexOf('_');
    if (us < 0 || us == s.length() - 1) {
        return s;
    }
    int i = us + 1;
    while (i < s.length() && Character.isDigit(s.charAt(i))) {
        i++;
    }
    if (i == us + 1) {
        return s; // no digits after underscore
    }
    if (i != s.length()) {
        return s; // digits not at end -> don't strip
    }
    return s.substring(0, us);
}
```

### 2) Pass `targetPrefix` into `copyMatchingAttachments(...)`

Change signature:

```java
private List<Path> copyMatchingAttachments(
        Path sourceDir,
        Path targetDir,
        String normalizedBase,
        String targetBase,
        String targetPrefix) throws IOException
```

And call it like:

```java
List<Path> moved = copyMatchingAttachments(sourceDir, targetDir, normalizedBase, targetBase, targetPrefix);
```

### 3) In `copySingleAttachment()`, use `targetPrefix` (not `targetBase`) when building dest

Change method signature too:

```java
private Path copySingleAttachment(
        Path source,
        String fileName,
        String normalizedBase,
        Path targetDir,
        String targetBase,
        String targetPrefix) throws IOException
```

Then change this line:

```java
Path dest = uniqueIfExists(targetDir.resolve(targetBase + suffix));
```

to:

```java
Path dest = uniqueIfExists(targetDir.resolve(targetPrefix + suffix));
```

‚úÖ Now the output will be:

* XML stays: `A_01.xml`
* Attachments stay: `A_02.pdf`, `A_03.pdf`, ‚Ä¶

---

## Important: you do NOT need to change `normalizeAttachmentBase()`

Even though it strips `_01`, that is still correct because:

* it‚Äôs used only for **matching**
* you **don‚Äôt want** attachments to be tied to `_01`, you want them tied to the prefix (`A`)

So:

* keep stripping sequence for matching ‚úÖ
* stop using target XML seq in attachment rename ‚úÖ

---

## Quick sanity example after change

* `outputXmlFileName = A_01.xml` ‚Üí `targetPrefix = A`
* fileName = `A_02.pdf` ‚Üí suffix `_02.pdf`
* dest = `A + _02.pdf` ‚Üí `A_02.pdf` ‚úÖ

---

If you want, I can also give you a small **JUnit @TempDir test** for `SplitAttachmentMover` that creates a fake unzipped folder and verifies the copied filenames exactly match `A_02.pdf`, `A_03.pdf`, etc.



----------
Great catch ‚Äî this is exactly the right question to ask üëç
Nothing is ‚Äúmissing‚Äù at runtime, it‚Äôs just a **method you still need to define**.

Let me walk you through it cleanly and show **where it lives, why it exists, and the exact code**.

---

## What you asked about

You saw this line:

```java
return buildTaxSubtotalForVat(group, new BigDecimal("21"));
```

and asked:

> where is this method?

### ‚úÖ Answer

`buildTaxSubtotalForVat(...)` is a **new default helper method** that you must add **yourself** inside **`CsvInvoiceMapper`**.
It is **not generated by MapStruct** and it does **not already exist** unless you created it earlier.

It sits **next to** your other default methods like `toInvoiceTypeGroup(...)`.

---

## Why you need this method

You now have **two responsibilities**:

| VAT case   | How it‚Äôs calculated                                       |
| ---------- | --------------------------------------------------------- |
| VAT **0**  | Special logic ‚Üí sum `InvoiceLine_cbc_LineExtensionAmount` |
| VAT **21** | Generic logic ‚Üí sum taxable + tax amounts                 |

So you split the logic:

* `buildVatZeroSubtotal(...)` ‚Üí VAT 0 only
* `buildTaxSubtotalForVat(...)` ‚Üí generic VAT (21, maybe others later)

This keeps:

* logic **clear**
* subtotals printed **once**
* code **Sonar-friendly**

---

## Where it lives (important)

**Location:**

```java
@Mapper(componentModel = "spring")
public interface CsvInvoiceMapper {
    // ‚¨áÔ∏è HERE
}
```

It must be a **`default` method** so MapStruct does **not** try to generate it.

---

## Exact method you should add (VAT 21)

Here is the **complete, production-safe implementation**:

```java
default TaxSubtotalType buildTaxSubtotalForVat(
        CsvInvoiceGroup group,
        BigDecimal vatPercentage
) {
    BigDecimal taxableSum = BigDecimal.ZERO;
    BigDecimal taxSum = BigDecimal.ZERO;
    boolean found = false;

    for (CsvInvoiceDto row : group.getRows –∏–∑–≤–µ—Å—Ç–Ω–æ) {
        BigDecimal rowVat = toAmount(row.getInvoiceLineCbcVATPercentage());
        if (rowVat != null && rowVat.compareTo(vatPercentage) == 0) {
            found = true;

            taxableSum = taxableSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalExclVatValue())
            );

            taxSum = taxSum.add(
                safeAmount(row.getAdditionalItemPropertyCbcSubTotalVatAmountValue())
            );
        }
    }

    if (!found) {
        return null; // no VAT 21 lines ‚Üí no subtotal
    }

    TaxSubtotalType taxSubtotal = new TaxSubtotalType();

    TaxableAmountType taxableAmount = new TaxableAmountType();
    taxableAmount.setCurrencyID("EUR");
    taxableAmount.setValue(taxableSum);
    taxSubtotal.setTaxableAmount(taxableAmount);

    TaxAmountType taxAmount = new TaxAmountType();
    taxAmount.setCurrencyID("EUR");
    taxAmount.setValue(taxSum);
    taxSubtotal.setTaxAmount(taxAmount);

    TaxCategoryType category = getTaxCategory(
        vatPercentage,
        false,
        group.getRows().get(0).getItemCbcName()
    );
    taxSubtotal.setTaxCategory(category);

    return taxSubtotal;
}
```

---

## How it‚Äôs used (now it makes sense)

```java
default List<TaxTotalType> toTaxTotal(CsvInvoiceGroup group) {
    TaxTotalType taxTotal = new TaxTotalType();

    // VAT 21 (generic)
    TaxSubtotalType vat21 = buildTaxSubtotalForVat(group, new BigDecimal("21"));
    if (vat21 != null) {
        taxTotal.getTaxSubtotal().add(vat21);
    }

    // VAT 0 (special)
    TaxSubtotalType vat0 = buildVatZeroSubtotal(group);
    if (vat0 != null) {
        taxTotal.getTaxSubtotal().add(vat0);
    }

    if (taxTotal.getTaxSubtotal().isEmpty()) {
        return Collections.emptyList();
    }

    return Collections.singletonList(taxTotal);
}
```

---

## Helper you also need (already referenced)

```java
default BigDecimal safeAmount(String value) {
    if (value == null || value.isBlank()) {
        return BigDecimal.ZERO;
    }
    return toAmount(value);
}
```

---

## Final mental model (so it sticks)

* **MapStruct mappings** ‚Üí structure only
* **Default methods** ‚Üí business aggregation logic
* **`buildTaxSubtotalForVat`** ‚Üí generic VAT logic (21)
* **`buildVatZeroSubtotal`** ‚Üí special VAT 0 logic
* **`toTaxTotal(group)`** ‚Üí orchestrates both, once per invoice

Nothing is duplicated, nothing runs per line accidentally.

---

If you want, next I can:

* üîç Add **debug logs** that prove this runs once per invoice
* üß™ Write **JUnit tests** for VAT 21 + VAT 0 together
* ‚ôªÔ∏è Mirror the same logic for **CreditNote mapper**

Just tell me where you want to go next.
