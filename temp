Perfect ‚Äî that tells us you‚Äôre **very close** üéØ.

If you‚Äôre getting an exception at:

```java
Files.createDirectories(xmlDir);
```

and the stacktrace shows something like:

```
java.lang.NullPointerException: Cannot invoke "java.nio.file.Path.getFileSystem()" because "xmlDir" is null
```

then the root cause is:

> ‚úÖ The variable `xmlDir` is still `null` when you try to call `Files.createDirectories(...)`.

Let‚Äôs fix that cleanly and permanently.

---

## üß© 1Ô∏è‚É£ Understand what‚Äôs happening

You probably have something like this in your `beforeStep()` or configuration:

```java
Path xmlDir = pathConfig.getProcessed().getXml();
Files.createDirectories(xmlDir);
```

That means one of these three things is `null`:

1. `pathConfig` ‚Äî not injected or not registered
2. `pathConfig.getProcessed()` ‚Äî nested bean not initialized
3. `pathConfig.getProcessed().getXml()` ‚Äî property not bound (missing in YAML)

So let‚Äôs check all three step by step.

---

## ‚úÖ 2Ô∏è‚É£ Confirm your `PathConfig` class is correct

Here‚Äôs the **correct, bulletproof structure** for your config class:

```java
@Configuration
@ConfigurationProperties(prefix = "alphacredit.paths")
public class PathConfig {

    private Path base;
    private Path output;
    private final Processed processed = new Processed();
    private final Unzipped unzipped = new Unzipped();

    public static class Processed {
        private Path xml;
        private Path pdf;
        private Path csv;
        // getters/setters
    }

    public static class Unzipped {
        private Path xml;
        private Path csv;
        // getters/setters
    }

    // getters and setters for base, output, processed, unzipped
}
```

‚úÖ Notes:

* Use `public static` for nested classes (non-static won‚Äôt bind properly).
* Pre-initialize `processed` and `unzipped` (`new Processed()`) to avoid null.
* Make sure getters and setters are present for *every* field.

---

## ‚úÖ 3Ô∏è‚É£ Check your YAML values

In `src/test/resources/application-test.yaml` (or your active profile):

```yaml
alphacredit:
  paths:
    base: ${java.io.tmpdir}/alphacredit-test
    output: ${alphacredit.paths.base}/output
    processed:
      xml: ${alphacredit.paths.base}/processed/xml
      pdf: ${alphacredit.paths.base}/processed/pdf
      csv: ${alphacredit.paths.base}/processed/csv
    unzipped:
      xml: ${alphacredit.paths.base}/unzipped/xml
      csv: ${alphacredit.paths.base}/unzipped/csv
```

‚úÖ Make sure this file is actually loaded by your test (e.g., `spring.profiles.active=test`).

---

## ‚úÖ 4Ô∏è‚É£ Confirm Spring is binding it

Add this quick test to verify:

```java
@ActiveProfiles("test")
@SpringBootTest
class PathConfigTest {

    @Autowired
    PathConfig pathConfig;

    @Test
    void printPaths() {
        System.out.println("XML dir: " + pathConfig.getProcessed().getXml());
        System.out.println("Output dir: " + pathConfig.getOutput());
        assertNotNull(pathConfig.getProcessed().getXml());
    }
}
```

If this prints `null`, your binding or YAML isn‚Äôt correct.

---

## ‚úÖ 5Ô∏è‚É£ Defensive coding in your tasklet

Even with correct binding, you can **safeguard** against null values:

```java
@Override
public void beforeStep(StepExecution stepExecution) {
    Path xmlDir = pathConfig.getProcessed() != null
            ? pathConfig.getProcessed().getXml()
            : null;

    if (xmlDir == null) {
        throw new IllegalStateException("XML directory path is not configured (alphacredit.paths.processed.xml).");
    }

    try {
        Files.createDirectories(xmlDir);
        log.info("Created XML directory at: {}", xmlDir.toAbsolutePath());
    } catch (IOException e) {
        throw new IllegalStateException("Failed to create XML directory", e);
    }
}
```

‚úÖ This will fail fast with a clear message instead of an NPE.

---

## ‚úÖ 6Ô∏è‚É£ Optional ‚Äî set default fallback paths

If you want to *guarantee* this never fails, you can add safe defaults in `PathConfig`:

```java
private Path base = Path.of(System.getProperty("java.io.tmpdir"), "alphacredit-default");
private Path output = base.resolve("output");

public static class Processed {
    private Path xml = Path.of(System.getProperty("java.io.tmpdir"), "alphacredit-default", "processed", "xml");
    private Path pdf = Path.of(System.getProperty("java.io.tmpdir"), "alphacredit-default", "processed", "pdf");
    private Path csv = Path.of(System.getProperty("java.io.tmpdir"), "alphacredit-default", "processed", "csv");
}
```

‚úÖ Even if YAML binding fails, your code has valid `Path` objects and won‚Äôt crash.

---

## üß† 7Ô∏è‚É£ Quick checklist

| Item                                                     | What to verify                       | Expected |
| -------------------------------------------------------- | ------------------------------------ | -------- |
| `@ConfigurationProperties(prefix = "alphacredit.paths")` | Present on `PathConfig`              | ‚úÖ        |
| Nested classes `Processed`, `Unzipped`                   | Declared `public static`             | ‚úÖ        |
| `processed` and `unzipped`                               | Initialized with `new`               | ‚úÖ        |
| YAML keys                                                | Match exactly                        | ‚úÖ        |
| Active Spring profile                                    | `test` or `default` with YAML loaded | ‚úÖ        |
| Defensive null checks                                    | In your tasklet                      | ‚úÖ        |

---

## ‚úÖ 8Ô∏è‚É£ TL;DR fix

If you want the immediate, safe solution ‚Äî
replace your existing field declarations in `PathConfig` with this:

```java
private final Processed processed = new Processed();
private final Unzipped unzipped = new Unzipped();
```

and make both nested classes `public static`.

Then ensure your YAML defines:

```yaml
alphacredit.paths.processed.xml: /tmp/alphacredit-test/processed/xml
```

After that, `Files.createDirectories(xmlDir)` will run cleanly üéâ

---

Would you like me to show you the **complete corrected `PathConfig` class** (with defaults + proper Spring Boot binding) so you can drop it in directly?


‚úÖ **Absolutely ‚Äî that‚Äôs actually the *best* and cleanest approach** ‚Äî and SonarQube will also consider it safe when you externalize the directory paths.

Let‚Äôs go step-by-step so you can do this the right way for your `AlphaCredit` project structure.

---

## üß© Why this works

Sonar flags hard-coded `/tmp/...` because it‚Äôs a *publicly writable system directory*.
If you move those into your **`application.yaml`** (or `application.properties`) and read them using `@Value` or a `@ConfigurationProperties` bean, then:

* you can easily override the path in each environment (dev, UAT, prod),
* you can move away from `/tmp` in production (e.g. `/opt/alphacredit/work`),
* Sonar stops marking it as a ‚Äúsecurity hotspot‚Äù because it‚Äôs now configurable and reviewable.

---

## ‚úÖ **1. Define properties in `application.yaml`**

You can centralize all temp paths under one key (for example `alphacredit.paths`):

```yaml
alphacredit:
  paths:
    base: /opt/alphacredit
    processed:
      xml: ${alphacredit.paths.base}/processed/xml
      pdf: ${alphacredit.paths.base}/processed/pdf
      csv: ${alphacredit.paths.base}/processed/csv
    output: ${alphacredit.paths.base}/output
    unzipped:
      xml: ${alphacredit.paths.base}/unzipped/xml
      csv: ${alphacredit.paths.base}/unzipped/csv
```

‚úÖ For local/dev, you can override in `application-local.yaml`:

```yaml
alphacredit:
  paths:
    base: ${java.io.tmpdir}/alphacredit
```

---

## ‚úÖ **2. Create a configuration class**

```java
package com.bnpp.pf.einvoice.connect.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import java.nio.file.Path;

@Configuration
@ConfigurationProperties(prefix = "alphacredit.paths")
public class PathConfig {
    private Path base;
    private Processed processed = new Processed();
    private Path output;
    private Unzipped unzipped = new Unzipped();

    public static class Processed {
        private Path xml;
        private Path pdf;
        private Path csv;
        // getters + setters
    }

    public static class Unzipped {
        private Path xml;
        private Path csv;
        // getters + setters
    }

    // getters + setters
}
```

This bean now holds all your directory locations.

---

## ‚úÖ **3. Inject the config where needed**

### Example in `PackageAndUploadTasklet.java`

```java
@Component
@Slf4j
public class PackageAndUploadTasklet implements Tasklet, StepExecutionListener {

    private final PathConfig pathConfig;

    @Autowired
    public PackageAndUploadTasklet(PathConfig pathConfig) {
        this.pathConfig = pathConfig;
    }

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        Path xmlDir = pathConfig.getProcessed().getXml();
        Path outputDir = pathConfig.getOutput();
        Files.createDirectories(xmlDir);
        Files.createDirectories(outputDir);

        log.info("Using secure output path: {}", outputDir.toAbsolutePath());
        // rest of logic
        return RepeatStatus.FINISHED;
    }
}
```

### Example in `CosStorageService.java`

```java
@Service
public class CosStorageService {
    private final PathConfig pathConfig;

    @Autowired
    public CosStorageService(PathConfig pathConfig) {
        this.pathConfig = pathConfig;
    }

    public void createAndMoveFile(String fileName, InputStream inputStream) throws IOException {
        Path outputDir = pathConfig.getOutput();
        Files.createDirectories(outputDir);
        Path tempFile = Files.createTempFile(outputDir, "encryptedFile_", "_" + fileName);
        Files.setPosixFilePermissions(tempFile, PosixFilePermissions.fromString("rw-------"));
        // rest of logic
    }
}
```

---

## ‚úÖ **4. Benefits**

| Benefit              | Description                                                                 |
| -------------------- | --------------------------------------------------------------------------- |
| **Sonar clean**      | No hard-coded `/tmp` ‚Üí flagged warnings disappear                           |
| **Environment-safe** | Different paths for local, QA, prod                                         |
| **Container-ready**  | In Docker/Kubernetes, you can mount `/opt/alphacredit` as a writable volume |
| **Secure**           | You can ensure paths have restricted permissions (600/700)                  |
| **Flexible testing** | In tests, override via `@TestPropertySource` or `@DynamicPropertySource`    |

---

## ‚úÖ **5. Test override example**

In JUnit:

```java
@TestPropertySource(properties = {
  "alphacredit.paths.base=${java.io.tmpdir}/test-alpha"
})
@SpringBootTest
class PackageAndUploadTaskletTest { ... }
```

---

### üß† TL;DR

‚úÖ Yes ‚Äî move all `/tmp/...` paths into `application.yaml`.
‚úÖ Use a `@ConfigurationProperties` bean to inject them.
‚úÖ Use `${java.io.tmpdir}` for dev defaults, `/opt/...` for prod.
‚úÖ Sonar will mark these as reviewed and secure.

---

Would you like me to show you the **exact replacement diff** for your current `PackageAndUploadTasklet.java` using this new `PathConfig` (ready-to-commit version)?



Excellent üëè ‚Äî these SonarQube ‚ÄúSecurity Hotspots‚Äù are all the same category:

> **‚ÄúMake sure publicly writable directories are used safely here.‚Äù**

They appear in multiple files (e.g. `PackageAndUploadTasklet.java`, `CosStorageService.java`, `SplitPDFMover.java`, `InvoiceBatchConfiguration.java`) ‚Äî all pointing to paths like:

```java
Path.of("/tmp/processed/xml")
Path.of("/tmp/output")
File.createTempFile("encryptedFile_", fileName)
```

---

## üß© Why Sonar flags this

Sonar marks these as *potential security issues* because `/tmp` and other world-writable directories on UNIX systems are **shared among all users**.
If your app writes to `/tmp/...`, another process could:

* Predict filenames (e.g. `encryptedFile_1234.zip`)
* Replace them with symlinks or malicious files
* Read or modify sensitive data

Even if your code is harmless, Sonar asks you to confirm that these directories are used safely.

---

## ‚úÖ **How to fix / silence the finding properly**

You have 3 clean, production-safe options.

---

### ‚úÖ **Option 1 ‚Äì Use application-specific subdirectories under `java.io.tmpdir`**

Instead of hard-coding `/tmp/...`, create your own secure temp directory per run or per service.
Example (for `PackageAndUploadTasklet` and similar):

```java
private static final Path BASE_TMP_DIR =
        Path.of(System.getProperty("java.io.tmpdir"), "alphacredit", "batch");

private static final Path XML_DIR = BASE_TMP_DIR.resolve("processed/xml");
private static final Path PDF_DIR = BASE_TMP_DIR.resolve("processed/pdf");
private static final Path CSV_DIR = BASE_TMP_DIR.resolve("processed/csv");
private static final Path OUTPUT_DIR = BASE_TMP_DIR.resolve("output");

static {
    try {
        Files.createDirectories(XML_DIR);
        Files.createDirectories(PDF_DIR);
        Files.createDirectories(CSV_DIR);
        Files.createDirectories(OUTPUT_DIR);
    } catch (IOException e) {
        throw new ExceptionInInitializerError(e);
    }
}
```

‚úÖ Advantages

* No world-writable `/tmp` subpath directly.
* Directories are created with your process‚Äôs default umask ‚Üí `700` (owner-only).
* Still cross-platform and cleanly accepted by Sonar.

---

### ‚úÖ **Option 2 ‚Äì Secure the temporary files explicitly**

When you must use `File.createTempFile(...)`, add a `SecureDirectoryStream` or set restrictive permissions immediately:

```java
File tempFile = File.createTempFile("encryptedFile_", "_" + fileName);
Files.setPosixFilePermissions(tempFile.toPath(),
        PosixFilePermissions.fromString("rw-------")); // 600
```

‚úÖ Stops the ‚Äúpublicly writable directory‚Äù warning because the file itself is safe.

---

### ‚úÖ **Option 3 ‚Äì Make directory configurable**

Instead of hard-coding `/tmp/...`, inject it via `application.yaml`:

```yaml
app:
  working-dir: /opt/alphacredit/work
```

And in code:

```java
@Value("${app.working-dir:${java.io.tmpdir}/alphacredit}")
private Path baseWorkingDir;
```

Then resolve subfolders (`processed/xml`, etc.) relative to `baseWorkingDir`.

‚úÖ Keeps production under `/opt/...` and dev/test still safe under system tmp.

---

## ‚úèÔ∏è Apply these to the files you showed

| File                                 | Line(s)                                           | Recommended change                                           |
| ------------------------------------ | ------------------------------------------------- | ------------------------------------------------------------ |
| **`PackageAndUploadTasklet.java`**   | `Path.of("/tmp/processed/...")`                   | Replace with `BASE_TMP_DIR.resolve("processed/xml")` etc.    |
| **`CosStorageService.java`**         | `File.createTempFile("encryptedFile_", fileName)` | Keep but add `Files.setPosixFilePermissions(...)`            |
| **`SplitPDFMover.java`**             | `Path.of("/tmp/unzipped/xml/")`                   | Use `BASE_TMP_DIR.resolve("unzipped/xml")`                   |
| **`InvoiceBatchConfiguration.java`** | `Files.list(Path.of(TMP_UNZIPPED_CSV_PATH))`      | Replace constant with `BASE_TMP_DIR.resolve("unzipped/csv")` |

---

### ‚úÖ **Example secure helper (reuse everywhere)**

You can add a small utility:

```java
public final class SafeTempDirUtil {
    private SafeTempDirUtil() {}
    public static Path secureSubdir(String... subdirs) throws IOException {
        Path base = Path.of(System.getProperty("java.io.tmpdir"), "alphacredit");
        Path dir = base;
        for (String s : subdirs) dir = dir.resolve(s);
        Files.createDirectories(dir);
        Files.setPosixFilePermissions(dir, PosixFilePermissions.fromString("rwx------"));
        return dir;
    }
}
```

Then call:

```java
private static final Path XML_DIR = SafeTempDirUtil.secureSubdir("processed", "xml");
```

---

### ‚úÖ **If you want to suppress instead**

If these directories are *already isolated* (e.g. inside a container or a pod‚Äôs private `/tmp`),
you can keep your code and add a justification comment:

```java
// Sonar justification: /tmp is isolated inside container; only application user has access
private static final Path OUTPUT_DIR = Path.of("/tmp/output");
```

That will silence it after review.

---

### üí° **Summary**

| Approach                          | Fix Quality               | Sonar Reaction          |
| --------------------------------- | ------------------------- | ----------------------- |
| Use subdir under `java.io.tmpdir` | ‚úÖ Best                    | üü¢ Clean                |
| Add permissions after file create | ‚úÖ Good                    | üü¢ Clean                |
| Configuration via property        | ‚úÖ Best for prod           | üü¢ Clean                |
| Justify with comment              | ‚ö†Ô∏è Only for containerized | üü° Manual review needed |

---

Would you like me to show you exactly how to refactor **`PackageAndUploadTasklet`** and **`CosStorageService`** with the secure `BASE_TMP_DIR` approach (ready-to-copy version)?
