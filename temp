Yes — **use `sanitizeFilenamePreserveExtension(...)` for “actual file names”** (things that include `.xml/.pdf/.csv/.jpeg`), because it solves the exact problem you called out:

* It **sanitizes the base name**
* It **keeps the extension untouched**
* It avoids “dot replacement” breaking `.xml/.pdf`

### When to use it

Use it anywhere you sanitize something that is **already a filename** or will become one:

✅ incoming ZIP entry names (before writing to disk)
✅ supplier/party names when you append them into a filename
✅ invoice/credit-note output file names **when you already have `... + ".xml"`** and don’t want to destroy the extension

### When *not* to use it

Don’t use it for **tokens/IDs** that are *not a filename*, like:

* invoiceId (e.g. `26.51.510012`)
* contract numbers
* registry IDs

For those, use a “token sanitize” (no extension logic) so you don’t accidentally treat dots as an extension split.

---

## One improvement you asked for: strip accents (È → E) without turning into `_`

Here’s a minimal upgrade of your method that **strips accents**, preserves extension, and still uses your existing `UNSAFE_FILE_CHARS` replacement.

```java
import java.text.Normalizer;

public static String sanitizeFilenamePreserveExtension(String filename) {
    if (filename == null) return "";

    String trimmed = filename.trim();
    if (trimmed.isEmpty()) return "";

    // strip accents (È -> E), keep other chars for pattern to handle
    String normalized = Normalizer.normalize(trimmed, Normalizer.Form.NFD)
            .replaceAll("\\p{M}+", ""); // remove diacritics

    int lastDot = normalized.lastIndexOf('.');

    // No extension (or ".bashrc"-like) -> sanitize whole thing
    if (lastDot <= 0 || lastDot == normalized.length() - 1) {
        return UNSAFE_FILE_CHARS.matcher(normalized).replaceAll("_");
    }

    String base = normalized.substring(0, lastDot);
    String ext  = normalized.substring(lastDot); // includes the dot

    String safeBase = UNSAFE_FILE_CHARS.matcher(base).replaceAll("_");

    // (optional) you can also harden extension if you want:
    // ext = ext.replaceAll("[^A-Za-z0-9.]+", "");

    return safeBase + ext;
}
```

This will turn:

* `"HUITRIÈRE & EOLE.pdf"` → `"HUITRIERE_&_EOLE.pdf"` (with your current blacklist pattern)
* If you want `&` removed too, you’d need the whitelist pattern (different choice).

---

# JUnit 5: parameterized tests (fixes the Sonar “replace these 6 tests” issue)

Here’s a single parameterized test covering multiple cases, including accents + extension preservation:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

class InvoiceBatchUtilTest {

    @ParameterizedTest(name = "[{index}] \"{0}\" -> \"{1}\"")
    @MethodSource("sanitizeFilenamePreserveExtensionCases")
    void sanitizeFilenamePreserveExtension_parameterized(String input, String expected) {
        assertEquals(expected, InvoiceBatchUtil.sanitizeFilenamePreserveExtension(input));
    }

    private static Stream<Arguments> sanitizeFilenamePreserveExtensionCases() {
        return Stream.of(
                Arguments.of(null, ""),
                Arguments.of("", ""),
                Arguments.of("   ", ""),
                Arguments.of("invoice test?.xml", "invoice_test_.xml"),
                Arguments.of("my file name.pdf", "my_file_name.pdf"),
                Arguments.of("bad:name*file?.xml", "bad_name_file_.xml"),
                Arguments.of("HUITRIÈRE & EOLE.pdf", "HUITRIERE_&_EOLE.pdf"),
                Arguments.of(".bashrc", "_bashrc"),              // no extension case
                Arguments.of("noext", "noext"),                 // no extension case
                Arguments.of("trailingdot.", "trailingdot.")    // treated as no extension (kept dot), then sanitized if pattern hits
        );
    }
}
```

> Note: expected outputs assume your **current blacklist** pattern: `[\\s\\\\/:*?"<>|]+`.
> If you switch to a whitelist pattern, some expected strings change (e.g., `&` would become `_`).

---

If you paste your exact current `UNSAFE_FILE_CHARS` (and whether you want to keep `&` or not), I can adjust the expected outputs so your tests match your production behavior perfectly.
