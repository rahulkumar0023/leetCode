void zipEncryptUploadFiles(Path processedFile, String zipFilePrefix) throws IOException {
  Files.createDirectories(outputDir);

  // Step 1: Zip
  String zipFileName = zipFilePrefix + "_invoices_" + getCurrentDateTimeValue() + ".zip";
  File zipFile = outputDir.resolve(zipFileName).toFile();
  zipDirectory(processedFile, zipFile);

  // Step 2: Encrypt
  String encryptedFileName = zipFileName + ".pgp";
  File encryptedFile = outputDir.resolve(encryptedFileName).toFile();
  pgpEncrypt.encrypt(new FileInputStream(zipFile), new FileOutputStream(encryptedFile));
  log.info("Encrypted ZIP at: {}", encryptedFile.getAbsolutePath());

  // Step 3: Upload
  String key = "outgoing_e-invoice/" + encryptedFileName;
  cosStorageService.uploadFile(key, encryptedFile);
  log.info("Uploaded to COS: {}", key);

  // Step 4: Notify CFT (no waiting inside this method)
  log.info("CFT notify enabled: {}", cftEnabled);
  if (cftEnabled) {
    cftApiClient.notifyUpload(key, encryptedFileName); // returns 201 asynchronously
  }

  // ---- SIZE-BASED GRACE before moving to processed ----
  long bytes = encryptedFile.length();
  Duration grace = pickWaitByEstimate(bytes); // or pickWaitByTier(bytes)
  log.info("Payload size = {} bytes ({}). Grace wait before move = {}",
      bytes, human(bytes), grace);
  if (!grace.isZero()) {
    try { Thread.sleep(grace.toMillis()); } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
    }
  }

  // Step 5: Move to processed
  moveToProcessed(encryptedFileName, key);
}

// ---------- helpers (tweak thresholds to taste) ----------
private static Duration pickWaitByTier(long bytes) {
  long MB = 1024L * 1024L;
  if (bytes < 50 * MB)  return Duration.ZERO;           // <50MB: no wait
  if (bytes < 200 * MB) return Duration.ofSeconds(6);   // 50–200MB
  if (bytes < 1024 * MB)return Duration.ofSeconds(20);  // 200MB–1GB
  return Duration.ofMinutes(2);                         // 1GB+
}

private static Duration pickWaitByEstimate(long bytes) {
  // Replace 50 MB/s with your observed end-to-end throughput
  double assumedBps = 50 * 1024 * 1024d;
  double secs = 6 + 1.5 * (bytes / assumedBps);         // base + scaled wait
  long clamped = Math.max(0, Math.min((long)Math.ceil(secs), 2 * 60 * 60)); // cap 2h
  return Duration.ofSeconds(clamped);
}

private static String human(long bytes) {
  String[] u = {"B","KB","MB","GB","TB"};
  int i = 0; double v = bytes;
  while (v >= 1024 && i < u.length - 1) { v /= 1024; i++; }
  return String.format("%.1f %s", v, u[i]);
}
