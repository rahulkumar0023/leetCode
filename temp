You're right! To maintain proper prefixes like `cac`, `cbc` instead of `ns2`, `ns3`, we need to register a custom **`NamespacePrefixMapper`** with the marshaller.

Here's the updated full code with `UBLNamespacePrefixMapper` integrated. This assumes you're using **Glassfish JAXB runtime**, which supports `com.sun.xml.bind.marshaller.NamespacePrefixMapper`.

---

## ‚úÖ `UBLNamespacePrefixMapper.java`

```java
package com.example.batch.util;

import com.sun.xml.bind.marshaller.NamespacePrefixMapper;

public class UBLNamespacePrefixMapper extends NamespacePrefixMapper {

    @Override
    public String getPreferredPrefix(String namespaceUri, String suggestion, boolean requirePrefix) {
        return switch (namespaceUri) {
            case "urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" -> "cac";
            case "urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2" -> "cbc";
            case "urn:oasis:names:specification:ubl:schema:xsd:Invoice-2" -> ""; // Default namespace
            default -> suggestion; // fallback
        };
    }
}
```

package com.example.batch.writer;

import com.example.batch.util.UBLNamespacePrefixMapper;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBElement;
import jakarta.xml.bind.Marshaller;
import lombok.extern.slf4j.Slf4j;
import network.oxalis.peppol.ubl2.jaxb.InvoiceType;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.xml.namespace.QName;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;

@Slf4j
@Component
public class InvoiceWriter implements ItemWriter<InvoiceType> {

    private final Path xmlDir;
    private final Path pdfDir;

    public InvoiceWriter(
            @Value("${invoice.output.xml-dir:/tmp/processed/xml}") String xmlDirPath,
            @Value("${invoice.output.pdf-dir:/tmp/processed/pdf}") String pdfDirPath
    ) {
        this.xmlDir = Path.of(xmlDirPath);
        this.pdfDir = Path.of(pdfDirPath);
    }

    @Override
    public void write(Chunk<? extends InvoiceType> invoices) throws Exception {
        Files.createDirectories(xmlDir);
        Files.createDirectories(pdfDir);

        JAXBContext context = JAXBContext.newInstance(InvoiceType.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        marshaller.setProperty("com.sun.xml.bind.namespacePrefixMapper", new UBLNamespacePrefixMapper());

        for (InvoiceType invoice : invoices) {
            String id = (invoice.getID() != null && invoice.getID().getValue() != null)
                    ? invoice.getID().getValue()
                    : UUID.randomUUID().toString();

            // Write XML
            File xmlOut = xmlDir.resolve("invoice-" + id + ".xml").toFile();
            JAXBElement<InvoiceType> jaxbElement = new JAXBElement<>(
                    new QName("urn:oasis:names:specification:ubl:schema:xsd:Invoice-2", "Invoice"),
                    InvoiceType.class,
                    invoice
            );

            try (OutputStream os = new FileOutputStream(xmlOut)) {
                marshaller.marshal(jaxbElement, os);
                log.info("‚úÖ XML written: {}", xmlOut.getAbsolutePath());
            } catch (Exception e) {
                log.error("‚ùå Failed to write XML for invoice {}", id, e);
            }

            // Write placeholder PDF
            File pdfOut = pdfDir.resolve("invoice-" + id + ".pdf").toFile();
            try (FileWriter fw = new FileWriter(pdfOut)) {
                fw.write("Invoice ID: " + id + "\n(More invoice details here)");
                log.info("üìÑ PDF written: {}", pdfOut.getAbsolutePath());
            } catch (Exception e) {
                log.error("‚ùå Failed to write PDF for invoice {}", id, e);
            }
        }
    }
}

```

---

‚úÖ This should eliminate the extra `xmlns:nsX` noise and give you only `cac`, `cbc`, and the default namespace at the root.

Let me know if you're using **Jakarta JAXB 4.0+**, and I‚Äôll adjust the mapper accordingly using `jakarta.xml.bind.annotation.XmlNs`.

```

---

package com.example.batch.writer;

import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.Unmarshaller;
import network.oxalis.peppol.ubl2.jaxb.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.item.Chunk;

import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertTrue;

class InvoiceWriterTest {

    @Test
    void testWriteWithSampleInvoice() throws Exception {
        // Load sample invoice XML from test resources
        InputStream is = getClass().getResourceAsStream("/sample-invoice.xml");
        JAXBContext context = JAXBContext.newInstance(InvoiceType.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InvoiceType invoice = (InvoiceType) unmarshaller.unmarshal(is);

        // Set temp output dirs
        Path tempXmlDir = Files.createTempDirectory("test-xml");
        Path tempPdfDir = Files.createTempDirectory("test-pdf");

        InvoiceWriter writer = new InvoiceWriter(tempXmlDir.toString(), tempPdfDir.toString());
        writer.write(Chunk.of(invoice));

        // Verify output files
        assertTrue(Files.list(tempXmlDir).findFirst().isPresent(), "XML file should be created");
        assertTrue(Files.list(tempPdfDir).findFirst().isPresent(), "PDF file should be created");
    }
}

```

---

### üîß Add this to `application.yml` (optional):

```yaml
invoice:
  output:
    xml-dir: /tmp/processed/xml
    pdf-dir: /tmp/processed/pdf
```

---

Would you like to assert **XML contents** too in the tests? I can help with that next.





Absolutely! Here‚Äôs a clean implementation of a PDF invoice reader class (PdfInvoiceReader) along with a corresponding JUnit 5 test class.

‚∏ª

‚úÖ PdfInvoiceReader.java

This reads .pdf files from a given directory pattern and returns them as Resource items:

package com.example.batch.reader;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.ItemReader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.ResourcePatternResolver;

import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

@Slf4j
public class PdfInvoiceReader implements ItemReader<Resource> {

    private final Iterator<Resource> resourceIterator;

    public PdfInvoiceReader(ResourcePatternResolver resolver, String pattern) throws IOException {
        Resource[] resources = resolver.getResources(pattern);
        List<Resource> resourceList = Arrays.stream(resources)
                .filter(Resource::isReadable)
                .toList();
        this.resourceIterator = resourceList.iterator();
        log.info("üîç Found {} PDF files to process.", resourceList.size());
    }

    @Override
    public Resource read() {
        if (resourceIterator.hasNext()) {
            Resource next = resourceIterator.next();
            log.info("üìÑ Reading PDF file: {}", next.getFilename());
            return next;
        }
        return null; // Signals end of reading
    }
}


‚∏ª

‚úÖ PdfInvoiceReaderTest.java

A test that loads PDFs from src/test/resources/pdf and verifies reading:

package com.example.batch.reader;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class PdfInvoiceReaderTest {

    private PdfInvoiceReader reader;

    @BeforeEach
    void setUp() throws Exception {
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        reader = new PdfInvoiceReader(resolver, "classpath:pdf/*.pdf");
    }

    @Test
    void shouldReadAllPdfResources() throws Exception {
        List<Resource> pdfs = new ArrayList<>();
        Resource pdf;
        while ((pdf = reader.read()) != null) {
            assertNotNull(pdf.getFilename());
            assertTrue(pdf.getFilename().endsWith(".pdf"));
            pdfs.add(pdf);
        }
        assertFalse(pdfs.isEmpty(), "No PDFs were read from classpath.");
    }
}


‚∏ª

üß™ Test Setup Notes
	‚Ä¢	Place at least one sample .pdf in src/test/resources/pdf/.
	‚Ä¢	The test reads all PDF files matching classpath:pdf/*.pdf.

Would you also like a PDF text extractor for validation in tests?
