Got you. Here’s a **mac-friendly (POSIX sh)** script that supports **multiple ports per host** and outputs a **real CSV**: one row per IP in **nslookup order**.

### `nslookup_in_order_multiport_csv.sh`

```sh
#!/bin/sh
# Usage: ./nslookup_in_order_multiport_csv.sh hosts.txt > nslookup.csv
# hosts.txt lines can be:
#   host.example.com:443
#   host.example.com:443,8443  (spaces / ; / / are also ok)
#   host.only.com              (no port; blank port in CSV)

set -eu
[ "$#" -eq 1 ] || { echo "Usage: $0 hosts.txt" >&2; exit 1; }

hosts_file=$1
echo "hostname,port,ip,rank"

lookup_ips() {
  h="$1"
  {
    nslookup -type=A "$h"
    nslookup -type=AAAA "$h"
  } 2>/dev/null \
  | awk '
      /^Name:[ \t]/ {seen=1; next}
      !seen {next}
      /^Address:[ \t]/      {print $2; next}
      /^Addresses:[ \t]*/   {
        sub(/^Addresses:[ \t]*/, "", $0); gsub(/^[ \t]+|[ \t]+$/, "", $0)
        if (length($0)) print $0
        multi=1; next
      }
      multi && /^[ \t]*[0-9a-fA-F:.]+$/ {
        gsub(/^[ \t]+|[ \t]+$/, "", $0)
        if (length($0)) print $0
        next
      }
      multi && !/^[ \t]/ { multi=0 }
    ' | awk 'NF'
}

# If files came from Windows, pre-clean:  perl -pi -e "s/\r$//" hosts.txt
while IFS= read -r line || [ -n "$line" ]; do
  case "$line" in ''|\#*) continue ;; esac

  host=${line%%:*}
  rest=${line#*:}
  [ "$host" = "$rest" ] && rest=""   # no port provided

  ips="$(lookup_ips "$host")"        # newline-separated; in nslookup order

  if [ -n "$rest" ]; then
    # Expand multiple ports: split on comma / space / semicolon / slash
    printf '%s' "$rest" \
    | tr ',;/ ' '\n' | sed '/^$/d' \
    | while IFS= read -r port; do
        case "$port" in ''|*[!0-9]*) continue ;; esac
        rank=0
        printf '%s\n' "$ips" | while IFS= read -r ip; do
          [ -z "$ip" ] && continue
          rank=$((rank+1))
          printf '%s,%s,%s,%s\n' "$host" "$port" "$ip" "$rank"
        done
      done
  else
    # No port: print rows with blank port
    rank=0
    printf '%s\n' "$ips" | while IFS= read -r ip; do
      [ -z "$ip" ] && continue
      rank=$((rank+1))
      printf '%s,,%s,%s\n' "$host" "$ip" "$rank"
    done
  fi
done < "$hosts_file"
```

**Run**

```bash
chmod +x nslookup_in_order_multiport_csv.sh
# (optional if you hit encoding issues)
export LC_ALL=C LANG=C
./nslookup_in_order_multiport_csv.sh hosts.txt > nslookup.csv
```

**Output columns**

* `hostname` — from your list (order preserved)
* `port` — each port expanded (multi-port supported)
* `ip` — one row per IP
* `rank` — 1,2,3… in the exact order **nslookup** returned

If you instead want a single row per host\:port with a quoted `ip_list` field (comma-separated), say the word and I’ll drop that variant too.


Absolutely—here are focused, drop-in **JUnit 5** test classes to cover:

1. the **processor** (CSV → `InvoiceType` or `CreditNoteType`)
2. the **classifier writer** (routes to your two writers)
3. an **end-to-end step test** (reader → processor → classifier writer) proving items are routed correctly

Assumptions:

* Package names for UBL classes are the standard ones (adjust if yours differ).
* You have `spring-boot-starter-test`, `spring-batch-test`, and `mockito` on the classpath.

---

# 1) Processor test

```java
package com.alphacredit.batch.processing;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvToUblProcessor processor;

  @Test
  void returnsCreditNote_whenTypeCode381() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381");
    var cn = new CreditNoteType();
    when(mapper.toCreditNoteType(dto)).thenReturn(cn);

    Object out = processor.process(dto);

    assertTrue(out instanceof CreditNoteType);
    verify(mapper).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void returnsInvoice_otherwise() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380");
    var inv = new InvoiceType();
    when(mapper.toInvoiceType(dto)).thenReturn(inv);

    Object out = processor.process(dto);

    assertTrue(out instanceof InvoiceType);
    verify(mapper).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }
}
```

---

# 2) Classifier writer test

This verifies that objects are dispatched to the correct writer.

```java
package com.alphacredit.batch.writer;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UblClassifierWriterTest {

  @SuppressWarnings("unchecked")
  @Test
  void routesToCorrectDelegate() throws Exception {
    // Arrange: two concrete writers
    ItemWriter<InvoiceType> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<CreditNoteType> creditWriter = mock(ItemWriter.class);

    // Build the classifier writer just like in your WriterConfig
    ClassifierCompositeItemWriter<Object> classifier = new ClassifierCompositeItemWriter<>();
    classifier.setClassifier(item -> {
      if (item instanceof InvoiceType) return (ItemWriter<Object>)(ItemWriter<?>)invoiceWriter;
      if (item instanceof CreditNoteType) return (ItemWriter<Object>)(ItemWriter<?>)creditWriter;
      throw new IllegalArgumentException("Unsupported: " + item.getClass());
    });

    // Input batch: 2 invoices + 1 credit note
    var inv1 = new InvoiceType();
    var inv2 = new InvoiceType();
    var cn1  = new CreditNoteType();

    // Act
    classifier.write(List.of(inv1, cn1, inv2));

    // Assert: each delegate got only the items of its type
    ArgumentCaptor<List<InvoiceType>> invCap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(2)).write(invCap.capture());
    // Because ClassifierCompositeItemWriter calls delegate per-item, we expect multiple single-item lists
    assertEquals(2, invCap.getAllValues().size());
    assertTrue(invCap.getAllValues().stream().allMatch(l -> l.size() == 1 && l.get(0) instanceof InvoiceType));

    ArgumentCaptor<List<CreditNoteType>> cnCap = ArgumentCaptor.forClass(List.class);
    verify(creditWriter, times(1)).write(cnCap.capture());
    assertEquals(1, cnCap.getAllValues().size());
    assertEquals(1, cnCap.getValue().size());
    assertTrue(cnCap.getValue().get(0) instanceof CreditNoteType);

    verifyNoMoreInteractions(invoiceWriter, creditWriter);
  }
}
```

---

# 3) End-to-end step test (Spring Batch)

This spins up a minimal Spring context and proves that:

* the **processor** converts based on `InvoiceTypeCode`
* the **classifier** routes to the right writer
* both writers get called the expected number of times

We’ll use **stub writers** that just record what they saw.

```java
package com.alphacredit.batch.step;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.*;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.*;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CsvToXmlStepTest.Config.class)
class CsvToXmlStepTest {

  @Autowired JobLauncher launcher;
  @Autowired Job job;
  @Autowired Config.RecordingInvoiceWriter invWriter;
  @Autowired Config.RecordingCreditWriter cnWriter;

  @Test
  void routesInvoicesAndCreditNotes() throws Exception {
    JobExecution exec = launcher.run(job, new JobParameters());
    assertEquals(BatchStatus.COMPLETED, exec.getStatus());

    // We fed 2 invoices + 1 creditnote (see reader below)
    assertEquals(2, invWriter.items.size());
    assertEquals(1, cnWriter.items.size());
  }

  // ---- Test configuration ----
  @Configuration
  @EnableBatchProcessing
  static class Config {

    // Simple reader that returns 3 DTOs: 2 invoices (380) + 1 credit (381)
    @Bean
    ItemReader<CsvInvoiceDto> reader() {
      List<CsvInvoiceDto> list = new ArrayList<>();
      list.add(dto("INV-1", "380"));
      list.add(dto("INV-2", "380"));
      list.add(dto("CN-1",  "381"));
      return new ListItemReader<>(list);
    }

    private static CsvInvoiceDto dto(String id, String typeCode) {
      CsvInvoiceDto d = new CsvInvoiceDto();
      d.setInvoiceNumber(id);
      d.setInvoiceTypeCode(typeCode);
      return d;
    }

    // Mapper stub that makes minimal UBL objects
    @Bean
    CsvInvoiceMapper mapper() {
      return new CsvInvoiceMapper() {
        @Override public InvoiceType toInvoiceType(CsvInvoiceDto src) {
          InvoiceType inv = new InvoiceType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          inv.setID(id);
          return inv;
        }
        @Override public CreditNoteType toCreditNoteType(CsvInvoiceDto src) {
          CreditNoteType cn = new CreditNoteType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          cn.setID(id);
          return cn;
        }
      };
    }

    @Bean CsvToUblProcessor processor(CsvInvoiceMapper mapper) { return new CsvToUblProcessor(mapper); }

    // Recording writers (stand-ins for your XMLInvoiceWriter / XMLCreditNoteWriter)
    @Bean RecordingInvoiceWriter invoiceWriter() { return new RecordingInvoiceWriter(); }
    @Bean RecordingCreditWriter creditWriter()   { return new RecordingCreditWriter(); }

    @Bean
    @SuppressWarnings("unchecked")
    ClassifierCompositeItemWriter<Object> classifierWriter(RecordingInvoiceWriter inv, RecordingCreditWriter cn) {
      ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();
      cw.setClassifier(item -> {
        if (item instanceof InvoiceType)     return (ItemWriter<Object>)(ItemWriter<?>) inv;
        if (item instanceof CreditNoteType)  return (ItemWriter<Object>)(ItemWriter<?>) cn;
        throw new IllegalArgumentException("Unsupported: " + item);
      });
      return cw;
    }

    @Bean
    Job job(JobRepository repo, PlatformTransactionManager tx,
            ItemReader<CsvInvoiceDto> reader,
            CsvToUblProcessor processor,
            ClassifierCompositeItemWriter<Object> writer) {
      Step step = new StepBuilder("csvToXmlStep", repo)
          .<CsvInvoiceDto, Object>chunk(10, tx)
          .reader(reader)
          .processor(processor)
          .writer(writer)
          .build();
      return new JobBuilder("testJob", repo).start(step).build();
    }

    // --- recording writers
    static class RecordingInvoiceWriter implements ItemWriter<InvoiceType> {
      final List<InvoiceType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends InvoiceType> items) { this.items.addAll(items); }
    }
    static class RecordingCreditWriter implements ItemWriter<CreditNoteType> {
      final List<CreditNoteType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends CreditNoteType> items) { this.items.addAll(items); }
    }
  }
}
```

---

## What these tests give you

* ✅ **Processor logic**: confidently flips to `CreditNoteType` when `InvoiceTypeCode == 381`.
* ✅ **Routing**: classifier sends each object to the correct concrete writer.
* ✅ **Step integration**: with a real Batch step, confirms two invoices + one credit note end up in the expected writers.

If you want, I can also add quick tests for your `BucketResolver` on both `InvoiceType` and `CreditNoteType` using your latest implementation, but since you already validated that earlier, these three should cover your CSV→polymorphic UBL flow end-to-end.


Absolutely—here are focused, drop-in **JUnit 5** test classes to cover:

1. the **processor** (CSV → `InvoiceType` or `CreditNoteType`)
2. the **classifier writer** (routes to your two writers)
3. an **end-to-end step test** (reader → processor → classifier writer) proving items are routed correctly

Assumptions:

* Package names for UBL classes are the standard ones (adjust if yours differ).
* You have `spring-boot-starter-test`, `spring-batch-test`, and `mockito` on the classpath.

---

# 1) Processor test

```java
package com.alphacredit.batch.processing;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvToUblProcessorTest {

  @Mock CsvInvoiceMapper mapper;
  @InjectMocks CsvToUblProcessor processor;

  @Test
  void returnsCreditNote_whenTypeCode381() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("381");
    var cn = new CreditNoteType();
    when(mapper.toCreditNoteType(dto)).thenReturn(cn);

    Object out = processor.process(dto);

    assertTrue(out instanceof CreditNoteType);
    verify(mapper).toCreditNoteType(dto);
    verify(mapper, never()).toInvoiceType(any());
  }

  @Test
  void returnsInvoice_otherwise() throws Exception {
    var dto = new CsvInvoiceDto();
    dto.setInvoiceTypeCode("380");
    var inv = new InvoiceType();
    when(mapper.toInvoiceType(dto)).thenReturn(inv);

    Object out = processor.process(dto);

    assertTrue(out instanceof InvoiceType);
    verify(mapper).toInvoiceType(dto);
    verify(mapper, never()).toCreditNoteType(any());
  }
}
```

---

# 2) Classifier writer test

This verifies that objects are dispatched to the correct writer.

```java
package com.alphacredit.batch.writer;

import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UblClassifierWriterTest {

  @SuppressWarnings("unchecked")
  @Test
  void routesToCorrectDelegate() throws Exception {
    // Arrange: two concrete writers
    ItemWriter<InvoiceType> invoiceWriter = mock(ItemWriter.class);
    ItemWriter<CreditNoteType> creditWriter = mock(ItemWriter.class);

    // Build the classifier writer just like in your WriterConfig
    ClassifierCompositeItemWriter<Object> classifier = new ClassifierCompositeItemWriter<>();
    classifier.setClassifier(item -> {
      if (item instanceof InvoiceType) return (ItemWriter<Object>)(ItemWriter<?>)invoiceWriter;
      if (item instanceof CreditNoteType) return (ItemWriter<Object>)(ItemWriter<?>)creditWriter;
      throw new IllegalArgumentException("Unsupported: " + item.getClass());
    });

    // Input batch: 2 invoices + 1 credit note
    var inv1 = new InvoiceType();
    var inv2 = new InvoiceType();
    var cn1  = new CreditNoteType();

    // Act
    classifier.write(List.of(inv1, cn1, inv2));

    // Assert: each delegate got only the items of its type
    ArgumentCaptor<List<InvoiceType>> invCap = ArgumentCaptor.forClass(List.class);
    verify(invoiceWriter, times(2)).write(invCap.capture());
    // Because ClassifierCompositeItemWriter calls delegate per-item, we expect multiple single-item lists
    assertEquals(2, invCap.getAllValues().size());
    assertTrue(invCap.getAllValues().stream().allMatch(l -> l.size() == 1 && l.get(0) instanceof InvoiceType));

    ArgumentCaptor<List<CreditNoteType>> cnCap = ArgumentCaptor.forClass(List.class);
    verify(creditWriter, times(1)).write(cnCap.capture());
    assertEquals(1, cnCap.getAllValues().size());
    assertEquals(1, cnCap.getValue().size());
    assertTrue(cnCap.getValue().get(0) instanceof CreditNoteType);

    verifyNoMoreInteractions(invoiceWriter, creditWriter);
  }
}
```

---

# 3) End-to-end step test (Spring Batch)

This spins up a minimal Spring context and proves that:

* the **processor** converts based on `InvoiceTypeCode`
* the **classifier** routes to the right writer
* both writers get called the expected number of times

We’ll use **stub writers** that just record what they saw.

```java
package com.alphacredit.batch.step;

import com.alphacredit.batch.domain.CsvInvoiceDto;
import com.alphacredit.batch.mapping.CsvInvoiceMapper;
import com.alphacredit.batch.processing.CsvToUblProcessor;
import oasis.names.specification.ubl.schema.xsd.creditnote_2.CreditNoteType;
import oasis.names.specification.ubl.schema.xsd.invoice_2.InvoiceType;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.*;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.*;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CsvToXmlStepTest.Config.class)
class CsvToXmlStepTest {

  @Autowired JobLauncher launcher;
  @Autowired Job job;
  @Autowired Config.RecordingInvoiceWriter invWriter;
  @Autowired Config.RecordingCreditWriter cnWriter;

  @Test
  void routesInvoicesAndCreditNotes() throws Exception {
    JobExecution exec = launcher.run(job, new JobParameters());
    assertEquals(BatchStatus.COMPLETED, exec.getStatus());

    // We fed 2 invoices + 1 creditnote (see reader below)
    assertEquals(2, invWriter.items.size());
    assertEquals(1, cnWriter.items.size());
  }

  // ---- Test configuration ----
  @Configuration
  @EnableBatchProcessing
  static class Config {

    // Simple reader that returns 3 DTOs: 2 invoices (380) + 1 credit (381)
    @Bean
    ItemReader<CsvInvoiceDto> reader() {
      List<CsvInvoiceDto> list = new ArrayList<>();
      list.add(dto("INV-1", "380"));
      list.add(dto("INV-2", "380"));
      list.add(dto("CN-1",  "381"));
      return new ListItemReader<>(list);
    }

    private static CsvInvoiceDto dto(String id, String typeCode) {
      CsvInvoiceDto d = new CsvInvoiceDto();
      d.setInvoiceNumber(id);
      d.setInvoiceTypeCode(typeCode);
      return d;
    }

    // Mapper stub that makes minimal UBL objects
    @Bean
    CsvInvoiceMapper mapper() {
      return new CsvInvoiceMapper() {
        @Override public InvoiceType toInvoiceType(CsvInvoiceDto src) {
          InvoiceType inv = new InvoiceType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          inv.setID(id);
          return inv;
        }
        @Override public CreditNoteType toCreditNoteType(CsvInvoiceDto src) {
          CreditNoteType cn = new CreditNoteType();
          var id = new oasis.names.specification.ubl.schema.xsd.commonbasiccomponents_2.IDType();
          id.setValue(src.getInvoiceNumber());
          cn.setID(id);
          return cn;
        }
      };
    }

    @Bean CsvToUblProcessor processor(CsvInvoiceMapper mapper) { return new CsvToUblProcessor(mapper); }

    // Recording writers (stand-ins for your XMLInvoiceWriter / XMLCreditNoteWriter)
    @Bean RecordingInvoiceWriter invoiceWriter() { return new RecordingInvoiceWriter(); }
    @Bean RecordingCreditWriter creditWriter()   { return new RecordingCreditWriter(); }

    @Bean
    @SuppressWarnings("unchecked")
    ClassifierCompositeItemWriter<Object> classifierWriter(RecordingInvoiceWriter inv, RecordingCreditWriter cn) {
      ClassifierCompositeItemWriter<Object> cw = new ClassifierCompositeItemWriter<>();
      cw.setClassifier(item -> {
        if (item instanceof InvoiceType)     return (ItemWriter<Object>)(ItemWriter<?>) inv;
        if (item instanceof CreditNoteType)  return (ItemWriter<Object>)(ItemWriter<?>) cn;
        throw new IllegalArgumentException("Unsupported: " + item);
      });
      return cw;
    }

    @Bean
    Job job(JobRepository repo, PlatformTransactionManager tx,
            ItemReader<CsvInvoiceDto> reader,
            CsvToUblProcessor processor,
            ClassifierCompositeItemWriter<Object> writer) {
      Step step = new StepBuilder("csvToXmlStep", repo)
          .<CsvInvoiceDto, Object>chunk(10, tx)
          .reader(reader)
          .processor(processor)
          .writer(writer)
          .build();
      return new JobBuilder("testJob", repo).start(step).build();
    }

    // --- recording writers
    static class RecordingInvoiceWriter implements ItemWriter<InvoiceType> {
      final List<InvoiceType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends InvoiceType> items) { this.items.addAll(items); }
    }
    static class RecordingCreditWriter implements ItemWriter<CreditNoteType> {
      final List<CreditNoteType> items = new CopyOnWriteArrayList<>();
      @Override public void write(List<? extends CreditNoteType> items) { this.items.addAll(items); }
    }
  }
}
```

---

## What these tests give you

* ✅ **Processor logic**: confidently flips to `CreditNoteType` when `InvoiceTypeCode == 381`.
* ✅ **Routing**: classifier sends each object to the correct concrete writer.
* ✅ **Step integration**: with a real Batch step, confirms two invoices + one credit note end up in the expected writers.

If you want, I can also add quick tests for your `BucketResolver` on both `InvoiceType` and `CreditNoteType` using your latest implementation, but since you already validated that earlier, these three should cover your CSV→polymorphic UBL flow end-to-end.
