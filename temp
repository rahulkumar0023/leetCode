Yep — Sonar is complaining because the loop has **multiple `continue`**. Easiest fix: **invert the logic** and do the work inside a single `if (shouldCopy)` block (no `continue`, no `break`). That keeps it clean and readable.

Here’s the **Sonar-friendly** rewrite of just that loop section:

```java
try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
    for (Path p : stream) {

        boolean isFile = Files.isRegularFile(p);
        String name = isFile ? p.getFileName().toString() : "";
        String lower = isFile ? name.toLowerCase(Locale.ROOT) : "";

        boolean isXmlItself = isFile && lower.equals(normalizedBase + ".xml");
        boolean isAttachment = isFile && lower.startsWith(normalizedBase + "-");
        boolean shouldCopy = isAttachment && !isXmlItself;

        if (shouldCopy) {
            String suffix = name.substring(xmlBaseName.length()); // e.g. "-1.pdf"
            String destName = targetBase + suffix;

            Path dest = uniqueIfExists(targetDir.resolve(destName));
            Files.copy(p, dest, StandardCopyOption.COPY_ATTRIBUTES);

            moved.add(dest);
        }
    }
}
```

### Why this passes Sonar

* **0 `continue`**, **0 `break`**
* all conditions are expressed explicitly
* the loop has a single “action path”

If you want it even tighter (still Sonar-safe), you can remove the “empty string” trick and wrap in `if (Files.isRegularFile(p))` — still no `continue`:

```java
try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
    for (Path p : stream) {
        if (Files.isRegularFile(p)) {
            String name = p.getFileName().toString();
            String lower = name.toLowerCase(Locale.ROOT);

            boolean shouldCopy = lower.startsWith(normalizedBase + "-")
                    && !lower.equals(normalizedBase + ".xml");

            if (shouldCopy) {
                String suffix = name.substring(xmlBaseName.length());
                String destName = targetBase + suffix;

                Path dest = uniqueIfExists(targetDir.resolve(destName));
                Files.copy(p, dest, StandardCopyOption.COPY_ATTRIBUTES);
                moved.add(dest);
            }
        }
    }
}
```

Either version satisfies “use at most one break/continue” (actually uses none).


---------------------
Yes — with the new rule (**A.xml can have A-1.pdf, A-2.jpg, A-3.anything**), you should **replace the “single PDF mover” assumption** with a **generic attachment mover** that:

* finds **all files belonging to the same XML base**
* supports **any extension**
* copies them to the same output folder (alongside the generated XML)
* optionally renames them to match your **new output XML name** (finance naming, timestamp naming, etc.)

Below is the **final set of changes** (minimal, clean, Sonar/Fortify safe) + **JUnit tests**.

---

# ✅ What changes in behavior?

### Old

* one PDF expected: `<fileId>.pdf`
* move only that

### New

* attachments can be:

  * `A-1.pdf`
  * `A-2.pdf`
  * `A-3.jpeg`
  * etc.
* so for XML `A.xml`, we copy **all files that start with `A-`** (case-insensitive) from the unzipped folder to the output folder.

---

# 1) Replace `SplitPDFMover` with `SplitAttachmentMover`

Create a new class (or refactor existing one) that handles **multiple attachments + any type**.

```java
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

@Slf4j
@Component
@RequiredArgsConstructor
public class SplitAttachmentMover {

    private final PathConfig pathConfig;

    /**
     * Move/copy all attachments that belong to the XML base name.
     *
     * Example:
     *  xmlBaseName = "A"  -> copies: A-1.pdf, A-2.jpg, A-3.png, ...
     *
     * Renames attachments to follow output XML base name:
     *  outputXmlFileName = "20250115_SUPPLIER_INV_ABC.xml"
     *  => 20250115_SUPPLIER_INV_ABC-1.pdf, ...-2.jpg, etc.
     */
    public List<Path> moveAttachments(String xmlBaseName, String outputXmlFileName, Path targetDir) {
        Path sourceDir = pathConfig.getUnzipped().getXml();

        if (xmlBaseName == null || xmlBaseName.isBlank()) {
            log.warn("XML base name is blank. Skipping attachment move.");
            return List.of();
        }
        if (outputXmlFileName == null || outputXmlFileName.isBlank()) {
            log.warn("Output XML file name is blank. Skipping attachment move.");
            return List.of();
        }
        if (targetDir == null) {
            log.warn("Target directory is null. Skipping attachment move.");
            return List.of();
        }

        String normalizedBase = xmlBaseName.toLowerCase(Locale.ROOT);
        String targetBase = stripExtension(Paths.get(outputXmlFileName).getFileName().toString());

        List<Path> moved = new ArrayList<>();

        try {
            Files.createDirectories(targetDir);

            try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir)) {
                for (Path p : stream) {
                    if (!Files.isRegularFile(p)) {
                        continue;
                    }

                    String name = p.getFileName().toString();
                    String lower = name.toLowerCase(Locale.ROOT);

                    // Match: "<base>-<anything>" and NOT the xml itself.
                    if (lower.equals(normalizedBase + ".xml")) {
                        continue;
                    }
                    if (!lower.startsWith(normalizedBase + "-")) {
                        continue;
                    }

                    String suffix = name.substring(xmlBaseName.length()); // keeps "-1.pdf" with original case/extension
                    String destName = targetBase + suffix;

                    Path dest = uniqueIfExists(targetDir.resolve(destName));
                    Files.copy(p, dest, StandardCopyOption.COPY_ATTRIBUTES);

                    moved.add(dest);
                }
            }

            if (moved.isEmpty()) {
                log.debug("No attachments found for base '{}'", xmlBaseName);
            } else {
                log.info("Moved {} attachment(s) for base '{}'", moved.size(), xmlBaseName);
            }
            return moved;

        } catch (IOException ex) {
            // Do NOT fail invoice. Just log and continue.
            log.error("Failed moving attachments for base '{}': {}", xmlBaseName, ex.getMessage());
            return List.of();
        }
    }

    private static String stripExtension(String fileName) {
        int dot = fileName.lastIndexOf('.');
        if (dot > 0) {
            return fileName.substring(0, dot);
        }
        return fileName;
    }

    private static Path uniqueIfExists(Path dest) {
        if (!Files.exists(dest)) {
            return dest;
        }

        String name = dest.getFileName().toString();
        String base = stripExtension(name);
        String ext = "";

        int dot = name.lastIndexOf('.');
        if (dot > 0) {
            ext = name.substring(dot);
        }

        Path dir = dest.getParent();
        int i = 2;

        Path candidate = dir.resolve(base + "-" + i + ext);
        while (Files.exists(candidate)) {
            i++;
            candidate = dir.resolve(base + "-" + i + ext);
        }
        return candidate;
    }
}
```

### Notes

* Uses `Locale.ROOT` ✅
* avoids path traversal issues (we’re listing local dir entries) ✅
* does not fail invoice on attachment errors (your fault tolerance requirement) ✅

---

# 2) Update `XmlInvoiceWriter.updateInvoiceName(...)`

Replace:

```java
pdfMover.movePDF(invoiceId, invoiceFileName, outputDir);
```

With:

```java
String xmlBaseName = invoiceId; // MUST be base name without ".xml"
attachmentMover.moveAttachments(xmlBaseName, invoiceFileName, outputDir);
```

So your writer becomes:

```java
String invoiceId = registry.lookup(invoice); // should return base like "A" not "A.xml"
attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);
```

✅ This will move A-1.pdf, A-2.jpg, etc into output dir with the **same prefix as new xml output name**.

---

# 3) Make sure `registry.lookup(invoice)` returns the XML base

Right now you previously used it for `<fileId>.pdf`.
Now you need it to be the **original XML base**, e.g.:

* xml file: `A.xml`
* base: `A`

If it returns `A.xml`, fix it once:

```java
String invoiceId = registry.lookup(invoice);
if (invoiceId != null && invoiceId.toLowerCase(Locale.ROOT).endsWith(".xml")) {
    invoiceId = invoiceId.substring(0, invoiceId.length() - 4);
}
attachmentMover.moveAttachments(invoiceId, invoiceFileName, outputDir);
```

---

# 4) JUnit 5 test for full coverage

This test creates a temp “unzipped/xml” dir with:

* `A.xml`
* `A-1.pdf`
* `A-2.jpeg`
* `B-1.pdf` (should NOT be moved)

Then verifies results are copied & renamed using output XML base.

```java
import org.junit.jupiter.api.Test;

import java.nio.file.*;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class SplitAttachmentMoverTest {

    @Test
    void moveAttachments_copiesAllMatchingFiles_andRenamesToOutputBase() throws Exception {

        Path unzippedXml = Files.createTempDirectory("unzipped-xml");
        Path outDir = Files.createTempDirectory("out-xml");

        // create files
        Files.writeString(unzippedXml.resolve("A.xml"), "<xml/>");
        Files.write(unzippedXml.resolve("A-1.pdf"), "pdf1".getBytes());
        Files.write(unzippedXml.resolve("A-2.jpeg"), "img2".getBytes());
        Files.write(unzippedXml.resolve("B-1.pdf"), "other".getBytes());

        // PathConfig stub
        PathConfig pathConfig = new PathConfig() {
            @Override
            public Unzipped getUnzipped() {
                return new Unzipped() {
                    @Override public Path getXml() { return unzippedXml; }
                };
            }
        };

        SplitAttachmentMover mover = new SplitAttachmentMover(pathConfig);

        List<Path> moved = mover.moveAttachments("A", "NEWNAME_INV_123.xml", outDir);

        assertEquals(2, moved.size());

        Path pdf = outDir.resolve("NEWNAME_INV_123-1.pdf");
        Path jpeg = outDir.resolve("NEWNAME_INV_123-2.jpeg");

        assertTrue(Files.exists(pdf));
        assertTrue(Files.exists(jpeg));

        assertEquals("pdf1", Files.readString(pdf));
        assertEquals("img2", Files.readString(jpeg));

        // must not copy B-1.pdf
        assertFalse(Files.exists(outDir.resolve("NEWNAME_INV_123-1.pdf-2")));
        assertFalse(Files.exists(outDir.resolve("B-1.pdf")));
    }
}
```

> If your `PathConfig` / `Unzipped` are concrete classes (not interfaces), tell me their signatures and I’ll adapt the test to compile exactly.

---

# ✅ Where this fits in your pipeline

You already do:

* write output xml
* then move supporting files into output dir

This new mover keeps the same step placement, but supports **multi attachments**.

---

# Optional next enhancement (if attachments are inside the XML itself)

If the attachments are *embedded* via `EmbeddedDocumentBinaryObject`, you can **extract from XML** instead of relying on zip side-files. That’s a separate add-on, and we can integrate it later.

---

If you confirm:

1. Are these attachments **separate files in the ZIP** next to the XML (most likely)?
2. Or are they **embedded inside the XML**?

…I’ll lock the final production implementation (including where to hook it in the bundle and how to keep COS cleanup intact).
