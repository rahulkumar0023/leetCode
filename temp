That‚Äôs a great detail üëç ‚Äî your current `CsvInvoiceReader` is already doing the **low-level CSV parsing** (`DelimitedLineTokenizer`, `SmartCsvInvoiceFieldSetMapper`, etc.). You don‚Äôt need to throw that away.

üëâ The trick is: keep your existing `CsvInvoiceReader` *as-is* (so you still get 1 `CsvInvoiceDto` per row), and **wrap it** in a ‚Äúgrouping reader‚Äù that combines consecutive rows with the same `invoiceId`.

---

## How it looks

```
CsvInvoiceReader (your class)
        ‚Üì  (1 CsvInvoiceDto per row)
GroupingCsvReader (new wrapper)
        ‚Üì  (CsvInvoiceGroup per invoiceId)
Processor (CsvInvoiceGroup ‚Üí InvoiceType with many lines)
        ‚Üì
XML Writer
```

---

## 1. Grouping wrapper around your reader

```java
@Component
@StepScope
public class GroupingCsvReader implements ItemReader<CsvInvoiceGroup>, ResourceAwareItemReaderItemStream<CsvInvoiceGroup> {

    private final CsvInvoiceReader delegate; // your existing reader
    private CsvInvoiceDto buffer;
    private Resource resource;

    public GroupingCsvReader(CsvInvoiceReader delegate) {
        this.delegate = delegate;
    }

    @Override
    public void setResource(Resource resource) {
        this.resource = resource;
        delegate.setResource(resource); // forward to your current reader
    }

    @Override
    public CsvInvoiceGroup read() throws Exception {
        List<CsvInvoiceDto> group = new ArrayList<>();
        CsvInvoiceDto first = (buffer != null) ? buffer : delegate.read();
        buffer = null;
        if (first == null) return null;

        String invoiceId = first.getInvoiceNumber();
        group.add(first);

        CsvInvoiceDto next;
        while ((next = delegate.read()) != null) {
            if (!invoiceId.equals(next.getInvoiceNumber())) {
                buffer = next; // save for next call
                break;
            }
            group.add(next);
        }

        return new CsvInvoiceGroup(invoiceId, group);
    }

    @Override
    public void open(ExecutionContext executionContext) throws ItemStreamException {
        delegate.open(executionContext);
    }

    @Override
    public void update(ExecutionContext executionContext) throws ItemStreamException {
        delegate.update(executionContext);
    }

    @Override
    public void close() throws ItemStreamException {
        delegate.close();
    }
}
```

---

## 2. CsvInvoiceGroup DTO

```java
@Data
@AllArgsConstructor
public class CsvInvoiceGroup {
    private String invoiceId;
    private List<CsvInvoiceDto> rows;
}
```

---

## 3. Processor: group ‚Üí InvoiceType

```java
@Component
@RequiredArgsConstructor
public class CsvGroupToInvoiceProcessor implements ItemProcessor<CsvInvoiceGroup, InvoiceType> {

    private final CsvInvoiceMapper mapper;

    @Override
    public InvoiceType process(CsvInvoiceGroup group) {
        return mapper.toInvoiceType(group);
    }
}
```

---

## 4. Mapper update

```java
@Mapper(componentModel = "spring")
public interface CsvInvoiceMapper {

    @Mapping(target = "ID", expression = "java(toID(group.getInvoiceId()))")
    @Mapping(target = "invoiceLine", expression = "java(toInvoiceLines(group.getRows()))")
    InvoiceType toInvoiceType(CsvInvoiceGroup group);

    default List<InvoiceLineType> toInvoiceLines(List<CsvInvoiceDto> rows) {
        List<InvoiceLineType> lines = new ArrayList<>();
        for (CsvInvoiceDto row : rows) {
            InvoiceLineType line = new InvoiceLineType();
            // map row ‚Üí line fields here
            lines.add(line);
        }
        return lines;
    }

    default IDType toID(String id) {
        IDType t = new IDType();
        t.setValue(id);
        return t;
    }
}
```

---

## 5. Step wiring

Instead of wiring your old `CsvInvoiceReader` directly:

```java
@Bean
public Step csvToXmlStep(GroupingCsvReader reader,
                         CsvGroupToInvoiceProcessor processor,
                         XMLInvoiceWriter writer) {
    return stepBuilderFactory.get("csvToXmlStep")
        .<CsvInvoiceGroup, InvoiceType>chunk(50)
        .reader(reader)
        .processor(processor)
        .writer(writer)
        .build();
}
```

---

‚úÖ This way you don‚Äôt lose your tokenizer/line-mapper logic ‚Äî your `CsvInvoiceReader` still produces `CsvInvoiceDto` per row.
‚úÖ The wrapper groups them into invoices before mapping.
‚úÖ One invoice ID = one XML with multiple `<InvoiceLine>` entries.

---

Do you want me to also show the **CreditNote variant** (same grouping, but `CreditNoteLineType` instead of `InvoiceLineType`), since you‚Äôve already got `InvoiceTypeCode` deciding between the two?
