Ahh, that error is coming from this line in the test:

```java
Field modifiers = Field.class.getDeclaredField("modifiers");
```

On modern JDKs (12+), `Field.modifiers` is no longer accessible, so the old trick of stripping `final` off a `private static final` field doesn’t work anymore. Instead of trying to mutate those constants, just **don’t change them**. Create the real folders/files where your class expects them (e.g. `/tmp/...`) and let the tasklet run normally.

Here’s a **revised full test** for `PackageAndUploadTasklet` that avoids touching `modifiers`, calls `beforeStep(...)`, and still verifies zip→pgp→upload (+ optional CFT notify). It **only reads** the static path constants and creates files there.

```java
package com.bnpp.pf.einvoice.connect.batch.tasklet;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.core.*;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Test suite for PackageAndUploadTasklet that does NOT mutate static finals.
 * We simply create files in the actual static directories the class uses.
 */
@ExtendWith(MockitoExtension.class)
class PackageAndUploadTaskletTest {

    @Mock private CosStorageService cosStorageService;
    @Mock private CftApiClient cftApiClient;
    @Mock private PGPEncrypt pgpEncrypt;

    private PackageAndUploadTasklet tasklet;

    private Path OUTPUT_DIR;
    private Path XML_DIR;
    private Path PDF_DIR;
    private Path CSV_DIR;

    @BeforeEach
    void setUp() throws Exception {
        tasklet = new PackageAndUploadTasklet(cosStorageService, cftApiClient, pgpEncrypt);

        // Read (not modify!) the static final paths from the class
        OUTPUT_DIR = getPathConst("OUTPUT_DIR");
        XML_DIR    = getPathConst("XML_DIR");
        PDF_DIR    = getPathConst("PDF_DIR");
        CSV_DIR    = getPathConst("CSV_DIR");

        // Ensure directories exist and are clean
        Files.createDirectories(OUTPUT_DIR);
        cleanDir(OUTPUT_DIR);
        Files.createDirectories(XML_DIR);
        cleanDir(XML_DIR);
        Files.createDirectories(PDF_DIR);
        cleanDir(PDF_DIR);
        Files.createDirectories(CSV_DIR);
        cleanDir(CSV_DIR);

        // Default: enable CFT notify; you can flip it per-test
        setBooleanField(tasklet, "cftEnabled", true);
    }

    private static Path getPathConst(String name) throws Exception {
        Field f = PackageAndUploadTasklet.class.getDeclaredField(name);
        f.setAccessible(true);
        return (Path) f.get(null); // static field
    }

    private static void cleanDir(Path dir) throws IOException {
        if (Files.exists(dir)) {
            try (var s = Files.list(dir)) {
                s.forEach(p -> p.toFile().delete());
            }
        }
    }

    private static void setBooleanField(Object target, String fieldName, boolean value) throws Exception {
        Field f = target.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.setBoolean(target, value);
    }

    private static Path touch(Path dir, String fileName, String content) throws IOException {
        Files.createDirectories(dir);
        Path p = dir.resolve(fileName);
        Files.writeString(p, content);
        return p;
    }

    private static StepExecution newStepExecutionWithFlag(Boolean hasCsv) {
        JobExecution je = new JobExecution(1L);
        if (hasCsv != null) {
            je.getExecutionContext().put("hasCsv", hasCsv);
        }
        return new StepExecution("pkg", je);
    }

    /** Stub PGP to just create a .pgp file output */
    private void stubEncryptWritesOutput() throws Exception {
        doAnswer(inv -> {
            try (InputStream in = inv.getArgument(0);
                 FileOutputStream out = inv.getArgument(1)) {
                if (in != null) in.transferTo(out);
                out.write(1);
            }
            return null;
        }).when(pgpEncrypt).encrypt(any(InputStream.class), any(FileOutputStream.class));
    }

    @Test
    void zipsEncryptsUploads_XML_and_PDF_when_hasCsv_false_and_notifies_cft() throws Exception {
        // arrange
        StepExecution se = newStepExecutionWithFlag(false);
        tasklet.beforeStep(se);

        touch(XML_DIR, "miles.xml", "<a/>");
        touch(XML_DIR, "finance.xml", "<b/>");
        touch(PDF_DIR, "doc.pdf", "%PDF-1.4");

        stubEncryptWritesOutput();

        // act
        RepeatStatus status = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        // assert
        assertThat(status).isEqualTo(RepeatStatus.FINISHED);

        // Two processed directories -> two uploads + two notifies
        verify(cosStorageService, times(2))
                .uploadFile(startsWith("outgoing-e-invoice/"), argThat((File f) -> f.getName().endsWith(".pgp")));
        verify(cftApiClient, times(2)).notifyUpload(startsWith("outgoing-e-invoice/"), endsWith(".pgp"));

        // Ensure PGP artifacts exist under OUTPUT_DIR
        long pgpCount;
        try (var s = Files.walk(OUTPUT_DIR)) {
            pgpCount = s.filter(p -> p.getFileName().toString().endsWith(".pgp")).count();
        }
        assertThat(pgpCount).isEqualTo(2);
    }

    @Test
    void processes_only_CSV_when_hasCsv_true_and_does_NOT_notify_when_flag_off() throws Exception {
        // arrange
        setBooleanField(tasklet, "cftEnabled", false);
        StepExecution se = newStepExecutionWithFlag(true);
        tasklet.beforeStep(se);

        touch(CSV_DIR, "invoices.csv", "id,amount\n1,10.00");
        // even if others exist, the code path should prefer CSV when hasCsv=true
        touch(XML_DIR, "other.xml", "<x/>");
        touch(PDF_DIR, "other.pdf", "%PDF-1.4");

        stubEncryptWritesOutput();

        // act
        RepeatStatus status = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        // assert
        assertThat(status).isEqualTo(RepeatStatus.FINISHED);
        verify(cosStorageService, times(1))
                .uploadFile(contains("outgoing-e-invoice/"), argThat((File f) -> f.getName().endsWith(".pgp")));
        verifyNoInteractions(cftApiClient);
    }

    @Test
    void skips_when_all_directories_empty() throws Exception {
        // arrange
        StepExecution se = newStepExecutionWithFlag(false);
        tasklet.beforeStep(se);

        // act
        RepeatStatus status = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        // assert
        assertThat(status).isEqualTo(RepeatStatus.FINISHED);
        verifyNoInteractions(pgpEncrypt, cosStorageService, cftApiClient);
    }

    @Test
    void zip_contains_all_files_from_directory() throws Exception {
        // arrange
        StepExecution se = newStepExecutionWithFlag(false);
        tasklet.beforeStep(se);

        touch(XML_DIR, "a.xml", "<a/>");
        touch(XML_DIR, "b.xml", "<b/>");
        stubEncryptWritesOutput();

        // act
        tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

        // find produced ZIP in OUTPUT_DIR
        Path zip = Files.list(OUTPUT_DIR)
                .filter(p -> p.getFileName().toString().endsWith(".zip"))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Expected a .zip in OUTPUT_DIR"));

        // assert entries
        var names = new ArrayList<String>();
        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zip))) {
            for (ZipEntry e; (e = zis.getNextEntry()) != null; ) {
                names.add(e.getName());
            }
        }
        assertThat(names).contains("a.xml", "b.xml");
    }
}
```

### Why this fixes the issue

* We **don’t touch** `Field.modifiers` (no illegal reflection).
* We **call `beforeStep(...)`** so `this.stepExecution` in your tasklet is set.
* We **create files** in the real static directories your code uses.
* PGP encryption is **stubbed** to just write a byte; no crypto needed.

If you prefer not to use `/tmp` in tests at all, the longer-term fix is to make those dirs configurable (via `@Value`) and inject a JUnit `@TempDir` path — happy to show that version too.
