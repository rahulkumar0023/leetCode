Here you go — a single, drop-in JUnit 5 test class that generates the .zip and .zip.pgp files on the fly, mocks PGPDecrypt and CosStorageService, and fully covers execute(...) (happy CSV, happy XML, empty list, mismatch, decrypt error).

Update the package and any field/method names (e.g., fetchEncryptedFiles, jobType) to match your code.

// src/test/java/com/bnpp/pf/einvoice/connect/batch/tasklet/FetchDecryptUnzipTaskletExecuteTest.java
package com.bnpp.pf.einvoice.connect.batch.tasklet;

import com.bnpp.pf.einvoice.connect.cos.CosStorageService;
import com.bnpp.pf.einvoice.connect.exception.InvoiceProcessingException;
import com.bnpp.pf.einvoice.connect.pgp.PGPDecrypt;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

class FetchDecryptUnzipTaskletExecuteTest {

  private static final Path CSV_TARGET = Path.of("/tmp/unzipped");
  private static final Path XML_TARGET = CSV_TARGET.resolve("xml");

  @TempDir Path tmp;

  private PGPDecrypt pgpDecrypt;
  private CosStorageService cos;
  private FetchDecryptUnzipTasklet tasklet;

  @BeforeEach
  void setup() throws Exception {
    // mocks
    pgpDecrypt = mock(PGPDecrypt.class);
    cos = mock(CosStorageService.class);

    // class under test
    tasklet = new FetchDecryptUnzipTasklet();
    ReflectionTestUtils.setField(tasklet, "pgpDecrypt", pgpDecrypt);
    ReflectionTestUtils.setField(tasklet, "cosStorageService", cos);

    // ensure target dirs exist & are clean
    Files.createDirectories(CSV_TARGET);
    Files.createDirectories(XML_TARGET);
    try (var s = Files.list(CSV_TARGET)) { s.forEach(p -> p.toFile().delete()); }
    try (var s = Files.list(XML_TARGET)) { s.forEach(p -> p.toFile().delete()); }

    // default decrypt behavior: copy bytes input -> output (pretend “decrypt”)
    doAnswer(inv -> {
      try (InputStream in = inv.getArgument(0);
           OutputStream out = inv.getArgument(1)) {
        in.transferTo(out);
      }
      return null;
    }).when(pgpDecrypt).decrypt(any(InputStream.class), any(OutputStream.class));
  }

  // ---------- tests ----------

  @Test
  void execute_returnsFinished_whenNoFiles_andSetsNoFlags() throws Exception {
    when(cos.fetchEncryptedFiles()).thenReturn(List.of());

    StepExecution se = newStepExec();
    RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

    assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
    assertThat(se.getJobExecution().getExecutionContext().containsKey("hasCsv")).isFalse();
    assertThat(se.getJobExecution().getExecutionContext().containsKey("hasXml")).isFalse();
  }

  @Test
  void execute_csvFlow_setsHasCsvTrue_andUnzipsToCsvTarget() throws Exception {
    // jobType = csv
    ReflectionTestUtils.setField(tasklet, "jobType", "csv");

    Path zip = makeZip(tmp.resolve("file_csv.zip"), "a.csv", "id,amt\n1,100");
    Path pgp = encrypt(zip);
    when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

    StepExecution se = newStepExec();
    RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

    assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
    assertThat(se.getJobExecution().getExecutionContext().get("hasCsv")).isEqualTo(Boolean.TRUE);
    assertThat(Files.list(CSV_TARGET).anyMatch(p -> p.toString().endsWith(".csv"))).isTrue();
  }

  @Test
  void execute_xmlFlow_setsHasXmlTrue_andUnzipsToXmlTarget() throws Exception {
    // jobType = xml
    ReflectionTestUtils.setField(tasklet, "jobType", "xml");

    Path zip = makeZip(tmp.resolve("file_xml.zip"), "doc.xml", "<a/>");
    Path pgp = encrypt(zip);
    when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

    StepExecution se = newStepExec();
    RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

    assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
    assertThat(se.getJobExecution().getExecutionContext().get("hasXml")).isEqualTo(Boolean.TRUE);
    assertThat(Files.list(XML_TARGET).anyMatch(p -> p.toString().endsWith(".xml"))).isTrue();
  }

  @Test
  void execute_mismatchBetweenJobTypeAndFileSuffix_skipsDecryptAndFlags() throws Exception {
    // jobType = csv but file name has "_xml" (so should skip)
    ReflectionTestUtils.setField(tasklet, "jobType", "csv");

    Path zip = makeZip(tmp.resolve("file_xml.zip"), "doc.xml", "<x/>");
    Path pgp = encrypt(zip); // name contains "_xml"
    when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

    StepExecution se = newStepExec();
    RepeatStatus rs = tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)));

    assertThat(rs).isEqualTo(RepeatStatus.FINISHED);
    assertThat(se.getJobExecution().getExecutionContext().containsKey("hasCsv")).isFalse();
    verify(pgpDecrypt, never()).decrypt(any(), any());
    assertThat(Files.list(CSV_TARGET).findAny().isPresent()).isFalse();
  }

  @Test
  void execute_decryptError_throwsInvoiceProcessingException() throws Exception {
    ReflectionTestUtils.setField(tasklet, "jobType", "csv");

    Path zip = makeZip(tmp.resolve("broken_csv.zip"), "a.csv", "x");
    Path pgp = encrypt(zip);
    when(cos.fetchEncryptedFiles()).thenReturn(List.of(pgp.toFile()));

    doThrow(new RuntimeException("boom"))
        .when(pgpDecrypt).decrypt(any(InputStream.class), any(OutputStream.class));

    StepExecution se = newStepExec();

    assertThatThrownBy(() ->
        tasklet.execute(new StepContribution(se), new ChunkContext(new StepContext(se)))
    ).isInstanceOf(InvoiceProcessingException.class);
  }

  // ---------- helpers ----------

  private static StepExecution newStepExec() {
    return new StepExecution("fetchDecryptUnzip", new JobExecution(System.nanoTime()));
  }

  private static Path makeZip(Path zip, String entryName, String content) throws Exception {
    Files.createDirectories(zip.getParent());
    try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip))) {
      if (entryName.endsWith("/")) {
        zos.putNextEntry(new ZipEntry(entryName));
        zos.closeEntry();
      } else {
        zos.putNextEntry(new ZipEntry(entryName));
        zos.write(content.getBytes(StandardCharsets.UTF_8));
        zos.closeEntry();
      }
    }
    return zip;
  }

  /** Simulate encryption by copying to a .pgp file; real crypto is mocked by PGPDecrypt */
  private static Path encrypt(Path zip) throws Exception {
    Path pgp = zip.resolveSibling(zip.getFileName().toString() + ".pgp"); // e.g., file_csv.zip.pgp
    Files.copy(zip, pgp, StandardCopyOption.REPLACE_EXISTING);
    return pgp;
  }
}

Notes
	•	If your tasklet uses different field names (e.g., fileType instead of jobType) or a different COS method (e.g., downloadToTemp), just tweak the ReflectionTestUtils.setField(...) and the mock when(...) lines.
	•	The test ensures /tmp/unzipped and /tmp/unzipped/xml exist before asserting, matching your production paths. If you’ve made the base dir configurable, inject that property into the tasklet (and the test) instead.
