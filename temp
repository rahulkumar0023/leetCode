private static Duration pick(long bytes) {
    return WaitPolicy.pickWaitByTier(bytes);
  }

  @Test
  void tinyFile_under1MB_returns3s() {
    assertEquals(Duration.ofSeconds(3), pick(700 * 1024L)); // ~0.68 MB
    assertEquals(Duration.ofSeconds(3), pick(0));           // 0 bytes
  }

  @Test
  void smallFile_between1AndUnder5MB_returns6s() {
    assertEquals(Duration.ofSeconds(6), pick(1 * WaitPolicy.MB));            // exactly 1 MB
    assertEquals(Duration.ofSeconds(6), pick(2 * WaitPolicy.MB));            // 2 MB
    assertEquals(Duration.ofSeconds(6), pick(5 * WaitPolicy.MB - 1));        // just under 5 MB
  }

  @Test
  void boundary_exactly5MB_entersLinearRule_base6PlusMB() {
    // 5 MB -> ceil(5) = 5 => 6 + 5 = 11s
    assertEquals(Duration.ofSeconds(11), pick(5 * WaitPolicy.MB));
  }

  @Test
  void justOver5MB_ceilsToNextMB_thenLinear() {
    long bytes = 5 * WaitPolicy.MB + 1; // ~5.000001 MB -> ceil -> 6 MB
    // 6 + 6 = 12s
    assertEquals(Duration.ofSeconds(12), pick(bytes));
  }

  @Test
  void typical_midSize_120MB_waits6Plus120s() {
    assertEquals(Duration.ofSeconds(126), pick(120 * WaitPolicy.MB)); // 6 + 120
  }

  @Test
  void linearRule_isCappedAtMaxWait() {
    // 700 MB -> 6 + 700 = 706 seconds, but cap is 600s (10 minutes)
    assertEquals(Duration.ofSeconds(WaitPolicy.MAX_WAIT_SEC), pick(700 * WaitPolicy.MB));
  }

  @Test
  void rounding_behavior_for_fractionalMB_in_linear_path() {
    // 5.01 MB -> ceil to 6 MB => 6 + 6 = 12s
    long fivePointOhOneMB = (long) Math.ceil(5.01 * WaitPolicy.MB);
    assertEquals(Duration.ofSeconds(12), pick(fivePointOhOneMB));

    // 9.9 MB -> ceil to 10 MB => 6 + 10 = 16s
    long ninePointNineMB = (long) Math.ceil(9.9 * WaitPolicy.MB);
    assertEquals(Duration.ofSeconds(16), pick(ninePointNineMB));
  }
